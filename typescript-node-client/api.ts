/**
 * New FreshBooks
 * # Quick Start   The column on the right hand side has a curl call that demonstrates the required Headers and general format of requests to the FreshBooks API.  Requests are authenticated using OAuth2 Bearer tokens which you receive in exchange for a code we issue after a logged-in user performs an authorization grant request. You can create an OAuth application and get a `client_id` and `secret` at the [developer page](https://my.freshbooks.com/#/developer).  The FreshBooks API is an interface for accessing your FreshBooks data using JSON. The API makes it easy to create web and desktop applications that integrate with your account. Possible uses for it include automatically creating and sending invoices when users sign up on your website, pulling lists of client information, copying data to 3rd party services, and more...  Check out our Scenarios and API Reference sections to see what to expect, and when you're ready, sign up for a FreshBooks account if you don't have one, and proceed to the [developer page](https://my.freshbooks.com/#/developer) to create an application and start development.  Oh, and we're not trying to be secretive about the URL of the developer page, it's: <https://www.my.freshbooks.com/#/developer>   # Required Headers   There are two required headers:  1. `Content-Type: application/json` 2. `Authorization: Bearer`   # Sign up for a FreshBooks account If you don't have one, create a [FreshBooks account](https://www.freshbooks.com/#/signup). You can reach out to our support team at  to have your account put on our partner plan. Then visit the developer page to create an application, and follow our OAuth documentation to start issuing Bearer tokens and making authenticated calls. # CONCEPTS AND IDEAS  # Adding a Logo to your Invoice  In order for you to add a logo to your FreshBooks invoice, you will need to do it in two steps.  1. Upload your logo to your FreshBooks account using the Uploader endpoint 2. Apply your logo to your invoice  # Uploading your Logo  Using the Uploader endpoint, add your .png or .jpg file. Your response will contain a `jwt` value. Take that value and add it to your GET call for your new invoice.  You can now use the POST Single Invoice (or Update Invoice) endpoint to apply your logo to an invoice. You will need to add your `jwt` token under presentation at `img_src_logo`.  **Note: The presentation payload also allows you to set colours based on hex code, change the style of your invoice and a few other customizable options.**  # Adding a Receipt to your Expense  This process is similar to adding a logo to an invoice. You will first need to upload the expense image via the uploader endpoint (See the Postman call for the Uploader). You will then receive back a response with the `jwt` key and it's associated value.   You will use then add this value in your POST body to add this newly uploaded receipt to an expense. For an example, check out the Expenses folder below.  # Adding a Payment Gateway to your Invoice  To add a payment gateway to your invoice you will first need to make sure that you have gone through the \"Know Your Client\" process in FreshBooks. This will ensure that you comply to the Terms of Service with either/both of our payment processors, Stripe and FreshBooks Payments. This process will require you to sign up for an account, fill in your business and banking details, tell them what type of business you're managing and how often you would like to have funds deposited into your bank account.   Once you have gone through the KYC process, you can then toggle online payments on an invoice by setting `\"allowed_gatewayids\"` to their corresponding payment processor under your invoices call. We use `26` for Stripe and `30` for FreshBooks Payments. For an example of this, look under invoices and choose the PUT call for \"Toggle Online Payments on Invoice\".  # Getting a Shareable Link to your Invoice   To create a shareable link for your invoice, you need to add an `includes%5B%5D=share_link` parameter to the end of your GET call for the invoice you are looking to share. You will need to make sure the invoice has already been marked as sent. If you want to mark an invoice as sent you can simply follow the steps under invoices (Hint: adding `\"status\"` as `2`  to the body of your PUT call should do the trick.)   You will then receive back a `direct_link` which can be shared as you see fit. As an example, sometimes our users will add this to an invoice that gets sent out independently from FreshBooks or as a reminder to pay your bill.   # Getting all the Includes Parameters  Our Includes parameters allow for additional payloads to be added to your existing call, but are hidden unless explicitly called for.  All the Includes parameters associated with your calls can be found in one of the LIST examples posted below. For example, if you want to see the associated Includes parameters for an invoice, simply click on the `List Invoices`. You will see a list of available Includes a description related to each of them.   # Identity Model   ## Account IDs & Business IDs  Users may interact with more than one business in the new FreshBooks. Users are uniquely identified by their email across all of the new FreshBooks, so if leafy@example.com is an Administrator of one account and gets added as a Client on another, they will have some access to both. They could then open a second business of their own, or be added as an employee of another person’s business—we live complicated lives!  That's why calls to our API must state what Business or Account they want to work on. You can find ids for the Businesses and Accounts a user can interact with by making a call to the Identity Info endpoin. An example of its response is in the code pane on the right. The two keys we care about most are `roles` and `business_memberships`.  Most roles have an accountid, as do all of the business objects listed in the `business_memberships`. Those business objects also each have an `id`, which is their `business_id`. Be careful not to mistake those ids for the `id` in the `business_membership` object.  ## Acting on a Specific Account   Calls to the `/accounting` endpoints take this form:  *  `/accounting/account///`  Calls to the `/timetracking/` and `/projects/` endpoints often require a , for example:  * `/timetracking/business//time_entries` *  All users have a `business_id`. Most users have accounts, but not all. When a Client receives an invoice, views it, and saves it, they will exist as an Identity in our system with a Role on a Business, but they do not have an Account. If you know your integration will never need to deal with someone who is just a Client and hasn’t got their own Account, you can ignore this. If you aren’t sure of that, you must gracefully handle the case where you cannot find an for a user.  # Error Codes **Number**|**Error Code**|**Description** :-----:|:-----:|:-----: 409|Conflict|The resource being modified is being modified by another request. 500|FreshAlchemyUnexpected|The ORM encountered an unexpected error. 1001|RequiredField|A required field is missing 1003|AccessDenied|You do not have access to perform the action requested. 1004|InvalidValue|A Value passed was not of the right type or range. 1005|ParseError|The server was unable to parse your request, possibly due to a syntactical error in the request format. 1006|MappingError|  1039|ValuesBackwardsError|  1042|InactiveAccountError|The account referred to in the request is inactive. 1007|DateRangeBackwardsError|A supplied date range must have the earlier date first. 1008|DateRangeRequiredError|A field in the request that requires a date range was not supplied one. 1009|DuplicateGroupByClause|The request caused an attempt to group by a column that is already used for a group by in a query. 1010|UnknownGroupByClause|The request caused an attempt to group by an unknown column in a query. 1011|DeletedResource|The resource referred to in the request is deleted. 1012|UnknownResource|The resource referred to in the request cannot be found. 1013|InvalidPerPage|The 'per\\_page' argument in the request was not a positive integer. 1014|InvalidPage|The 'page' argument in the request was not a positive integer. 1015|MappingErrorNumber|  1016|MappingErrorDateTime|  1033|MappingErrorDate|  1031|MappingErrorBoolean|  1017|MaxLengthExceeded|The request, or a line in the request, was too long. 1018|InvalidPercentValue|Percent values should be strings formatted as decimals. 1019|ItemDuplicateTax|A tax being added to an item seems to already exist. 1020|FileUploadFailed|  1021|FileDownloadFailed|  1022|FileDeleteFailed|  1023|FilterErrorDate|  1024|FilterErrorNumber|  1032|FilterErrorBoolean|  1034|FilterErrorList|  1025|InvalidNegativeValue|A value in the request that was negative should not be. 1026|DuplicateTax|The tax in the request already exists. 1027|InvalidCharacter|  1028|InvalidLessThanOneValue|  1029|InvalidDuplicateValue|  1030|InvalidRangeValue|  1035|InvalidMappingType|  1036|UnicodeOutOfRange|  1037|FilterErrorScalar|  1038|WriteAccessDenied|  1040|InvalidTotal|  1100|SystemVisitException|  1101|SystemAlreadyVisited|  1102|MaximumContractorChainLengthReached|  1103|LateReminderPositionNotSupported|  1104|OldVisStateAttributeCouldNotBeSet|  1105|CannotUpdateIpAddress|  1106|CannotUpdateLandingUrl|  1107|CannotUpdateReferringUrl|  1108|CannotUpdateReferralid| 
 *
 * OpenAPI spec version: 1.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import localVarRequest = require('request');
import http = require('http');
import Promise = require('bluebird');

let defaultBasePath = 'https://api.freshbooks.com';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */
let primitives = [
                    "string",
                    "boolean",
                    "double",
                    "integer",
                    "long",
                    "float",
                    "number",
                    "any"
                 ];

class ObjectSerializer {

    public static findCorrectType(data: any, expectedType: string) {
        if (data == undefined) {
            return expectedType;
        } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        } else if (expectedType === "Date") {
            return expectedType;
        } else {
            if (enumsMap[expectedType]) {
                return expectedType;
            }

            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }

            // Check the discriminator
            let discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            } else {
                if (data[discriminatorProperty]) {
                    return data[discriminatorProperty]; // use the type given in the discriminator
                } else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    }

    public static serialize(data: any, type: string) {
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.serialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return data.toString();
        } else {
            if (enumsMap[type]) {
                return data;
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }

            // get the map for the correct type.
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            let instance: {[index: string]: any} = {};
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
            }
            return instance;
        }
    }

    public static deserialize(data: any, type: string) {
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.deserialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return new Date(data);
        } else {
            if (enumsMap[type]) {// is Enum
                return data;
            }

            if (!typeMap[type]) { // dont know the type
                return data;
            }
            let instance = new typeMap[type]();
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);
            }
            return instance;
        }
    }
}

export class Abilities {
    'abilities': Array<Abilities1>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "abilities",
            "baseName": "abilities",
            "type": "Array<Abilities1>"
        }    ];

    static getAttributeTypeMap() {
        return Abilities.attributeTypeMap;
    }
}

export class Abilities1 {
    'name': string;
    'value': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Abilities1.attributeTypeMap;
    }
}

export class Ability {
    'name': string;
    'value': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Ability.attributeTypeMap;
    }
}

export class Ability2 {
    'timeEntryId': number;
    'abilities': Array<Ability>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "timeEntryId",
            "baseName": "time_entry_id",
            "type": "number"
        },
        {
            "name": "abilities",
            "baseName": "abilities",
            "type": "Array<Ability>"
        }    ];

    static getAttributeTypeMap() {
        return Ability2.attributeTypeMap;
    }
}

export class AcceptEstimateRequest {
    'estimate': Estimate6;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "estimate",
            "baseName": "estimate",
            "type": "Estimate6"
        }    ];

    static getAttributeTypeMap() {
        return AcceptEstimateRequest.attributeTypeMap;
    }
}

export class Account {
    '_030': Model030;
    '_3160': Model030;
    '_6190': Model030;
    '_91': Model030;
    'email': string;
    'fname': string;
    'lname': string;
    'organization': string;
    'total': Total;
    'userid': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_030",
            "baseName": "0-30",
            "type": "Model030"
        },
        {
            "name": "_3160",
            "baseName": "31-60",
            "type": "Model030"
        },
        {
            "name": "_6190",
            "baseName": "61-90",
            "type": "Model030"
        },
        {
            "name": "_91",
            "baseName": "91+",
            "type": "Model030"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "fname",
            "baseName": "fname",
            "type": "string"
        },
        {
            "name": "lname",
            "baseName": "lname",
            "type": "string"
        },
        {
            "name": "organization",
            "baseName": "organization",
            "type": "string"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "Total"
        },
        {
            "name": "userid",
            "baseName": "userid",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Account.attributeTypeMap;
    }
}

export class Account1 {
    'accountName': string;
    'accountNumber': string;
    'balances': Array<Balance1>;
    'subAccounts': Array<SubAccount>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountName",
            "baseName": "account_name",
            "type": "string"
        },
        {
            "name": "accountNumber",
            "baseName": "account_number",
            "type": "string"
        },
        {
            "name": "balances",
            "baseName": "balances",
            "type": "Array<Balance1>"
        },
        {
            "name": "subAccounts",
            "baseName": "sub_accounts",
            "type": "Array<SubAccount>"
        }    ];

    static getAttributeTypeMap() {
        return Account1.attributeTypeMap;
    }
}

export class Account2 {
    'accountName': string;
    'accountNumber': string;
    'accountType': string;
    'accountid': number;
    'accountingSystemid': string;
    'id': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountName",
            "baseName": "account_name",
            "type": "string"
        },
        {
            "name": "accountNumber",
            "baseName": "account_number",
            "type": "string"
        },
        {
            "name": "accountType",
            "baseName": "account_type",
            "type": "string"
        },
        {
            "name": "accountid",
            "baseName": "accountid",
            "type": "number"
        },
        {
            "name": "accountingSystemid",
            "baseName": "accounting_systemid",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Account2.attributeTypeMap;
    }
}

export class AccountBusiness {
    'accountBusinessId': number;
    'accountId': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountBusinessId",
            "baseName": "account_business_id",
            "type": "number"
        },
        {
            "name": "accountId",
            "baseName": "account_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AccountBusiness.attributeTypeMap;
    }
}

export class AccountsAging {
    'response': Response70;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Response70"
        }    ];

    static getAttributeTypeMap() {
        return AccountsAging.attributeTypeMap;
    }
}

export class AccountsAging1 {
    'accounts': Array<Account>;
    'companyName': string;
    'currencyCode': string;
    'downloadToken': string;
    'endDate': string;
    'totals': Totals;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accounts",
            "baseName": "accounts",
            "type": "Array<Account>"
        },
        {
            "name": "companyName",
            "baseName": "company_name",
            "type": "string"
        },
        {
            "name": "currencyCode",
            "baseName": "currency_code",
            "type": "string"
        },
        {
            "name": "downloadToken",
            "baseName": "download_token",
            "type": "string"
        },
        {
            "name": "endDate",
            "baseName": "end_date",
            "type": "string"
        },
        {
            "name": "totals",
            "baseName": "totals",
            "type": "Totals"
        }    ];

    static getAttributeTypeMap() {
        return AccountsAging1.attributeTypeMap;
    }
}

export class AddBusiness {
    'response': Response64;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Response64"
        }    ];

    static getAttributeTypeMap() {
        return AddBusiness.attributeTypeMap;
    }
}

export class AddBusinessRequest {
    'name': string;
    'dateFormat': string;
    'addressAttributes': AddressAttributes;
    'phoneNumberAttributes': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "dateFormat",
            "baseName": "date_format",
            "type": "string"
        },
        {
            "name": "addressAttributes",
            "baseName": "address_attributes",
            "type": "AddressAttributes"
        },
        {
            "name": "phoneNumberAttributes",
            "baseName": "phone_number_attributes",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AddBusinessRequest.attributeTypeMap;
    }
}

export class AddCommenttoProjectDiscussionMessageRequest {
    'comment': Comment;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "comment",
            "baseName": "comment",
            "type": "Comment"
        }    ];

    static getAttributeTypeMap() {
        return AddCommenttoProjectDiscussionMessageRequest.attributeTypeMap;
    }
}

export class AddJournalEntry {
    'response': Response78;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Response78"
        }    ];

    static getAttributeTypeMap() {
        return AddJournalEntry.attributeTypeMap;
    }
}

export class AddJournalEntryRequest {
    'journalEntry': JournalEntry;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "journalEntry",
            "baseName": "journal_entry",
            "type": "JournalEntry"
        }    ];

    static getAttributeTypeMap() {
        return AddJournalEntryRequest.attributeTypeMap;
    }
}

export class Address {
    'id': number;
    'street': string;
    'city': string;
    'province': string;
    'country': string;
    'postalCode': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "street",
            "baseName": "street",
            "type": "string"
        },
        {
            "name": "city",
            "baseName": "city",
            "type": "string"
        },
        {
            "name": "province",
            "baseName": "province",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "postalCode",
            "baseName": "postal_code",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Address.attributeTypeMap;
    }
}

export class AddressAttributes {
    'country': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AddressAttributes.attributeTypeMap;
    }
}

export class AllowedGateway {
    'allowedid': number;
    'connectionid': string;
    'gatewayName': string;
    'gatewayid': number;
    'id': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "allowedid",
            "baseName": "allowedid",
            "type": "number"
        },
        {
            "name": "connectionid",
            "baseName": "connectionid",
            "type": "string"
        },
        {
            "name": "gatewayName",
            "baseName": "gateway_name",
            "type": "string"
        },
        {
            "name": "gatewayid",
            "baseName": "gatewayid",
            "type": "number"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return AllowedGateway.attributeTypeMap;
    }
}

export class Amount {
    'amount': string;
    'code': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "string"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Amount.attributeTypeMap;
    }
}

export class Amount35 {
    'amount'?: string;
    'code'?: string;
    'count'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "string"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Amount35.attributeTypeMap;
    }
}

export class ApwodA {
    'advancedAccountingAccess': boolean;
    'advancedPaymentsAccess': boolean;
    'autoBankImportAccess': boolean;
    'autobillLimit': number;
    'bankImportAccess': boolean;
    'clientLimit': number;
    'documentLimit': number;
    'editSubjectLineAccess': boolean;
    'lateFeeAccess': boolean;
    'lateReminderAccess': boolean;
    'paymentsFeesReportAccess': boolean;
    'quickbooksIntegrationAccess': boolean;
    'recurringRevenueReportAccess': boolean;
    'removeBrandingAccess': boolean;
    'staffLimit': number;
    'businessAccountantLimit': number;
    'betaMobileCreateExpenseSubcategoryAccess': boolean;
    'iosBetaZendeskWidgetAccess': boolean;
    'mobileReceiptRebillingAccess': boolean;
    'richProposalsAccess': boolean;
    'proposalsCandidateAccess': boolean;
    'heliosPushnotificationsBetaAccess': boolean;
    'esignaturesAccess': boolean;
    'heliosCompanyTaxesBetaAccess': boolean;
    'heliosInvoiceArchiveBetaAccess': boolean;
    'heliosSyncThrottleBetaAccess': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "advancedAccountingAccess",
            "baseName": "advanced_accounting.access",
            "type": "boolean"
        },
        {
            "name": "advancedPaymentsAccess",
            "baseName": "advanced_payments.access",
            "type": "boolean"
        },
        {
            "name": "autoBankImportAccess",
            "baseName": "auto_bank_import.access",
            "type": "boolean"
        },
        {
            "name": "autobillLimit",
            "baseName": "autobill.limit",
            "type": "number"
        },
        {
            "name": "bankImportAccess",
            "baseName": "bank_import.access",
            "type": "boolean"
        },
        {
            "name": "clientLimit",
            "baseName": "client.limit",
            "type": "number"
        },
        {
            "name": "documentLimit",
            "baseName": "document.limit",
            "type": "number"
        },
        {
            "name": "editSubjectLineAccess",
            "baseName": "edit_subject_line.access",
            "type": "boolean"
        },
        {
            "name": "lateFeeAccess",
            "baseName": "late_fee.access",
            "type": "boolean"
        },
        {
            "name": "lateReminderAccess",
            "baseName": "late_reminder.access",
            "type": "boolean"
        },
        {
            "name": "paymentsFeesReportAccess",
            "baseName": "payments_fees_report.access",
            "type": "boolean"
        },
        {
            "name": "quickbooksIntegrationAccess",
            "baseName": "quickbooks_integration.access",
            "type": "boolean"
        },
        {
            "name": "recurringRevenueReportAccess",
            "baseName": "recurring_revenue_report.access",
            "type": "boolean"
        },
        {
            "name": "removeBrandingAccess",
            "baseName": "remove_branding.access",
            "type": "boolean"
        },
        {
            "name": "staffLimit",
            "baseName": "staff.limit",
            "type": "number"
        },
        {
            "name": "businessAccountantLimit",
            "baseName": "business_accountant.limit",
            "type": "number"
        },
        {
            "name": "betaMobileCreateExpenseSubcategoryAccess",
            "baseName": "beta_mobile_create_expense_subcategory.access",
            "type": "boolean"
        },
        {
            "name": "iosBetaZendeskWidgetAccess",
            "baseName": "ios_beta_zendesk_widget.access",
            "type": "boolean"
        },
        {
            "name": "mobileReceiptRebillingAccess",
            "baseName": "mobile_receipt_rebilling.access",
            "type": "boolean"
        },
        {
            "name": "richProposalsAccess",
            "baseName": "rich_proposals.access",
            "type": "boolean"
        },
        {
            "name": "proposalsCandidateAccess",
            "baseName": "proposals_candidate.access",
            "type": "boolean"
        },
        {
            "name": "heliosPushnotificationsBetaAccess",
            "baseName": "helios_pushnotifications.beta.access",
            "type": "boolean"
        },
        {
            "name": "esignaturesAccess",
            "baseName": "esignatures.access",
            "type": "boolean"
        },
        {
            "name": "heliosCompanyTaxesBetaAccess",
            "baseName": "helios_company_taxes.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosInvoiceArchiveBetaAccess",
            "baseName": "helios_invoice_archive.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosSyncThrottleBetaAccess",
            "baseName": "helios_sync_throttle.beta.access",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return ApwodA.attributeTypeMap;
    }
}

export class AssetsTotal {
    'balance': Balance;
    'date': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "balance",
            "baseName": "balance",
            "type": "Balance"
        },
        {
            "name": "date",
            "baseName": "date",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AssetsTotal.attributeTypeMap;
    }
}

export class Attachment {
    'attachmentid'?: number;
    'id'?: number;
    'jwt'?: string;
    'mediaType'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "attachmentid",
            "baseName": "attachmentid",
            "type": "number"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "jwt",
            "baseName": "jwt",
            "type": "string"
        },
        {
            "name": "mediaType",
            "baseName": "media_type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Attachment.attributeTypeMap;
    }
}

export class Attachment1 {
    'jwt': string;
    'mediaType': string;
    'expenseid': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "jwt",
            "baseName": "jwt",
            "type": "string"
        },
        {
            "name": "mediaType",
            "baseName": "media_type",
            "type": "string"
        },
        {
            "name": "expenseid",
            "baseName": "expenseid",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Attachment1.attributeTypeMap;
    }
}

export class Attachment2 {
    'attachmentid': number;
    'id': number;
    'jwt': string;
    'mediaType': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "attachmentid",
            "baseName": "attachmentid",
            "type": "number"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "jwt",
            "baseName": "jwt",
            "type": "string"
        },
        {
            "name": "mediaType",
            "baseName": "media_type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Attachment2.attributeTypeMap;
    }
}

export class BRAVo {
    'attachmentsAccess': boolean;
    'clientLimit': number;
    'richProposalsAccess': boolean;
    'staffLimit': number;
    'betaMobileCreateExpenseSubcategoryAccess': boolean;
    'iosBetaZendeskWidgetAccess': boolean;
    'mobileReceiptRebillingAccess': boolean;
    'proposalsCandidateAccess': boolean;
    'heliosPushnotificationsBetaAccess': boolean;
    'esignaturesAccess': boolean;
    'autoBankImportAccess': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "attachmentsAccess",
            "baseName": "attachments.access",
            "type": "boolean"
        },
        {
            "name": "clientLimit",
            "baseName": "client.limit",
            "type": "number"
        },
        {
            "name": "richProposalsAccess",
            "baseName": "rich_proposals.access",
            "type": "boolean"
        },
        {
            "name": "staffLimit",
            "baseName": "staff.limit",
            "type": "number"
        },
        {
            "name": "betaMobileCreateExpenseSubcategoryAccess",
            "baseName": "beta_mobile_create_expense_subcategory.access",
            "type": "boolean"
        },
        {
            "name": "iosBetaZendeskWidgetAccess",
            "baseName": "ios_beta_zendesk_widget.access",
            "type": "boolean"
        },
        {
            "name": "mobileReceiptRebillingAccess",
            "baseName": "mobile_receipt_rebilling.access",
            "type": "boolean"
        },
        {
            "name": "proposalsCandidateAccess",
            "baseName": "proposals_candidate.access",
            "type": "boolean"
        },
        {
            "name": "heliosPushnotificationsBetaAccess",
            "baseName": "helios_pushnotifications.beta.access",
            "type": "boolean"
        },
        {
            "name": "esignaturesAccess",
            "baseName": "esignatures.access",
            "type": "boolean"
        },
        {
            "name": "autoBankImportAccess",
            "baseName": "auto_bank_import.access",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return BRAVo.attributeTypeMap;
    }
}

export class Balance {
    'amount': string;
    'code': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "string"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Balance.attributeTypeMap;
    }
}

export class Balance1 {
    'balance': Balance;
    'date': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "balance",
            "baseName": "balance",
            "type": "Balance"
        },
        {
            "name": "date",
            "baseName": "date",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Balance1.attributeTypeMap;
    }
}

export class BalanceSheet {
    'response': Response75;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Response75"
        }    ];

    static getAttributeTypeMap() {
        return BalanceSheet.attributeTypeMap;
    }
}

export class BalanceSheet1 {
    'assetsTotal': Array<AssetsTotal>;
    'companyName': string;
    'currencyCode': string;
    'data': Array<Datum>;
    'dates': Array<string>;
    'downloadToken': string;
    'liabilitiesAndEquityTotal': Array<LiabilitiesAndEquityTotal>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "assetsTotal",
            "baseName": "assets_total",
            "type": "Array<AssetsTotal>"
        },
        {
            "name": "companyName",
            "baseName": "company_name",
            "type": "string"
        },
        {
            "name": "currencyCode",
            "baseName": "currency_code",
            "type": "string"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<Datum>"
        },
        {
            "name": "dates",
            "baseName": "dates",
            "type": "Array<string>"
        },
        {
            "name": "downloadToken",
            "baseName": "download_token",
            "type": "string"
        },
        {
            "name": "liabilitiesAndEquityTotal",
            "baseName": "liabilities_and_equity_total",
            "type": "Array<LiabilitiesAndEquityTotal>"
        }    ];

    static getAttributeTypeMap() {
        return BalanceSheet1.attributeTypeMap;
    }
}

export class BankInfo {
    'bankName': string;
    'withdrawalPeriod': string;
    'lastPaymentDate': string;
    'withdrawalSchedule': Array<string>;
    'nextPayoutDate': string;
    'incomingPendingAmount': string;
    'lastPaymentAmount': string;
    'withdrawalType': string;
    'outgoingWithdrawalSchedule': Array<string>;
    'totalPayout': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "bankName",
            "baseName": "bank_name",
            "type": "string"
        },
        {
            "name": "withdrawalPeriod",
            "baseName": "withdrawal_period",
            "type": "string"
        },
        {
            "name": "lastPaymentDate",
            "baseName": "last_payment_date",
            "type": "string"
        },
        {
            "name": "withdrawalSchedule",
            "baseName": "withdrawal_schedule",
            "type": "Array<string>"
        },
        {
            "name": "nextPayoutDate",
            "baseName": "next_payout_date",
            "type": "string"
        },
        {
            "name": "incomingPendingAmount",
            "baseName": "incoming_pending_amount",
            "type": "string"
        },
        {
            "name": "lastPaymentAmount",
            "baseName": "last_payment_amount",
            "type": "string"
        },
        {
            "name": "withdrawalType",
            "baseName": "withdrawal_type",
            "type": "string"
        },
        {
            "name": "outgoingWithdrawalSchedule",
            "baseName": "outgoing_withdrawal_schedule",
            "type": "Array<string>"
        },
        {
            "name": "totalPayout",
            "baseName": "total_payout",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return BankInfo.attributeTypeMap;
    }
}

export class Business {
    'id': number;
    'name': string;
    'accountId': string;
    'dateFormat': string;
    'address': Address;
    'phoneNumber': PhoneNumber1;
    'businessClients': Array<BusinessClient>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "accountId",
            "baseName": "account_id",
            "type": "string"
        },
        {
            "name": "dateFormat",
            "baseName": "date_format",
            "type": "string"
        },
        {
            "name": "address",
            "baseName": "address",
            "type": "Address"
        },
        {
            "name": "phoneNumber",
            "baseName": "phone_number",
            "type": "PhoneNumber1"
        },
        {
            "name": "businessClients",
            "baseName": "business_clients",
            "type": "Array<BusinessClient>"
        }    ];

    static getAttributeTypeMap() {
        return Business.attributeTypeMap;
    }
}

export class BusinessClient {
    'id'?: number;
    'businessId'?: number;
    'accountId'?: string;
    'userid'?: number;
    'clientBusiness'?: ClientBusiness;
    'accountBusiness'?: AccountBusiness;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "businessId",
            "baseName": "business_id",
            "type": "number"
        },
        {
            "name": "accountId",
            "baseName": "account_id",
            "type": "string"
        },
        {
            "name": "userid",
            "baseName": "userid",
            "type": "number"
        },
        {
            "name": "clientBusiness",
            "baseName": "client_business",
            "type": "ClientBusiness"
        },
        {
            "name": "accountBusiness",
            "baseName": "account_business",
            "type": "AccountBusiness"
        }    ];

    static getAttributeTypeMap() {
        return BusinessClient.attributeTypeMap;
    }
}

export class BusinessGroup {
    'id': number;
    'category': string;
    'members': Array<Member3>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "category",
            "baseName": "category",
            "type": "string"
        },
        {
            "name": "members",
            "baseName": "members",
            "type": "Array<Member3>"
        }    ];

    static getAttributeTypeMap() {
        return BusinessGroup.attributeTypeMap;
    }
}

export class BusinessMembership {
    'id': number;
    'role': string;
    'unacknowledgedChange': boolean;
    'fasttrackToken': string;
    'business': Business;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "role",
            "baseName": "role",
            "type": "string"
        },
        {
            "name": "unacknowledgedChange",
            "baseName": "unacknowledged_change",
            "type": "boolean"
        },
        {
            "name": "fasttrackToken",
            "baseName": "fasttrack_token",
            "type": "string"
        },
        {
            "name": "business",
            "baseName": "business",
            "type": "Business"
        }    ];

    static getAttributeTypeMap() {
        return BusinessMembership.attributeTypeMap;
    }
}

export class BusinessMembership1 {
    'id': number;
    'role': string;
    'unacknowledgedChange': boolean;
    'fasttrackToken': string;
    'business': Business;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "role",
            "baseName": "role",
            "type": "string"
        },
        {
            "name": "unacknowledgedChange",
            "baseName": "unacknowledged_change",
            "type": "boolean"
        },
        {
            "name": "fasttrackToken",
            "baseName": "fasttrack_token",
            "type": "string"
        },
        {
            "name": "business",
            "baseName": "business",
            "type": "Business"
        }    ];

    static getAttributeTypeMap() {
        return BusinessMembership1.attributeTypeMap;
    }
}

export class Callback {
    'event': string;
    'uri': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "event",
            "baseName": "event",
            "type": "string"
        },
        {
            "name": "uri",
            "baseName": "uri",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Callback.attributeTypeMap;
    }
}

export class Callback1 {
    'callbackId': number;
    'resend': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "callbackId",
            "baseName": "callback_id",
            "type": "number"
        },
        {
            "name": "resend",
            "baseName": "resend",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Callback1.attributeTypeMap;
    }
}

export class Category {
    'category': string;
    'categoryid': number;
    'createdAt': string;
    'id': number;
    'isCogs': boolean;
    'isEditable': boolean;
    'parentid': number;
    'updatedAt': string;
    'visState': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "category",
            "baseName": "category",
            "type": "string"
        },
        {
            "name": "categoryid",
            "baseName": "categoryid",
            "type": "number"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "isCogs",
            "baseName": "is_cogs",
            "type": "boolean"
        },
        {
            "name": "isEditable",
            "baseName": "is_editable",
            "type": "boolean"
        },
        {
            "name": "parentid",
            "baseName": "parentid",
            "type": "number"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        },
        {
            "name": "visState",
            "baseName": "vis_state",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Category.attributeTypeMap;
    }
}

export class Category2 {
    'category': string;
    'categoryid': number;
    'createdAt': string;
    'id': number;
    'isCogs': boolean;
    'isEditable': boolean;
    'parentid': number;
    'updatedAt': string;
    'visState': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "category",
            "baseName": "category",
            "type": "string"
        },
        {
            "name": "categoryid",
            "baseName": "categoryid",
            "type": "number"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "isCogs",
            "baseName": "is_cogs",
            "type": "boolean"
        },
        {
            "name": "isEditable",
            "baseName": "is_editable",
            "type": "boolean"
        },
        {
            "name": "parentid",
            "baseName": "parentid",
            "type": "number"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        },
        {
            "name": "visState",
            "baseName": "vis_state",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Category2.attributeTypeMap;
    }
}

export class Child {
    'children': Array<string>;
    'data': Array<string>;
    'description': string;
    'entryType': string;
    'total': Total;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "children",
            "baseName": "children",
            "type": "Array<string>"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<string>"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "entryType",
            "baseName": "entry_type",
            "type": "string"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "Total"
        }    ];

    static getAttributeTypeMap() {
        return Child.attributeTypeMap;
    }
}

export class Client {
    'accountingSystemid': string;
    'allowLateFees': boolean;
    'allowLateNotifications': boolean;
    'busPhone': string;
    'companyIndustry': string;
    'companySize': string;
    'currencyCode': string;
    'directLinkToken': string;
    'email': string;
    'fax': string;
    'fname': string;
    'hasRetainer': string;
    'homePhone': string;
    'id': number;
    'language': string;
    'lastActivity': string;
    'lastLogin': string;
    'level': number;
    'lname': string;
    'mobPhone': string;
    'note': string;
    'notified': boolean;
    'numLogins': number;
    'organization': string;
    'pCity': string;
    'pCode': string;
    'pCountry': string;
    'pProvince': string;
    'pStreet': string;
    'pStreet2': string;
    'prefEmail': boolean;
    'prefGmail': boolean;
    'retainerId': string;
    'role': string;
    'sCity': string;
    'sCode': string;
    'sCountry': string;
    'sProvince': string;
    'sStreet': string;
    'sStreet2': string;
    'signupDate': string;
    'statementToken': string;
    'subdomain': string;
    'updated': string;
    'userid': number;
    'username': string;
    'vatName': string;
    'vatNumber': string;
    'visState': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountingSystemid",
            "baseName": "accounting_systemid",
            "type": "string"
        },
        {
            "name": "allowLateFees",
            "baseName": "allow_late_fees",
            "type": "boolean"
        },
        {
            "name": "allowLateNotifications",
            "baseName": "allow_late_notifications",
            "type": "boolean"
        },
        {
            "name": "busPhone",
            "baseName": "bus_phone",
            "type": "string"
        },
        {
            "name": "companyIndustry",
            "baseName": "company_industry",
            "type": "string"
        },
        {
            "name": "companySize",
            "baseName": "company_size",
            "type": "string"
        },
        {
            "name": "currencyCode",
            "baseName": "currency_code",
            "type": "string"
        },
        {
            "name": "directLinkToken",
            "baseName": "direct_link_token",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "fax",
            "baseName": "fax",
            "type": "string"
        },
        {
            "name": "fname",
            "baseName": "fname",
            "type": "string"
        },
        {
            "name": "hasRetainer",
            "baseName": "has_retainer",
            "type": "string"
        },
        {
            "name": "homePhone",
            "baseName": "home_phone",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "language",
            "baseName": "language",
            "type": "string"
        },
        {
            "name": "lastActivity",
            "baseName": "last_activity",
            "type": "string"
        },
        {
            "name": "lastLogin",
            "baseName": "last_login",
            "type": "string"
        },
        {
            "name": "level",
            "baseName": "level",
            "type": "number"
        },
        {
            "name": "lname",
            "baseName": "lname",
            "type": "string"
        },
        {
            "name": "mobPhone",
            "baseName": "mob_phone",
            "type": "string"
        },
        {
            "name": "note",
            "baseName": "note",
            "type": "string"
        },
        {
            "name": "notified",
            "baseName": "notified",
            "type": "boolean"
        },
        {
            "name": "numLogins",
            "baseName": "num_logins",
            "type": "number"
        },
        {
            "name": "organization",
            "baseName": "organization",
            "type": "string"
        },
        {
            "name": "pCity",
            "baseName": "p_city",
            "type": "string"
        },
        {
            "name": "pCode",
            "baseName": "p_code",
            "type": "string"
        },
        {
            "name": "pCountry",
            "baseName": "p_country",
            "type": "string"
        },
        {
            "name": "pProvince",
            "baseName": "p_province",
            "type": "string"
        },
        {
            "name": "pStreet",
            "baseName": "p_street",
            "type": "string"
        },
        {
            "name": "pStreet2",
            "baseName": "p_street2",
            "type": "string"
        },
        {
            "name": "prefEmail",
            "baseName": "pref_email",
            "type": "boolean"
        },
        {
            "name": "prefGmail",
            "baseName": "pref_gmail",
            "type": "boolean"
        },
        {
            "name": "retainerId",
            "baseName": "retainer_id",
            "type": "string"
        },
        {
            "name": "role",
            "baseName": "role",
            "type": "string"
        },
        {
            "name": "sCity",
            "baseName": "s_city",
            "type": "string"
        },
        {
            "name": "sCode",
            "baseName": "s_code",
            "type": "string"
        },
        {
            "name": "sCountry",
            "baseName": "s_country",
            "type": "string"
        },
        {
            "name": "sProvince",
            "baseName": "s_province",
            "type": "string"
        },
        {
            "name": "sStreet",
            "baseName": "s_street",
            "type": "string"
        },
        {
            "name": "sStreet2",
            "baseName": "s_street2",
            "type": "string"
        },
        {
            "name": "signupDate",
            "baseName": "signup_date",
            "type": "string"
        },
        {
            "name": "statementToken",
            "baseName": "statement_token",
            "type": "string"
        },
        {
            "name": "subdomain",
            "baseName": "subdomain",
            "type": "string"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "string"
        },
        {
            "name": "userid",
            "baseName": "userid",
            "type": "number"
        },
        {
            "name": "username",
            "baseName": "username",
            "type": "string"
        },
        {
            "name": "vatName",
            "baseName": "vat_name",
            "type": "string"
        },
        {
            "name": "vatNumber",
            "baseName": "vat_number",
            "type": "string"
        },
        {
            "name": "visState",
            "baseName": "vis_state",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Client.attributeTypeMap;
    }
}

export class Client1 {
    'accountingSystemid': string;
    'allowLateFees': boolean;
    'allowLateNotifications': boolean;
    'busPhone': string;
    'companyIndustry': string;
    'companySize': string;
    'currencyCode': string;
    'directLinkToken': string;
    'email': string;
    'fax': string;
    'fname': string;
    'hasRetainer': string;
    'homePhone': string;
    'id': number;
    'language': string;
    'lastActivity': string;
    'lastLogin': string;
    'level': number;
    'lname': string;
    'mobPhone': string;
    'note': string;
    'notified': boolean;
    'numLogins': number;
    'organization': string;
    'pCity': string;
    'pCode': string;
    'pCountry': string;
    'pProvince': string;
    'pStreet': string;
    'pStreet2': string;
    'prefEmail': boolean;
    'prefGmail': boolean;
    'retainerId': string;
    'role': string;
    'sCity': string;
    'sCode': string;
    'sCountry': string;
    'sProvince': string;
    'sStreet': string;
    'sStreet2': string;
    'signupDate': string;
    'statementToken': string;
    'subdomain': string;
    'updated': string;
    'userid': number;
    'username': string;
    'vatName': string;
    'vatNumber': string;
    'visState': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountingSystemid",
            "baseName": "accounting_systemid",
            "type": "string"
        },
        {
            "name": "allowLateFees",
            "baseName": "allow_late_fees",
            "type": "boolean"
        },
        {
            "name": "allowLateNotifications",
            "baseName": "allow_late_notifications",
            "type": "boolean"
        },
        {
            "name": "busPhone",
            "baseName": "bus_phone",
            "type": "string"
        },
        {
            "name": "companyIndustry",
            "baseName": "company_industry",
            "type": "string"
        },
        {
            "name": "companySize",
            "baseName": "company_size",
            "type": "string"
        },
        {
            "name": "currencyCode",
            "baseName": "currency_code",
            "type": "string"
        },
        {
            "name": "directLinkToken",
            "baseName": "direct_link_token",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "fax",
            "baseName": "fax",
            "type": "string"
        },
        {
            "name": "fname",
            "baseName": "fname",
            "type": "string"
        },
        {
            "name": "hasRetainer",
            "baseName": "has_retainer",
            "type": "string"
        },
        {
            "name": "homePhone",
            "baseName": "home_phone",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "language",
            "baseName": "language",
            "type": "string"
        },
        {
            "name": "lastActivity",
            "baseName": "last_activity",
            "type": "string"
        },
        {
            "name": "lastLogin",
            "baseName": "last_login",
            "type": "string"
        },
        {
            "name": "level",
            "baseName": "level",
            "type": "number"
        },
        {
            "name": "lname",
            "baseName": "lname",
            "type": "string"
        },
        {
            "name": "mobPhone",
            "baseName": "mob_phone",
            "type": "string"
        },
        {
            "name": "note",
            "baseName": "note",
            "type": "string"
        },
        {
            "name": "notified",
            "baseName": "notified",
            "type": "boolean"
        },
        {
            "name": "numLogins",
            "baseName": "num_logins",
            "type": "number"
        },
        {
            "name": "organization",
            "baseName": "organization",
            "type": "string"
        },
        {
            "name": "pCity",
            "baseName": "p_city",
            "type": "string"
        },
        {
            "name": "pCode",
            "baseName": "p_code",
            "type": "string"
        },
        {
            "name": "pCountry",
            "baseName": "p_country",
            "type": "string"
        },
        {
            "name": "pProvince",
            "baseName": "p_province",
            "type": "string"
        },
        {
            "name": "pStreet",
            "baseName": "p_street",
            "type": "string"
        },
        {
            "name": "pStreet2",
            "baseName": "p_street2",
            "type": "string"
        },
        {
            "name": "prefEmail",
            "baseName": "pref_email",
            "type": "boolean"
        },
        {
            "name": "prefGmail",
            "baseName": "pref_gmail",
            "type": "boolean"
        },
        {
            "name": "retainerId",
            "baseName": "retainer_id",
            "type": "string"
        },
        {
            "name": "role",
            "baseName": "role",
            "type": "string"
        },
        {
            "name": "sCity",
            "baseName": "s_city",
            "type": "string"
        },
        {
            "name": "sCode",
            "baseName": "s_code",
            "type": "string"
        },
        {
            "name": "sCountry",
            "baseName": "s_country",
            "type": "string"
        },
        {
            "name": "sProvince",
            "baseName": "s_province",
            "type": "string"
        },
        {
            "name": "sStreet",
            "baseName": "s_street",
            "type": "string"
        },
        {
            "name": "sStreet2",
            "baseName": "s_street2",
            "type": "string"
        },
        {
            "name": "signupDate",
            "baseName": "signup_date",
            "type": "string"
        },
        {
            "name": "statementToken",
            "baseName": "statement_token",
            "type": "string"
        },
        {
            "name": "subdomain",
            "baseName": "subdomain",
            "type": "string"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "string"
        },
        {
            "name": "userid",
            "baseName": "userid",
            "type": "number"
        },
        {
            "name": "username",
            "baseName": "username",
            "type": "string"
        },
        {
            "name": "vatName",
            "baseName": "vat_name",
            "type": "string"
        },
        {
            "name": "vatNumber",
            "baseName": "vat_number",
            "type": "string"
        },
        {
            "name": "visState",
            "baseName": "vis_state",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Client1.attributeTypeMap;
    }
}

export class Client2 {
    'fname': string;
    'lname': string;
    'email': string;
    'organization': string;
    'vatName': string;
    'vatNumber': string;
    'status': string;
    'note': string;
    'homePhone': string;
    'userid': string;
    'source': string;
    'highlightString': string;
    'pStreet': string;
    'pStreet2': string;
    'pCity': string;
    'pCountry': string;
    'pProvince': string;
    'pCode': string;
    'currencyCode': string;
    'language': string;
    'lastActivity': string;
    'face': string;
    'lateFee': string;
    'lateReminders': Array<string>;
    'contacts': Array<Contact>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "fname",
            "baseName": "fname",
            "type": "string"
        },
        {
            "name": "lname",
            "baseName": "lname",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "organization",
            "baseName": "organization",
            "type": "string"
        },
        {
            "name": "vatName",
            "baseName": "vat_name",
            "type": "string"
        },
        {
            "name": "vatNumber",
            "baseName": "vat_number",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "note",
            "baseName": "note",
            "type": "string"
        },
        {
            "name": "homePhone",
            "baseName": "home_phone",
            "type": "string"
        },
        {
            "name": "userid",
            "baseName": "userid",
            "type": "string"
        },
        {
            "name": "source",
            "baseName": "source",
            "type": "string"
        },
        {
            "name": "highlightString",
            "baseName": "highlight_string",
            "type": "string"
        },
        {
            "name": "pStreet",
            "baseName": "p_street",
            "type": "string"
        },
        {
            "name": "pStreet2",
            "baseName": "p_street2",
            "type": "string"
        },
        {
            "name": "pCity",
            "baseName": "p_city",
            "type": "string"
        },
        {
            "name": "pCountry",
            "baseName": "p_country",
            "type": "string"
        },
        {
            "name": "pProvince",
            "baseName": "p_province",
            "type": "string"
        },
        {
            "name": "pCode",
            "baseName": "p_code",
            "type": "string"
        },
        {
            "name": "currencyCode",
            "baseName": "currency_code",
            "type": "string"
        },
        {
            "name": "language",
            "baseName": "language",
            "type": "string"
        },
        {
            "name": "lastActivity",
            "baseName": "last_activity",
            "type": "string"
        },
        {
            "name": "face",
            "baseName": "face",
            "type": "string"
        },
        {
            "name": "lateFee",
            "baseName": "late_fee",
            "type": "string"
        },
        {
            "name": "lateReminders",
            "baseName": "late_reminders",
            "type": "Array<string>"
        },
        {
            "name": "contacts",
            "baseName": "contacts",
            "type": "Array<Contact>"
        }    ];

    static getAttributeTypeMap() {
        return Client2.attributeTypeMap;
    }
}

export class Client4 {
    'fname': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "fname",
            "baseName": "fname",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Client4.attributeTypeMap;
    }
}

export class Client6 {
    'contacts': Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "contacts",
            "baseName": "contacts",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return Client6.attributeTypeMap;
    }
}

export class ClientBusiness {
    'businessId': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "businessId",
            "baseName": "business_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ClientBusiness.attributeTypeMap;
    }
}

export class Comment {
    'content': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Comment.attributeTypeMap;
    }
}

export class Contact {
    'email': string;
    'fname': string;
    'lname': string;
    'phone1': string;
    'userid': string;
    'face': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "fname",
            "baseName": "fname",
            "type": "string"
        },
        {
            "name": "lname",
            "baseName": "lname",
            "type": "string"
        },
        {
            "name": "phone1",
            "baseName": "phone1",
            "type": "string"
        },
        {
            "name": "userid",
            "baseName": "userid",
            "type": "string"
        },
        {
            "name": "face",
            "baseName": "face",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Contact.attributeTypeMap;
    }
}

export class Contact1 {
    'email': string;
    'fname': string;
    'lname': string;
    'phone1': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "fname",
            "baseName": "fname",
            "type": "string"
        },
        {
            "name": "lname",
            "baseName": "lname",
            "type": "string"
        },
        {
            "name": "phone1",
            "baseName": "phone1",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Contact1.attributeTypeMap;
    }
}

export class CreateCustomExpenseCategory {
    'response': Response49;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Response49"
        }    ];

    static getAttributeTypeMap() {
        return CreateCustomExpenseCategory.attributeTypeMap;
    }
}

export class CreateExpense {
    'response': Response45;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Response45"
        }    ];

    static getAttributeTypeMap() {
        return CreateExpense.attributeTypeMap;
    }
}

export class CreateExpenseRequest {
    'expense': Expense1;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "expense",
            "baseName": "expense",
            "type": "Expense1"
        }    ];

    static getAttributeTypeMap() {
        return CreateExpenseRequest.attributeTypeMap;
    }
}

export class CreateExpensewithReceiptRequest {
    'expense': Expense3;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "expense",
            "baseName": "expense",
            "type": "Expense3"
        }    ];

    static getAttributeTypeMap() {
        return CreateExpensewithReceiptRequest.attributeTypeMap;
    }
}

export class CreateItem {
    'response': Response7;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Response7"
        }    ];

    static getAttributeTypeMap() {
        return CreateItem.attributeTypeMap;
    }
}

export class CreateItemRequest {
    'item': Item1;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "item",
            "baseName": "item",
            "type": "Item1"
        }    ];

    static getAttributeTypeMap() {
        return CreateItemRequest.attributeTypeMap;
    }
}

export class CreateNewMessageinProjectDiscussionRequest {
    'thread': Thread;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "thread",
            "baseName": "thread",
            "type": "Thread"
        }    ];

    static getAttributeTypeMap() {
        return CreateNewMessageinProjectDiscussionRequest.attributeTypeMap;
    }
}

export class CreateRecurringExpenseRequest {
    'expenseProfile': ExpenseProfile;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "expenseProfile",
            "baseName": "expense_profile",
            "type": "ExpenseProfile"
        }    ];

    static getAttributeTypeMap() {
        return CreateRecurringExpenseRequest.attributeTypeMap;
    }
}

export class CreateRetainerRequest {
    'retainer': Retainer1;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "retainer",
            "baseName": "retainer",
            "type": "Retainer1"
        }    ];

    static getAttributeTypeMap() {
        return CreateRetainerRequest.attributeTypeMap;
    }
}

export class CreateRetainerRetainerforclientalreadyexists {
    'errno': number;
    'error': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errno",
            "baseName": "errno",
            "type": "number"
        },
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateRetainerRetainerforclientalreadyexists.attributeTypeMap;
    }
}

export class CreateRetainerSuccess {
    'retainer': Retainer;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "retainer",
            "baseName": "retainer",
            "type": "Retainer"
        }    ];

    static getAttributeTypeMap() {
        return CreateRetainerSuccess.attributeTypeMap;
    }
}

export class CreateSingleInvoiceProfile {
    'response': Response15;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Response15"
        }    ];

    static getAttributeTypeMap() {
        return CreateSingleInvoiceProfile.attributeTypeMap;
    }
}

export class CreateSingleOtherIncome {
    'response': Response22;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Response22"
        }    ];

    static getAttributeTypeMap() {
        return CreateSingleOtherIncome.attributeTypeMap;
    }
}

export class CreateSingleOtherIncomeRequest {
    'otherIncome': OtherIncome1;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "otherIncome",
            "baseName": "other_income",
            "type": "OtherIncome1"
        }    ];

    static getAttributeTypeMap() {
        return CreateSingleOtherIncomeRequest.attributeTypeMap;
    }
}

export class CreateSingleProject {
    'project': Project2;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "project",
            "baseName": "project",
            "type": "Project2"
        }    ];

    static getAttributeTypeMap() {
        return CreateSingleProject.attributeTypeMap;
    }
}

export class CreateSingleTax {
    'response': Response4;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Response4"
        }    ];

    static getAttributeTypeMap() {
        return CreateSingleTax.attributeTypeMap;
    }
}

export class CreateSingleTax1 {
    'response': Response87;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Response87"
        }    ];

    static getAttributeTypeMap() {
        return CreateSingleTax1.attributeTypeMap;
    }
}

export class CreateSingleTaxRequest {
    'tax': Tax1;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "tax",
            "baseName": "tax",
            "type": "Tax1"
        }    ];

    static getAttributeTypeMap() {
        return CreateSingleTaxRequest.attributeTypeMap;
    }
}

export class CreateTask {
    'response': Response59;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Response59"
        }    ];

    static getAttributeTypeMap() {
        return CreateTask.attributeTypeMap;
    }
}

export class CreateTaskRequest {
    'task': Task2;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "task",
            "baseName": "task",
            "type": "Task2"
        }    ];

    static getAttributeTypeMap() {
        return CreateTaskRequest.attributeTypeMap;
    }
}

export class CreateaTimeEntry {
    'timeEntry': TimeEntry1;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "timeEntry",
            "baseName": "time_entry",
            "type": "TimeEntry1"
        }    ];

    static getAttributeTypeMap() {
        return CreateaTimeEntry.attributeTypeMap;
    }
}

export class Credit {
    'amount': string;
    'code': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "string"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Credit.attributeTypeMap;
    }
}

export class Credit1 {
    'amount'?: string;
    'code'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "string"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Credit1.attributeTypeMap;
    }
}

export class Datum {
    'accountType': string;
    'accounts': Array<Account1>;
    'balances': Array<Balance1>;
    'category': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountType",
            "baseName": "account_type",
            "type": "string"
        },
        {
            "name": "accounts",
            "baseName": "accounts",
            "type": "Array<Account1>"
        },
        {
            "name": "balances",
            "baseName": "balances",
            "type": "Array<Balance1>"
        },
        {
            "name": "category",
            "baseName": "category",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Datum.attributeTypeMap;
    }
}

export class Datum1 {
    'accountName': string;
    'accountNumber': string;
    'accountSubName': string;
    'accountSubNumber': string;
    'credit': Credit;
    'debit': Debit;
    'subAccountid': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountName",
            "baseName": "account_name",
            "type": "string"
        },
        {
            "name": "accountNumber",
            "baseName": "account_number",
            "type": "string"
        },
        {
            "name": "accountSubName",
            "baseName": "account_sub_name",
            "type": "string"
        },
        {
            "name": "accountSubNumber",
            "baseName": "account_sub_number",
            "type": "string"
        },
        {
            "name": "credit",
            "baseName": "credit",
            "type": "Credit"
        },
        {
            "name": "debit",
            "baseName": "debit",
            "type": "Debit"
        },
        {
            "name": "subAccountid",
            "baseName": "sub_accountid",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Datum1.attributeTypeMap;
    }
}

export class Debit {
    'amount': string;
    'code': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "string"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Debit.attributeTypeMap;
    }
}

export class Debit1 {
    'amount'?: string;
    'code'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "string"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Debit1.attributeTypeMap;
    }
}

export class DeleteBusiness {
    'response': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return DeleteBusiness.attributeTypeMap;
    }
}

export class DeleteBusinessMustDeleteSubscriptionfirst {
    'error': string;
    'errorDescription': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        },
        {
            "name": "errorDescription",
            "baseName": "error_description",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DeleteBusinessMustDeleteSubscriptionfirst.attributeTypeMap;
    }
}

export class DeleteEstimate {
    'response': Response53;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Response53"
        }    ];

    static getAttributeTypeMap() {
        return DeleteEstimate.attributeTypeMap;
    }
}

export class DeleteEstimateRequest {
    'estimate': Estimate4;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "estimate",
            "baseName": "estimate",
            "type": "Estimate4"
        }    ];

    static getAttributeTypeMap() {
        return DeleteEstimateRequest.attributeTypeMap;
    }
}

export class DeleteExpenseRequest {
    'expense': Expense8;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "expense",
            "baseName": "expense",
            "type": "Expense8"
        }    ];

    static getAttributeTypeMap() {
        return DeleteExpenseRequest.attributeTypeMap;
    }
}

export class DeleteInvoice {
    'response': Response33;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Response33"
        }    ];

    static getAttributeTypeMap() {
        return DeleteInvoice.attributeTypeMap;
    }
}

export class DeleteInvoiceProfile {
    'response': Response13;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Response13"
        }    ];

    static getAttributeTypeMap() {
        return DeleteInvoiceProfile.attributeTypeMap;
    }
}

export class DeleteInvoiceProfileRequest {
    'invoiceProfile': InvoiceProfile3;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "invoiceProfile",
            "baseName": "invoice_profile",
            "type": "InvoiceProfile3"
        }    ];

    static getAttributeTypeMap() {
        return DeleteInvoiceProfileRequest.attributeTypeMap;
    }
}

export class DeleteInvoiceRequest {
    'invoice': Invoice6;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "invoice",
            "baseName": "invoice",
            "type": "Invoice6"
        }    ];

    static getAttributeTypeMap() {
        return DeleteInvoiceRequest.attributeTypeMap;
    }
}

export class DeleteItemRequest {
    'item': Item6;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "item",
            "baseName": "item",
            "type": "Item6"
        }    ];

    static getAttributeTypeMap() {
        return DeleteItemRequest.attributeTypeMap;
    }
}

export class DeletePayment {
    'response': Response25;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Response25"
        }    ];

    static getAttributeTypeMap() {
        return DeletePayment.attributeTypeMap;
    }
}

export class DeletePaymentRequest {
    'payment': Payment3;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "payment",
            "baseName": "payment",
            "type": "Payment3"
        }    ];

    static getAttributeTypeMap() {
        return DeletePaymentRequest.attributeTypeMap;
    }
}

export class DeleteProject {
    'errorType': string;
    'message': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errorType",
            "baseName": "error_type",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DeleteProject.attributeTypeMap;
    }
}

export class DeleteProjectRequest {
    'project': Project4;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "project",
            "baseName": "project",
            "type": "Project4"
        }    ];

    static getAttributeTypeMap() {
        return DeleteProjectRequest.attributeTypeMap;
    }
}

export class DeleteRetainerRequest {
    'retainer': Retainer6;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "retainer",
            "baseName": "retainer",
            "type": "Retainer6"
        }    ];

    static getAttributeTypeMap() {
        return DeleteRetainerRequest.attributeTypeMap;
    }
}

export class DeleteRetainerSuccess {
    'retainer': Retainer;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "retainer",
            "baseName": "retainer",
            "type": "Retainer"
        }    ];

    static getAttributeTypeMap() {
        return DeleteRetainerSuccess.attributeTypeMap;
    }
}

export class DeleteSingleOtherIncome {
    'response': Response23;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Response23"
        }    ];

    static getAttributeTypeMap() {
        return DeleteSingleOtherIncome.attributeTypeMap;
    }
}

export class DeleteSingleOtherIncomeRequest {
    'otherIncome': OtherIncome5;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "otherIncome",
            "baseName": "other_income",
            "type": "OtherIncome5"
        }    ];

    static getAttributeTypeMap() {
        return DeleteSingleOtherIncomeRequest.attributeTypeMap;
    }
}

export class DeleteSingleTax {
    'response': any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return DeleteSingleTax.attributeTypeMap;
    }
}

export class DeleteStaff {
    'response': Response39;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Response39"
        }    ];

    static getAttributeTypeMap() {
        return DeleteStaff.attributeTypeMap;
    }
}

export class DeleteStaffRequest {
    'staff': Staff3;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "staff",
            "baseName": "staff",
            "type": "Staff3"
        }    ];

    static getAttributeTypeMap() {
        return DeleteStaffRequest.attributeTypeMap;
    }
}

export class DeleteTask {
    'response': Response59;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Response59"
        }    ];

    static getAttributeTypeMap() {
        return DeleteTask.attributeTypeMap;
    }
}

export class DeleteTaskRequest {
    'task': Task6;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "task",
            "baseName": "task",
            "type": "Task6"
        }    ];

    static getAttributeTypeMap() {
        return DeleteTaskRequest.attributeTypeMap;
    }
}

export class Detail {
    'subAccountid': string;
    'debit'?: string;
    'credit'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "subAccountid",
            "baseName": "sub_accountid",
            "type": "string"
        },
        {
            "name": "debit",
            "baseName": "debit",
            "type": "string"
        },
        {
            "name": "credit",
            "baseName": "credit",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Detail.attributeTypeMap;
    }
}

export class Detail1 {
    'credit': string;
    'currencyCode': string;
    'debit': string;
    'description': string;
    'detailid': number;
    'id': number;
    'name': string;
    'subAccountid': number;
    'userEnteredDate': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "credit",
            "baseName": "credit",
            "type": "string"
        },
        {
            "name": "currencyCode",
            "baseName": "currency_code",
            "type": "string"
        },
        {
            "name": "debit",
            "baseName": "debit",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "detailid",
            "baseName": "detailid",
            "type": "number"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "subAccountid",
            "baseName": "sub_accountid",
            "type": "number"
        },
        {
            "name": "userEnteredDate",
            "baseName": "user_entered_date",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Detail1.attributeTypeMap;
    }
}

export class Discount {
    'amount': string;
    'code': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "string"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Discount.attributeTypeMap;
    }
}

export class DiscountTotal {
    'amount': string;
    'code': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "string"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DiscountTotal.attributeTypeMap;
    }
}

export class DowO0g {
    'advancedAccountingAccess': boolean;
    'advancedPaymentsAccess': boolean;
    'autoBankImportAccess': boolean;
    'autobillLimit': number;
    'bankImportAccess': boolean;
    'businessAccountantLimit': number;
    'clientLimit': number;
    'documentLimit': number;
    'editSubjectLineAccess': boolean;
    'lateFeeAccess': boolean;
    'lateReminderAccess': boolean;
    'paymentsFeesReportAccess': boolean;
    'recurringRevenueReportAccess': boolean;
    'removeBrandingAccess': boolean;
    'staffLimit': number;
    'betaHeliosAsyncExpensesAccess': boolean;
    'betaMobileCreateExpenseSubcategoryAccess': boolean;
    'iosBetaZendeskWidgetAccess': boolean;
    'mobileReceiptRebillingAccess': boolean;
    'proposalsCandidateAccess': boolean;
    'heliosPushnotificationsBetaAccess': boolean;
    'iosBetaPaymentSchedulesAccess': boolean;
    'heliosRebillTimeAccess': boolean;
    'esignaturesAccess': boolean;
    'heliosDashboardAccess': boolean;
    'heliosLateFeeReminderBetaAccess': boolean;
    'heliosBulkActionsInvoicesBetaAccess': boolean;
    'heliosVirtualTerminalBetaAccess': boolean;
    'heliosExpenseRebillingBetaAccess': boolean;
    'heliosCompanyTaxesBetaAccess': boolean;
    'heliosInvoiceArchiveBetaAccess': boolean;
    'accountantInviteAccess': boolean;
    'heliosSyncThrottleBetaAccess': boolean;
    'bankReconciliationAccess': boolean;
    'heliosPushResourceToUseExecuteBetaAccess': boolean;
    'newTimeTrackingAccess': boolean;
    'bankRecSmartMatchAccess': boolean;
    'balanceSheetAccess': boolean;
    'invoiceV2SearchAccess': boolean;
    'importItemsCsvAccess': boolean;
    'exportClientsCsvAccess': boolean;
    'heliosVirtualTerminalTutorialBetaAccess': boolean;
    'inlineExpenseEditAccess': boolean;
    'heliosVirtualTerminalAdvertisingBetaAccess': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "advancedAccountingAccess",
            "baseName": "advanced_accounting.access",
            "type": "boolean"
        },
        {
            "name": "advancedPaymentsAccess",
            "baseName": "advanced_payments.access",
            "type": "boolean"
        },
        {
            "name": "autoBankImportAccess",
            "baseName": "auto_bank_import.access",
            "type": "boolean"
        },
        {
            "name": "autobillLimit",
            "baseName": "autobill.limit",
            "type": "number"
        },
        {
            "name": "bankImportAccess",
            "baseName": "bank_import.access",
            "type": "boolean"
        },
        {
            "name": "businessAccountantLimit",
            "baseName": "business_accountant.limit",
            "type": "number"
        },
        {
            "name": "clientLimit",
            "baseName": "client.limit",
            "type": "number"
        },
        {
            "name": "documentLimit",
            "baseName": "document.limit",
            "type": "number"
        },
        {
            "name": "editSubjectLineAccess",
            "baseName": "edit_subject_line.access",
            "type": "boolean"
        },
        {
            "name": "lateFeeAccess",
            "baseName": "late_fee.access",
            "type": "boolean"
        },
        {
            "name": "lateReminderAccess",
            "baseName": "late_reminder.access",
            "type": "boolean"
        },
        {
            "name": "paymentsFeesReportAccess",
            "baseName": "payments_fees_report.access",
            "type": "boolean"
        },
        {
            "name": "recurringRevenueReportAccess",
            "baseName": "recurring_revenue_report.access",
            "type": "boolean"
        },
        {
            "name": "removeBrandingAccess",
            "baseName": "remove_branding.access",
            "type": "boolean"
        },
        {
            "name": "staffLimit",
            "baseName": "staff.limit",
            "type": "number"
        },
        {
            "name": "betaHeliosAsyncExpensesAccess",
            "baseName": "BetaHeliosAsyncExpenses.access",
            "type": "boolean"
        },
        {
            "name": "betaMobileCreateExpenseSubcategoryAccess",
            "baseName": "beta_mobile_create_expense_subcategory.access",
            "type": "boolean"
        },
        {
            "name": "iosBetaZendeskWidgetAccess",
            "baseName": "ios_beta_zendesk_widget.access",
            "type": "boolean"
        },
        {
            "name": "mobileReceiptRebillingAccess",
            "baseName": "mobile_receipt_rebilling.access",
            "type": "boolean"
        },
        {
            "name": "proposalsCandidateAccess",
            "baseName": "proposals_candidate.access",
            "type": "boolean"
        },
        {
            "name": "heliosPushnotificationsBetaAccess",
            "baseName": "helios_pushnotifications.beta.access",
            "type": "boolean"
        },
        {
            "name": "iosBetaPaymentSchedulesAccess",
            "baseName": "ios_beta_payment_schedules.access",
            "type": "boolean"
        },
        {
            "name": "heliosRebillTimeAccess",
            "baseName": "helios_rebill_time.access",
            "type": "boolean"
        },
        {
            "name": "esignaturesAccess",
            "baseName": "esignatures.access",
            "type": "boolean"
        },
        {
            "name": "heliosDashboardAccess",
            "baseName": "helios_dashboard.access",
            "type": "boolean"
        },
        {
            "name": "heliosLateFeeReminderBetaAccess",
            "baseName": "helios_late_fee_reminder.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosBulkActionsInvoicesBetaAccess",
            "baseName": "helios_bulk_actions_invoices.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosVirtualTerminalBetaAccess",
            "baseName": "helios_virtual_terminal.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosExpenseRebillingBetaAccess",
            "baseName": "helios_expense_rebilling.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosCompanyTaxesBetaAccess",
            "baseName": "helios_company_taxes.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosInvoiceArchiveBetaAccess",
            "baseName": "helios_invoice_archive.beta.access",
            "type": "boolean"
        },
        {
            "name": "accountantInviteAccess",
            "baseName": "accountant_invite.access",
            "type": "boolean"
        },
        {
            "name": "heliosSyncThrottleBetaAccess",
            "baseName": "helios_sync_throttle.beta.access",
            "type": "boolean"
        },
        {
            "name": "bankReconciliationAccess",
            "baseName": "BankReconciliation.access",
            "type": "boolean"
        },
        {
            "name": "heliosPushResourceToUseExecuteBetaAccess",
            "baseName": "helios_push_resource_to_use_execute.beta.access",
            "type": "boolean"
        },
        {
            "name": "newTimeTrackingAccess",
            "baseName": "new_time_tracking.access",
            "type": "boolean"
        },
        {
            "name": "bankRecSmartMatchAccess",
            "baseName": "bank_rec_smart_match.access",
            "type": "boolean"
        },
        {
            "name": "balanceSheetAccess",
            "baseName": "balance_sheet.access",
            "type": "boolean"
        },
        {
            "name": "invoiceV2SearchAccess",
            "baseName": "invoice_v2_search.access",
            "type": "boolean"
        },
        {
            "name": "importItemsCsvAccess",
            "baseName": "import_items_csv.access",
            "type": "boolean"
        },
        {
            "name": "exportClientsCsvAccess",
            "baseName": "export_clients_csv.access",
            "type": "boolean"
        },
        {
            "name": "heliosVirtualTerminalTutorialBetaAccess",
            "baseName": "helios_virtual_terminal_tutorial.beta.access",
            "type": "boolean"
        },
        {
            "name": "inlineExpenseEditAccess",
            "baseName": "inline_expense_edit.access",
            "type": "boolean"
        },
        {
            "name": "heliosVirtualTerminalAdvertisingBetaAccess",
            "baseName": "helios_virtual_terminal_advertising.beta.access",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return DowO0g.attributeTypeMap;
    }
}

export class E1rYq {
    'attachmentsAccess': boolean;
    'clientLimit': number;
    'richProposalsAccess': boolean;
    'staffLimit': number;
    'betaMobileCreateExpenseSubcategoryAccess': boolean;
    'iosBetaZendeskWidgetAccess': boolean;
    'mobileReceiptRebillingAccess': boolean;
    'proposalsCandidateAccess': boolean;
    'heliosPushnotificationsBetaAccess': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "attachmentsAccess",
            "baseName": "attachments.access",
            "type": "boolean"
        },
        {
            "name": "clientLimit",
            "baseName": "client.limit",
            "type": "number"
        },
        {
            "name": "richProposalsAccess",
            "baseName": "rich_proposals.access",
            "type": "boolean"
        },
        {
            "name": "staffLimit",
            "baseName": "staff.limit",
            "type": "number"
        },
        {
            "name": "betaMobileCreateExpenseSubcategoryAccess",
            "baseName": "beta_mobile_create_expense_subcategory.access",
            "type": "boolean"
        },
        {
            "name": "iosBetaZendeskWidgetAccess",
            "baseName": "ios_beta_zendesk_widget.access",
            "type": "boolean"
        },
        {
            "name": "mobileReceiptRebillingAccess",
            "baseName": "mobile_receipt_rebilling.access",
            "type": "boolean"
        },
        {
            "name": "proposalsCandidateAccess",
            "baseName": "proposals_candidate.access",
            "type": "boolean"
        },
        {
            "name": "heliosPushnotificationsBetaAccess",
            "baseName": "helios_pushnotifications.beta.access",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return E1rYq.attributeTypeMap;
    }
}

export class E4MaY {
    'attachmentsAccess': boolean;
    'clientLimit': number;
    'richProposalsAccess': boolean;
    'staffLimit': number;
    'betaMobileCreateExpenseSubcategoryAccess': boolean;
    'iosBetaZendeskWidgetAccess': boolean;
    'mobileReceiptRebillingAccess': boolean;
    'proposalsCandidateAccess': boolean;
    'heliosPushnotificationsBetaAccess': boolean;
    'esignaturesAccess': boolean;
    'autoBankImportAccess': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "attachmentsAccess",
            "baseName": "attachments.access",
            "type": "boolean"
        },
        {
            "name": "clientLimit",
            "baseName": "client.limit",
            "type": "number"
        },
        {
            "name": "richProposalsAccess",
            "baseName": "rich_proposals.access",
            "type": "boolean"
        },
        {
            "name": "staffLimit",
            "baseName": "staff.limit",
            "type": "number"
        },
        {
            "name": "betaMobileCreateExpenseSubcategoryAccess",
            "baseName": "beta_mobile_create_expense_subcategory.access",
            "type": "boolean"
        },
        {
            "name": "iosBetaZendeskWidgetAccess",
            "baseName": "ios_beta_zendesk_widget.access",
            "type": "boolean"
        },
        {
            "name": "mobileReceiptRebillingAccess",
            "baseName": "mobile_receipt_rebilling.access",
            "type": "boolean"
        },
        {
            "name": "proposalsCandidateAccess",
            "baseName": "proposals_candidate.access",
            "type": "boolean"
        },
        {
            "name": "heliosPushnotificationsBetaAccess",
            "baseName": "helios_pushnotifications.beta.access",
            "type": "boolean"
        },
        {
            "name": "esignaturesAccess",
            "baseName": "esignatures.access",
            "type": "boolean"
        },
        {
            "name": "autoBankImportAccess",
            "baseName": "auto_bank_import.access",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return E4MaY.attributeTypeMap;
    }
}

export class E86QZ {
    'advancedAccountingAccess': boolean;
    'advancedPaymentsAccess': boolean;
    'autoBankImportAccess': boolean;
    'autobillLimit': number;
    'bankImportAccess': boolean;
    'businessAccountantLimit': number;
    'clientLimit': number;
    'documentLimit': number;
    'editSubjectLineAccess': boolean;
    'lateFeeAccess': boolean;
    'lateReminderAccess': boolean;
    'paymentsFeesReportAccess': boolean;
    'quickbooksIntegrationAccess': boolean;
    'recurringRevenueReportAccess': boolean;
    'removeBrandingAccess': boolean;
    'staffLimit': number;
    'betaHeliosAsyncExpensesAccess': boolean;
    'betaMobileCreateExpenseSubcategoryAccess': boolean;
    'iosBetaZendeskWidgetAccess': boolean;
    'mobileReceiptRebillingAccess': boolean;
    'richProposalsAccess': boolean;
    'proposalsCandidateAccess': boolean;
    'heliosPushnotificationsBetaAccess': boolean;
    'iosBetaPaymentSchedulesAccess': boolean;
    'attachmentsAccess': boolean;
    'heliosRebillTimeAccess': boolean;
    'esignaturesAccess': boolean;
    'heliosDashboardAccess': boolean;
    'heliosLateFeeReminderBetaAccess': boolean;
    'heliosBulkActionsInvoicesBetaAccess': boolean;
    'heliosVirtualTerminalBetaAccess': boolean;
    'heliosExpenseRebillingBetaAccess': boolean;
    'heliosCompanyTaxesBetaAccess': boolean;
    'heliosInvoiceArchiveBetaAccess': boolean;
    'accountantInviteAccess': boolean;
    'heliosSyncThrottleBetaAccess': boolean;
    'retainersAccess': boolean;
    'bankReconciliationAccess': boolean;
    'heliosPushResourceToUseExecuteBetaAccess': boolean;
    'newTimeTrackingAccess': boolean;
    'bankRecSmartMatchAccess': boolean;
    'balanceSheetAccess': boolean;
    'invoiceV2SearchAccess': boolean;
    'importItemsCsvAccess': boolean;
    'exportClientsCsvAccess': boolean;
    'heliosVirtualTerminalTutorialBetaAccess': boolean;
    'inlineExpenseEditAccess': boolean;
    'heliosVirtualTerminalAdvertisingBetaAccess': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "advancedAccountingAccess",
            "baseName": "advanced_accounting.access",
            "type": "boolean"
        },
        {
            "name": "advancedPaymentsAccess",
            "baseName": "advanced_payments.access",
            "type": "boolean"
        },
        {
            "name": "autoBankImportAccess",
            "baseName": "auto_bank_import.access",
            "type": "boolean"
        },
        {
            "name": "autobillLimit",
            "baseName": "autobill.limit",
            "type": "number"
        },
        {
            "name": "bankImportAccess",
            "baseName": "bank_import.access",
            "type": "boolean"
        },
        {
            "name": "businessAccountantLimit",
            "baseName": "business_accountant.limit",
            "type": "number"
        },
        {
            "name": "clientLimit",
            "baseName": "client.limit",
            "type": "number"
        },
        {
            "name": "documentLimit",
            "baseName": "document.limit",
            "type": "number"
        },
        {
            "name": "editSubjectLineAccess",
            "baseName": "edit_subject_line.access",
            "type": "boolean"
        },
        {
            "name": "lateFeeAccess",
            "baseName": "late_fee.access",
            "type": "boolean"
        },
        {
            "name": "lateReminderAccess",
            "baseName": "late_reminder.access",
            "type": "boolean"
        },
        {
            "name": "paymentsFeesReportAccess",
            "baseName": "payments_fees_report.access",
            "type": "boolean"
        },
        {
            "name": "quickbooksIntegrationAccess",
            "baseName": "quickbooks_integration.access",
            "type": "boolean"
        },
        {
            "name": "recurringRevenueReportAccess",
            "baseName": "recurring_revenue_report.access",
            "type": "boolean"
        },
        {
            "name": "removeBrandingAccess",
            "baseName": "remove_branding.access",
            "type": "boolean"
        },
        {
            "name": "staffLimit",
            "baseName": "staff.limit",
            "type": "number"
        },
        {
            "name": "betaHeliosAsyncExpensesAccess",
            "baseName": "BetaHeliosAsyncExpenses.access",
            "type": "boolean"
        },
        {
            "name": "betaMobileCreateExpenseSubcategoryAccess",
            "baseName": "beta_mobile_create_expense_subcategory.access",
            "type": "boolean"
        },
        {
            "name": "iosBetaZendeskWidgetAccess",
            "baseName": "ios_beta_zendesk_widget.access",
            "type": "boolean"
        },
        {
            "name": "mobileReceiptRebillingAccess",
            "baseName": "mobile_receipt_rebilling.access",
            "type": "boolean"
        },
        {
            "name": "richProposalsAccess",
            "baseName": "rich_proposals.access",
            "type": "boolean"
        },
        {
            "name": "proposalsCandidateAccess",
            "baseName": "proposals_candidate.access",
            "type": "boolean"
        },
        {
            "name": "heliosPushnotificationsBetaAccess",
            "baseName": "helios_pushnotifications.beta.access",
            "type": "boolean"
        },
        {
            "name": "iosBetaPaymentSchedulesAccess",
            "baseName": "ios_beta_payment_schedules.access",
            "type": "boolean"
        },
        {
            "name": "attachmentsAccess",
            "baseName": "attachments.access",
            "type": "boolean"
        },
        {
            "name": "heliosRebillTimeAccess",
            "baseName": "helios_rebill_time.access",
            "type": "boolean"
        },
        {
            "name": "esignaturesAccess",
            "baseName": "esignatures.access",
            "type": "boolean"
        },
        {
            "name": "heliosDashboardAccess",
            "baseName": "helios_dashboard.access",
            "type": "boolean"
        },
        {
            "name": "heliosLateFeeReminderBetaAccess",
            "baseName": "helios_late_fee_reminder.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosBulkActionsInvoicesBetaAccess",
            "baseName": "helios_bulk_actions_invoices.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosVirtualTerminalBetaAccess",
            "baseName": "helios_virtual_terminal.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosExpenseRebillingBetaAccess",
            "baseName": "helios_expense_rebilling.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosCompanyTaxesBetaAccess",
            "baseName": "helios_company_taxes.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosInvoiceArchiveBetaAccess",
            "baseName": "helios_invoice_archive.beta.access",
            "type": "boolean"
        },
        {
            "name": "accountantInviteAccess",
            "baseName": "accountant_invite.access",
            "type": "boolean"
        },
        {
            "name": "heliosSyncThrottleBetaAccess",
            "baseName": "helios_sync_throttle.beta.access",
            "type": "boolean"
        },
        {
            "name": "retainersAccess",
            "baseName": "retainers.access",
            "type": "boolean"
        },
        {
            "name": "bankReconciliationAccess",
            "baseName": "BankReconciliation.access",
            "type": "boolean"
        },
        {
            "name": "heliosPushResourceToUseExecuteBetaAccess",
            "baseName": "helios_push_resource_to_use_execute.beta.access",
            "type": "boolean"
        },
        {
            "name": "newTimeTrackingAccess",
            "baseName": "new_time_tracking.access",
            "type": "boolean"
        },
        {
            "name": "bankRecSmartMatchAccess",
            "baseName": "bank_rec_smart_match.access",
            "type": "boolean"
        },
        {
            "name": "balanceSheetAccess",
            "baseName": "balance_sheet.access",
            "type": "boolean"
        },
        {
            "name": "invoiceV2SearchAccess",
            "baseName": "invoice_v2_search.access",
            "type": "boolean"
        },
        {
            "name": "importItemsCsvAccess",
            "baseName": "import_items_csv.access",
            "type": "boolean"
        },
        {
            "name": "exportClientsCsvAccess",
            "baseName": "export_clients_csv.access",
            "type": "boolean"
        },
        {
            "name": "heliosVirtualTerminalTutorialBetaAccess",
            "baseName": "helios_virtual_terminal_tutorial.beta.access",
            "type": "boolean"
        },
        {
            "name": "inlineExpenseEditAccess",
            "baseName": "inline_expense_edit.access",
            "type": "boolean"
        },
        {
            "name": "heliosVirtualTerminalAdvertisingBetaAccess",
            "baseName": "helios_virtual_terminal_advertising.beta.access",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return E86QZ.attributeTypeMap;
    }
}

export class EditSecondaryContactIDRequest {
    'contact': Contact1;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "contact",
            "baseName": "contact",
            "type": "Contact1"
        }    ];

    static getAttributeTypeMap() {
        return EditSecondaryContactIDRequest.attributeTypeMap;
    }
}

export class EeCnZ {
    'advancedAccountingAccess': boolean;
    'attachmentsAccess': boolean;
    'clientLimit': number;
    'richProposalsAccess': boolean;
    'staffLimit': number;
    'betaMobileCreateExpenseSubcategoryAccess': boolean;
    'iosBetaZendeskWidgetAccess': boolean;
    'mobileReceiptRebillingAccess': boolean;
    'proposalsCandidateAccess': boolean;
    'heliosPushnotificationsBetaAccess': boolean;
    'esignaturesAccess': boolean;
    'heliosBulkActionsInvoicesBetaAccess': boolean;
    'autoBankImportAccess': boolean;
    'heliosExpenseRebillingBetaAccess': boolean;
    'heliosCompanyTaxesBetaAccess': boolean;
    'heliosInvoiceArchiveBetaAccess': boolean;
    'heliosSyncThrottleBetaAccess': boolean;
    'heliosPushResourceToUseExecuteBetaAccess': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "advancedAccountingAccess",
            "baseName": "advanced_accounting.access",
            "type": "boolean"
        },
        {
            "name": "attachmentsAccess",
            "baseName": "attachments.access",
            "type": "boolean"
        },
        {
            "name": "clientLimit",
            "baseName": "client.limit",
            "type": "number"
        },
        {
            "name": "richProposalsAccess",
            "baseName": "rich_proposals.access",
            "type": "boolean"
        },
        {
            "name": "staffLimit",
            "baseName": "staff.limit",
            "type": "number"
        },
        {
            "name": "betaMobileCreateExpenseSubcategoryAccess",
            "baseName": "beta_mobile_create_expense_subcategory.access",
            "type": "boolean"
        },
        {
            "name": "iosBetaZendeskWidgetAccess",
            "baseName": "ios_beta_zendesk_widget.access",
            "type": "boolean"
        },
        {
            "name": "mobileReceiptRebillingAccess",
            "baseName": "mobile_receipt_rebilling.access",
            "type": "boolean"
        },
        {
            "name": "proposalsCandidateAccess",
            "baseName": "proposals_candidate.access",
            "type": "boolean"
        },
        {
            "name": "heliosPushnotificationsBetaAccess",
            "baseName": "helios_pushnotifications.beta.access",
            "type": "boolean"
        },
        {
            "name": "esignaturesAccess",
            "baseName": "esignatures.access",
            "type": "boolean"
        },
        {
            "name": "heliosBulkActionsInvoicesBetaAccess",
            "baseName": "helios_bulk_actions_invoices.beta.access",
            "type": "boolean"
        },
        {
            "name": "autoBankImportAccess",
            "baseName": "auto_bank_import.access",
            "type": "boolean"
        },
        {
            "name": "heliosExpenseRebillingBetaAccess",
            "baseName": "helios_expense_rebilling.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosCompanyTaxesBetaAccess",
            "baseName": "helios_company_taxes.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosInvoiceArchiveBetaAccess",
            "baseName": "helios_invoice_archive.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosSyncThrottleBetaAccess",
            "baseName": "helios_sync_throttle.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosPushResourceToUseExecuteBetaAccess",
            "baseName": "helios_push_resource_to_use_execute.beta.access",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return EeCnZ.attributeTypeMap;
    }
}

export class Entry {
    'accountingSystemid': string;
    'clientid': string;
    'creditid': string;
    'entryid': number;
    'expenseid': number;
    'id': number;
    'incomeid': string;
    'invoiceid': string;
    'paymentid': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountingSystemid",
            "baseName": "accounting_systemid",
            "type": "string"
        },
        {
            "name": "clientid",
            "baseName": "clientid",
            "type": "string"
        },
        {
            "name": "creditid",
            "baseName": "creditid",
            "type": "string"
        },
        {
            "name": "entryid",
            "baseName": "entryid",
            "type": "number"
        },
        {
            "name": "expenseid",
            "baseName": "expenseid",
            "type": "number"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "incomeid",
            "baseName": "incomeid",
            "type": "string"
        },
        {
            "name": "invoiceid",
            "baseName": "invoiceid",
            "type": "string"
        },
        {
            "name": "paymentid",
            "baseName": "paymentid",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Entry.attributeTypeMap;
    }
}

export class Error5 {
    'errno': number;
    'field': string;
    'message': string;
    'object': string;
    'value': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errno",
            "baseName": "errno",
            "type": "number"
        },
        {
            "name": "field",
            "baseName": "field",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "object",
            "baseName": "object",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Error5.attributeTypeMap;
    }
}

export class Estimate {
    'accepted': boolean;
    'accountingSystemid': string;
    'address': string;
    'amount': Amount;
    'city': string;
    'code': string;
    'country': string;
    'createDate': string;
    'createdAt': string;
    'currencyCode': string;
    'currentOrganization': string;
    'customerid': number;
    'description': string;
    'discountTotal': DiscountTotal;
    'discountValue': string;
    'displayStatus': string;
    'estimateNumber': string;
    'estimateid': number;
    'extArchive': number;
    'fname': string;
    'id': number;
    'invoiced': boolean;
    'language': string;
    'lname': string;
    'notes': string;
    'organization': string;
    'ownerid': number;
    'poNumber': string;
    'province': string;
    'replyStatus': string;
    'requireClientSignature': boolean;
    'richProposal': boolean;
    'sentid': number;
    'status': number;
    'street': string;
    'street2': string;
    'template': string;
    'terms': string;
    'uiStatus': string;
    'updated': string;
    'vatName': string;
    'vatNumber': string;
    'visState': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accepted",
            "baseName": "accepted",
            "type": "boolean"
        },
        {
            "name": "accountingSystemid",
            "baseName": "accounting_systemid",
            "type": "string"
        },
        {
            "name": "address",
            "baseName": "address",
            "type": "string"
        },
        {
            "name": "amount",
            "baseName": "amount",
            "type": "Amount"
        },
        {
            "name": "city",
            "baseName": "city",
            "type": "string"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "createDate",
            "baseName": "create_date",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "currencyCode",
            "baseName": "currency_code",
            "type": "string"
        },
        {
            "name": "currentOrganization",
            "baseName": "current_organization",
            "type": "string"
        },
        {
            "name": "customerid",
            "baseName": "customerid",
            "type": "number"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "discountTotal",
            "baseName": "discount_total",
            "type": "DiscountTotal"
        },
        {
            "name": "discountValue",
            "baseName": "discount_value",
            "type": "string"
        },
        {
            "name": "displayStatus",
            "baseName": "display_status",
            "type": "string"
        },
        {
            "name": "estimateNumber",
            "baseName": "estimate_number",
            "type": "string"
        },
        {
            "name": "estimateid",
            "baseName": "estimateid",
            "type": "number"
        },
        {
            "name": "extArchive",
            "baseName": "ext_archive",
            "type": "number"
        },
        {
            "name": "fname",
            "baseName": "fname",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "invoiced",
            "baseName": "invoiced",
            "type": "boolean"
        },
        {
            "name": "language",
            "baseName": "language",
            "type": "string"
        },
        {
            "name": "lname",
            "baseName": "lname",
            "type": "string"
        },
        {
            "name": "notes",
            "baseName": "notes",
            "type": "string"
        },
        {
            "name": "organization",
            "baseName": "organization",
            "type": "string"
        },
        {
            "name": "ownerid",
            "baseName": "ownerid",
            "type": "number"
        },
        {
            "name": "poNumber",
            "baseName": "po_number",
            "type": "string"
        },
        {
            "name": "province",
            "baseName": "province",
            "type": "string"
        },
        {
            "name": "replyStatus",
            "baseName": "reply_status",
            "type": "string"
        },
        {
            "name": "requireClientSignature",
            "baseName": "require_client_signature",
            "type": "boolean"
        },
        {
            "name": "richProposal",
            "baseName": "rich_proposal",
            "type": "boolean"
        },
        {
            "name": "sentid",
            "baseName": "sentid",
            "type": "number"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "number"
        },
        {
            "name": "street",
            "baseName": "street",
            "type": "string"
        },
        {
            "name": "street2",
            "baseName": "street2",
            "type": "string"
        },
        {
            "name": "template",
            "baseName": "template",
            "type": "string"
        },
        {
            "name": "terms",
            "baseName": "terms",
            "type": "string"
        },
        {
            "name": "uiStatus",
            "baseName": "ui_status",
            "type": "string"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "string"
        },
        {
            "name": "vatName",
            "baseName": "vat_name",
            "type": "string"
        },
        {
            "name": "vatNumber",
            "baseName": "vat_number",
            "type": "string"
        },
        {
            "name": "visState",
            "baseName": "vis_state",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Estimate.attributeTypeMap;
    }
}

export class Estimate2 {
    'accepted': boolean;
    'accountingSystemid': string;
    'address': string;
    'amount': Amount;
    'city': string;
    'code': string;
    'country': string;
    'createDate': string;
    'createdAt': string;
    'currencyCode': string;
    'currentOrganization': string;
    'customerid': number;
    'description': string;
    'discountTotal': DiscountTotal;
    'discountValue': string;
    'displayStatus': string;
    'estimateNumber': string;
    'estimateid': number;
    'extArchive': number;
    'fname': string;
    'id': number;
    'invoiced': boolean;
    'language': string;
    'lname': string;
    'notes': string;
    'organization': string;
    'ownerid': number;
    'poNumber': string;
    'province': string;
    'replyStatus': string;
    'requireClientSignature': boolean;
    'richProposal': boolean;
    'sentid': number;
    'status': number;
    'street': string;
    'street2': string;
    'template': string;
    'terms': string;
    'uiStatus': string;
    'updated': string;
    'vatName': string;
    'vatNumber': string;
    'visState': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accepted",
            "baseName": "accepted",
            "type": "boolean"
        },
        {
            "name": "accountingSystemid",
            "baseName": "accounting_systemid",
            "type": "string"
        },
        {
            "name": "address",
            "baseName": "address",
            "type": "string"
        },
        {
            "name": "amount",
            "baseName": "amount",
            "type": "Amount"
        },
        {
            "name": "city",
            "baseName": "city",
            "type": "string"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "createDate",
            "baseName": "create_date",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "currencyCode",
            "baseName": "currency_code",
            "type": "string"
        },
        {
            "name": "currentOrganization",
            "baseName": "current_organization",
            "type": "string"
        },
        {
            "name": "customerid",
            "baseName": "customerid",
            "type": "number"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "discountTotal",
            "baseName": "discount_total",
            "type": "DiscountTotal"
        },
        {
            "name": "discountValue",
            "baseName": "discount_value",
            "type": "string"
        },
        {
            "name": "displayStatus",
            "baseName": "display_status",
            "type": "string"
        },
        {
            "name": "estimateNumber",
            "baseName": "estimate_number",
            "type": "string"
        },
        {
            "name": "estimateid",
            "baseName": "estimateid",
            "type": "number"
        },
        {
            "name": "extArchive",
            "baseName": "ext_archive",
            "type": "number"
        },
        {
            "name": "fname",
            "baseName": "fname",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "invoiced",
            "baseName": "invoiced",
            "type": "boolean"
        },
        {
            "name": "language",
            "baseName": "language",
            "type": "string"
        },
        {
            "name": "lname",
            "baseName": "lname",
            "type": "string"
        },
        {
            "name": "notes",
            "baseName": "notes",
            "type": "string"
        },
        {
            "name": "organization",
            "baseName": "organization",
            "type": "string"
        },
        {
            "name": "ownerid",
            "baseName": "ownerid",
            "type": "number"
        },
        {
            "name": "poNumber",
            "baseName": "po_number",
            "type": "string"
        },
        {
            "name": "province",
            "baseName": "province",
            "type": "string"
        },
        {
            "name": "replyStatus",
            "baseName": "reply_status",
            "type": "string"
        },
        {
            "name": "requireClientSignature",
            "baseName": "require_client_signature",
            "type": "boolean"
        },
        {
            "name": "richProposal",
            "baseName": "rich_proposal",
            "type": "boolean"
        },
        {
            "name": "sentid",
            "baseName": "sentid",
            "type": "number"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "number"
        },
        {
            "name": "street",
            "baseName": "street",
            "type": "string"
        },
        {
            "name": "street2",
            "baseName": "street2",
            "type": "string"
        },
        {
            "name": "template",
            "baseName": "template",
            "type": "string"
        },
        {
            "name": "terms",
            "baseName": "terms",
            "type": "string"
        },
        {
            "name": "uiStatus",
            "baseName": "ui_status",
            "type": "string"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "string"
        },
        {
            "name": "vatName",
            "baseName": "vat_name",
            "type": "string"
        },
        {
            "name": "vatNumber",
            "baseName": "vat_number",
            "type": "string"
        },
        {
            "name": "visState",
            "baseName": "vis_state",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Estimate2.attributeTypeMap;
    }
}

export class Estimate4 {
    'visState': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "visState",
            "baseName": "vis_state",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Estimate4.attributeTypeMap;
    }
}

export class Estimate6 {
    'actionAccept': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "actionAccept",
            "baseName": "action_accept",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Estimate6.attributeTypeMap;
    }
}

export class Expense {
    'accountName': string;
    'accountid': string;
    'accountingSystemid': string;
    'amount': Amount;
    'attachment': Attachment;
    'backgroundJobid': string;
    'bankName': string;
    'category': Category;
    'categoryid': number;
    'clientid': number;
    'compoundedTax': boolean;
    'date': string;
    'expenseProfile': string;
    'expenseid': number;
    'extInvoiceid': number;
    'extSystemid': number;
    'fromBulkImport': boolean;
    'hasReceipt': boolean;
    'id': number;
    'includeReceipt': boolean;
    'invoiceid': string;
    'isCogs': boolean;
    'isduplicate': boolean;
    'markupPercent': string;
    'notes': string;
    'profileid': string;
    'project': string;
    'projectid': number;
    'staffid': number;
    'status': number;
    'taxAmount1': TaxAmount1;
    'taxAmount2': string;
    'taxName1': string;
    'taxName2': string;
    'taxPercent1': string;
    'taxPercent2': string;
    'transactionid': string;
    'updated': string;
    'vendor': string;
    'visState': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountName",
            "baseName": "account_name",
            "type": "string"
        },
        {
            "name": "accountid",
            "baseName": "accountid",
            "type": "string"
        },
        {
            "name": "accountingSystemid",
            "baseName": "accounting_systemid",
            "type": "string"
        },
        {
            "name": "amount",
            "baseName": "amount",
            "type": "Amount"
        },
        {
            "name": "attachment",
            "baseName": "attachment",
            "type": "Attachment"
        },
        {
            "name": "backgroundJobid",
            "baseName": "background_jobid",
            "type": "string"
        },
        {
            "name": "bankName",
            "baseName": "bank_name",
            "type": "string"
        },
        {
            "name": "category",
            "baseName": "category",
            "type": "Category"
        },
        {
            "name": "categoryid",
            "baseName": "categoryid",
            "type": "number"
        },
        {
            "name": "clientid",
            "baseName": "clientid",
            "type": "number"
        },
        {
            "name": "compoundedTax",
            "baseName": "compounded_tax",
            "type": "boolean"
        },
        {
            "name": "date",
            "baseName": "date",
            "type": "string"
        },
        {
            "name": "expenseProfile",
            "baseName": "expense_profile",
            "type": "string"
        },
        {
            "name": "expenseid",
            "baseName": "expenseid",
            "type": "number"
        },
        {
            "name": "extInvoiceid",
            "baseName": "ext_invoiceid",
            "type": "number"
        },
        {
            "name": "extSystemid",
            "baseName": "ext_systemid",
            "type": "number"
        },
        {
            "name": "fromBulkImport",
            "baseName": "from_bulk_import",
            "type": "boolean"
        },
        {
            "name": "hasReceipt",
            "baseName": "has_receipt",
            "type": "boolean"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "includeReceipt",
            "baseName": "include_receipt",
            "type": "boolean"
        },
        {
            "name": "invoiceid",
            "baseName": "invoiceid",
            "type": "string"
        },
        {
            "name": "isCogs",
            "baseName": "is_cogs",
            "type": "boolean"
        },
        {
            "name": "isduplicate",
            "baseName": "isduplicate",
            "type": "boolean"
        },
        {
            "name": "markupPercent",
            "baseName": "markup_percent",
            "type": "string"
        },
        {
            "name": "notes",
            "baseName": "notes",
            "type": "string"
        },
        {
            "name": "profileid",
            "baseName": "profileid",
            "type": "string"
        },
        {
            "name": "project",
            "baseName": "project",
            "type": "string"
        },
        {
            "name": "projectid",
            "baseName": "projectid",
            "type": "number"
        },
        {
            "name": "staffid",
            "baseName": "staffid",
            "type": "number"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "number"
        },
        {
            "name": "taxAmount1",
            "baseName": "taxAmount1",
            "type": "TaxAmount1"
        },
        {
            "name": "taxAmount2",
            "baseName": "taxAmount2",
            "type": "string"
        },
        {
            "name": "taxName1",
            "baseName": "taxName1",
            "type": "string"
        },
        {
            "name": "taxName2",
            "baseName": "taxName2",
            "type": "string"
        },
        {
            "name": "taxPercent1",
            "baseName": "taxPercent1",
            "type": "string"
        },
        {
            "name": "taxPercent2",
            "baseName": "taxPercent2",
            "type": "string"
        },
        {
            "name": "transactionid",
            "baseName": "transactionid",
            "type": "string"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "string"
        },
        {
            "name": "vendor",
            "baseName": "vendor",
            "type": "string"
        },
        {
            "name": "visState",
            "baseName": "vis_state",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Expense.attributeTypeMap;
    }
}

export class Expense1 {
    'transactionid': string;
    'status': string;
    'hasReceipt': boolean;
    'alwaysRemember': boolean;
    'isCogs': boolean;
    'accountName': string;
    'includeReceipt': boolean;
    'amount': Amount;
    'notes': string;
    'vendor': string;
    'date': string;
    'staffid': number;
    'authorName': string;
    'taxName1': string;
    'taxName2': string;
    'taxAmount1': TaxAmount11;
    'taxPercent1': number;
    'taxPercent2': string;
    'markupPercent': number;
    'invoiceid': string;
    'attachment': Attachment1;
    'categoryid': string;
    'categoryName': string;
    'clientid': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "transactionid",
            "baseName": "transactionid",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "hasReceipt",
            "baseName": "has_receipt",
            "type": "boolean"
        },
        {
            "name": "alwaysRemember",
            "baseName": "always_remember",
            "type": "boolean"
        },
        {
            "name": "isCogs",
            "baseName": "is_cogs",
            "type": "boolean"
        },
        {
            "name": "accountName",
            "baseName": "account_name",
            "type": "string"
        },
        {
            "name": "includeReceipt",
            "baseName": "include_receipt",
            "type": "boolean"
        },
        {
            "name": "amount",
            "baseName": "amount",
            "type": "Amount"
        },
        {
            "name": "notes",
            "baseName": "notes",
            "type": "string"
        },
        {
            "name": "vendor",
            "baseName": "vendor",
            "type": "string"
        },
        {
            "name": "date",
            "baseName": "date",
            "type": "string"
        },
        {
            "name": "staffid",
            "baseName": "staffid",
            "type": "number"
        },
        {
            "name": "authorName",
            "baseName": "author_name",
            "type": "string"
        },
        {
            "name": "taxName1",
            "baseName": "taxName1",
            "type": "string"
        },
        {
            "name": "taxName2",
            "baseName": "taxName2",
            "type": "string"
        },
        {
            "name": "taxAmount1",
            "baseName": "taxAmount1",
            "type": "TaxAmount11"
        },
        {
            "name": "taxPercent1",
            "baseName": "taxPercent1",
            "type": "number"
        },
        {
            "name": "taxPercent2",
            "baseName": "taxPercent2",
            "type": "string"
        },
        {
            "name": "markupPercent",
            "baseName": "markup_percent",
            "type": "number"
        },
        {
            "name": "invoiceid",
            "baseName": "invoiceid",
            "type": "string"
        },
        {
            "name": "attachment",
            "baseName": "attachment",
            "type": "Attachment1"
        },
        {
            "name": "categoryid",
            "baseName": "categoryid",
            "type": "string"
        },
        {
            "name": "categoryName",
            "baseName": "category_name",
            "type": "string"
        },
        {
            "name": "clientid",
            "baseName": "clientid",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Expense1.attributeTypeMap;
    }
}

export class Expense2 {
    'accountName': string;
    'accountid': string;
    'accountingSystemid': string;
    'amount': Amount;
    'attachment': Attachment2;
    'backgroundJobid': string;
    'bankName': string;
    'categoryid': number;
    'clientid': number;
    'compoundedTax': boolean;
    'date': string;
    'expenseid': number;
    'extInvoiceid': number;
    'extSystemid': number;
    'fromBulkImport': boolean;
    'hasReceipt': boolean;
    'id': number;
    'includeReceipt': boolean;
    'invoiceid': string;
    'isCogs': boolean;
    'isduplicate': boolean;
    'markupPercent': string;
    'notes': string;
    'profileid': string;
    'projectid': number;
    'staffid': number;
    'status': number;
    'taxAmount1': TaxAmount11;
    'taxAmount2': string;
    'taxName1': string;
    'taxName2': string;
    'taxPercent1': string;
    'taxPercent2': string;
    'transactionid': string;
    'updated': string;
    'vendor': string;
    'visState': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountName",
            "baseName": "account_name",
            "type": "string"
        },
        {
            "name": "accountid",
            "baseName": "accountid",
            "type": "string"
        },
        {
            "name": "accountingSystemid",
            "baseName": "accounting_systemid",
            "type": "string"
        },
        {
            "name": "amount",
            "baseName": "amount",
            "type": "Amount"
        },
        {
            "name": "attachment",
            "baseName": "attachment",
            "type": "Attachment2"
        },
        {
            "name": "backgroundJobid",
            "baseName": "background_jobid",
            "type": "string"
        },
        {
            "name": "bankName",
            "baseName": "bank_name",
            "type": "string"
        },
        {
            "name": "categoryid",
            "baseName": "categoryid",
            "type": "number"
        },
        {
            "name": "clientid",
            "baseName": "clientid",
            "type": "number"
        },
        {
            "name": "compoundedTax",
            "baseName": "compounded_tax",
            "type": "boolean"
        },
        {
            "name": "date",
            "baseName": "date",
            "type": "string"
        },
        {
            "name": "expenseid",
            "baseName": "expenseid",
            "type": "number"
        },
        {
            "name": "extInvoiceid",
            "baseName": "ext_invoiceid",
            "type": "number"
        },
        {
            "name": "extSystemid",
            "baseName": "ext_systemid",
            "type": "number"
        },
        {
            "name": "fromBulkImport",
            "baseName": "from_bulk_import",
            "type": "boolean"
        },
        {
            "name": "hasReceipt",
            "baseName": "has_receipt",
            "type": "boolean"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "includeReceipt",
            "baseName": "include_receipt",
            "type": "boolean"
        },
        {
            "name": "invoiceid",
            "baseName": "invoiceid",
            "type": "string"
        },
        {
            "name": "isCogs",
            "baseName": "is_cogs",
            "type": "boolean"
        },
        {
            "name": "isduplicate",
            "baseName": "isduplicate",
            "type": "boolean"
        },
        {
            "name": "markupPercent",
            "baseName": "markup_percent",
            "type": "string"
        },
        {
            "name": "notes",
            "baseName": "notes",
            "type": "string"
        },
        {
            "name": "profileid",
            "baseName": "profileid",
            "type": "string"
        },
        {
            "name": "projectid",
            "baseName": "projectid",
            "type": "number"
        },
        {
            "name": "staffid",
            "baseName": "staffid",
            "type": "number"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "number"
        },
        {
            "name": "taxAmount1",
            "baseName": "taxAmount1",
            "type": "TaxAmount11"
        },
        {
            "name": "taxAmount2",
            "baseName": "taxAmount2",
            "type": "string"
        },
        {
            "name": "taxName1",
            "baseName": "taxName1",
            "type": "string"
        },
        {
            "name": "taxName2",
            "baseName": "taxName2",
            "type": "string"
        },
        {
            "name": "taxPercent1",
            "baseName": "taxPercent1",
            "type": "string"
        },
        {
            "name": "taxPercent2",
            "baseName": "taxPercent2",
            "type": "string"
        },
        {
            "name": "transactionid",
            "baseName": "transactionid",
            "type": "string"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "string"
        },
        {
            "name": "vendor",
            "baseName": "vendor",
            "type": "string"
        },
        {
            "name": "visState",
            "baseName": "vis_state",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Expense2.attributeTypeMap;
    }
}

export class Expense3 {
    'transactionid': string;
    'status': string;
    'hasReceipt': boolean;
    'alwaysRemember': boolean;
    'isCogs': boolean;
    'accountName': string;
    'includeReceipt': boolean;
    'amount': Amount;
    'notes': string;
    'vendor': string;
    'date': string;
    'staffid': number;
    'authorName': string;
    'taxName1': string;
    'taxName2': string;
    'taxAmount1': TaxAmount11;
    'taxPercent1': number;
    'taxPercent2': string;
    'markupPercent': string;
    'invoiceid': string;
    'attachment': Attachment1;
    'categoryid': string;
    'clientid': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "transactionid",
            "baseName": "transactionid",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "hasReceipt",
            "baseName": "has_receipt",
            "type": "boolean"
        },
        {
            "name": "alwaysRemember",
            "baseName": "always_remember",
            "type": "boolean"
        },
        {
            "name": "isCogs",
            "baseName": "is_cogs",
            "type": "boolean"
        },
        {
            "name": "accountName",
            "baseName": "account_name",
            "type": "string"
        },
        {
            "name": "includeReceipt",
            "baseName": "include_receipt",
            "type": "boolean"
        },
        {
            "name": "amount",
            "baseName": "amount",
            "type": "Amount"
        },
        {
            "name": "notes",
            "baseName": "notes",
            "type": "string"
        },
        {
            "name": "vendor",
            "baseName": "vendor",
            "type": "string"
        },
        {
            "name": "date",
            "baseName": "date",
            "type": "string"
        },
        {
            "name": "staffid",
            "baseName": "staffid",
            "type": "number"
        },
        {
            "name": "authorName",
            "baseName": "author_name",
            "type": "string"
        },
        {
            "name": "taxName1",
            "baseName": "taxName1",
            "type": "string"
        },
        {
            "name": "taxName2",
            "baseName": "taxName2",
            "type": "string"
        },
        {
            "name": "taxAmount1",
            "baseName": "taxAmount1",
            "type": "TaxAmount11"
        },
        {
            "name": "taxPercent1",
            "baseName": "taxPercent1",
            "type": "number"
        },
        {
            "name": "taxPercent2",
            "baseName": "taxPercent2",
            "type": "string"
        },
        {
            "name": "markupPercent",
            "baseName": "markup_percent",
            "type": "string"
        },
        {
            "name": "invoiceid",
            "baseName": "invoiceid",
            "type": "string"
        },
        {
            "name": "attachment",
            "baseName": "attachment",
            "type": "Attachment1"
        },
        {
            "name": "categoryid",
            "baseName": "categoryid",
            "type": "string"
        },
        {
            "name": "clientid",
            "baseName": "clientid",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Expense3.attributeTypeMap;
    }
}

export class Expense5 {
    'vendor': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "vendor",
            "baseName": "vendor",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Expense5.attributeTypeMap;
    }
}

export class Expense6 {
    'accountName': string;
    'accountid': string;
    'accountingSystemid': string;
    'amount': Amount;
    'backgroundJobid': string;
    'bankName': string;
    'categoryid': number;
    'clientid': number;
    'compoundedTax': boolean;
    'date': string;
    'expenseid': number;
    'extInvoiceid': number;
    'extSystemid': number;
    'fromBulkImport': boolean;
    'hasReceipt': boolean;
    'id': number;
    'includeReceipt': boolean;
    'invoiceid': string;
    'isCogs': boolean;
    'isduplicate': boolean;
    'markupPercent': string;
    'notes': string;
    'profileid': string;
    'projectid': number;
    'staffid': number;
    'status': number;
    'taxAmount1': TaxAmount11;
    'taxAmount2': string;
    'taxName1': string;
    'taxName2': string;
    'taxPercent1': string;
    'taxPercent2': string;
    'transactionid': string;
    'updated': string;
    'vendor': string;
    'visState': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountName",
            "baseName": "account_name",
            "type": "string"
        },
        {
            "name": "accountid",
            "baseName": "accountid",
            "type": "string"
        },
        {
            "name": "accountingSystemid",
            "baseName": "accounting_systemid",
            "type": "string"
        },
        {
            "name": "amount",
            "baseName": "amount",
            "type": "Amount"
        },
        {
            "name": "backgroundJobid",
            "baseName": "background_jobid",
            "type": "string"
        },
        {
            "name": "bankName",
            "baseName": "bank_name",
            "type": "string"
        },
        {
            "name": "categoryid",
            "baseName": "categoryid",
            "type": "number"
        },
        {
            "name": "clientid",
            "baseName": "clientid",
            "type": "number"
        },
        {
            "name": "compoundedTax",
            "baseName": "compounded_tax",
            "type": "boolean"
        },
        {
            "name": "date",
            "baseName": "date",
            "type": "string"
        },
        {
            "name": "expenseid",
            "baseName": "expenseid",
            "type": "number"
        },
        {
            "name": "extInvoiceid",
            "baseName": "ext_invoiceid",
            "type": "number"
        },
        {
            "name": "extSystemid",
            "baseName": "ext_systemid",
            "type": "number"
        },
        {
            "name": "fromBulkImport",
            "baseName": "from_bulk_import",
            "type": "boolean"
        },
        {
            "name": "hasReceipt",
            "baseName": "has_receipt",
            "type": "boolean"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "includeReceipt",
            "baseName": "include_receipt",
            "type": "boolean"
        },
        {
            "name": "invoiceid",
            "baseName": "invoiceid",
            "type": "string"
        },
        {
            "name": "isCogs",
            "baseName": "is_cogs",
            "type": "boolean"
        },
        {
            "name": "isduplicate",
            "baseName": "isduplicate",
            "type": "boolean"
        },
        {
            "name": "markupPercent",
            "baseName": "markup_percent",
            "type": "string"
        },
        {
            "name": "notes",
            "baseName": "notes",
            "type": "string"
        },
        {
            "name": "profileid",
            "baseName": "profileid",
            "type": "string"
        },
        {
            "name": "projectid",
            "baseName": "projectid",
            "type": "number"
        },
        {
            "name": "staffid",
            "baseName": "staffid",
            "type": "number"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "number"
        },
        {
            "name": "taxAmount1",
            "baseName": "taxAmount1",
            "type": "TaxAmount11"
        },
        {
            "name": "taxAmount2",
            "baseName": "taxAmount2",
            "type": "string"
        },
        {
            "name": "taxName1",
            "baseName": "taxName1",
            "type": "string"
        },
        {
            "name": "taxName2",
            "baseName": "taxName2",
            "type": "string"
        },
        {
            "name": "taxPercent1",
            "baseName": "taxPercent1",
            "type": "string"
        },
        {
            "name": "taxPercent2",
            "baseName": "taxPercent2",
            "type": "string"
        },
        {
            "name": "transactionid",
            "baseName": "transactionid",
            "type": "string"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "string"
        },
        {
            "name": "vendor",
            "baseName": "vendor",
            "type": "string"
        },
        {
            "name": "visState",
            "baseName": "vis_state",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Expense6.attributeTypeMap;
    }
}

export class Expense8 {
    'visState': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "visState",
            "baseName": "vis_state",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Expense8.attributeTypeMap;
    }
}

export class Expense9 {
    'children': Array<Child>;
    'data': Array<string>;
    'description': string;
    'entryType': string;
    'total': Total;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "children",
            "baseName": "children",
            "type": "Array<Child>"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<string>"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "entryType",
            "baseName": "entry_type",
            "type": "string"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "Total"
        }    ];

    static getAttributeTypeMap() {
        return Expense9.attributeTypeMap;
    }
}

export class ExpenseProfile {
    'frequency': string;
    'profileid': string;
    'startDate': string;
    'endDate': string;
    'nextIssueDate': string;
    'isCogs': boolean;
    'amount': Amount;
    'notes': string;
    'vendor': string;
    'staffid': number;
    'authorName': string;
    'taxName1': string;
    'taxName2': string;
    'taxAmount1': TaxAmount11;
    'taxPercent1': number;
    'taxPercent2': string;
    'markupPercent': string;
    'fromBulkImport': boolean;
    'categoryid': string;
    'clientid': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "frequency",
            "baseName": "frequency",
            "type": "string"
        },
        {
            "name": "profileid",
            "baseName": "profileid",
            "type": "string"
        },
        {
            "name": "startDate",
            "baseName": "start_date",
            "type": "string"
        },
        {
            "name": "endDate",
            "baseName": "end_date",
            "type": "string"
        },
        {
            "name": "nextIssueDate",
            "baseName": "next_issue_date",
            "type": "string"
        },
        {
            "name": "isCogs",
            "baseName": "is_cogs",
            "type": "boolean"
        },
        {
            "name": "amount",
            "baseName": "amount",
            "type": "Amount"
        },
        {
            "name": "notes",
            "baseName": "notes",
            "type": "string"
        },
        {
            "name": "vendor",
            "baseName": "vendor",
            "type": "string"
        },
        {
            "name": "staffid",
            "baseName": "staffid",
            "type": "number"
        },
        {
            "name": "authorName",
            "baseName": "author_name",
            "type": "string"
        },
        {
            "name": "taxName1",
            "baseName": "taxName1",
            "type": "string"
        },
        {
            "name": "taxName2",
            "baseName": "taxName2",
            "type": "string"
        },
        {
            "name": "taxAmount1",
            "baseName": "taxAmount1",
            "type": "TaxAmount11"
        },
        {
            "name": "taxPercent1",
            "baseName": "taxPercent1",
            "type": "number"
        },
        {
            "name": "taxPercent2",
            "baseName": "taxPercent2",
            "type": "string"
        },
        {
            "name": "markupPercent",
            "baseName": "markup_percent",
            "type": "string"
        },
        {
            "name": "fromBulkImport",
            "baseName": "from_bulk_import",
            "type": "boolean"
        },
        {
            "name": "categoryid",
            "baseName": "categoryid",
            "type": "string"
        },
        {
            "name": "clientid",
            "baseName": "clientid",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ExpenseProfile.attributeTypeMap;
    }
}

export class ExpenseSummariesResponse {
    'response': Response48;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Response48"
        }    ];

    static getAttributeTypeMap() {
        return ExpenseSummariesResponse.attributeTypeMap;
    }
}

export class Fbpay {
    'currencies': Array<string>;
    'accountId': string;
    'actionReasons': Array<string>;
    'country': string;
    'tosAccepted': boolean;
    'email': string;
    'manageAccountUrl': string;
    'state': string;
    'bankInfo': BankInfo;
    'pricing': Pricing;
    'visaDebitAccepted': boolean;
    'id': string;
    'bankTransferEnabled': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "currencies",
            "baseName": "currencies",
            "type": "Array<string>"
        },
        {
            "name": "accountId",
            "baseName": "account_id",
            "type": "string"
        },
        {
            "name": "actionReasons",
            "baseName": "action_reasons",
            "type": "Array<string>"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "tosAccepted",
            "baseName": "tos_accepted",
            "type": "boolean"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "manageAccountUrl",
            "baseName": "manage_account_url",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "bankInfo",
            "baseName": "bank_info",
            "type": "BankInfo"
        },
        {
            "name": "pricing",
            "baseName": "pricing",
            "type": "Pricing"
        },
        {
            "name": "visaDebitAccepted",
            "baseName": "visa_debit_accepted",
            "type": "boolean"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "bankTransferEnabled",
            "baseName": "bank_transfer_enabled",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Fbpay.attributeTypeMap;
    }
}

export class G2MB3M {
    'advancedAccountingAccess': boolean;
    'attachmentsAccess': boolean;
    'businessAccountantLimit': number;
    'clientLimit': number;
    'proposalsCandidateAccess': boolean;
    'richProposalsAccess': boolean;
    'staffLimit': number;
    'betaHeliosAsyncExpensesAccess': boolean;
    'betaMobileCreateExpenseSubcategoryAccess': boolean;
    'iosBetaZendeskWidgetAccess': boolean;
    'mobileReceiptRebillingAccess': boolean;
    'heliosPushnotificationsBetaAccess': boolean;
    'iosBetaPaymentSchedulesAccess': boolean;
    'heliosRebillTimeAccess': boolean;
    'esignaturesAccess': boolean;
    'heliosDashboardAccess': boolean;
    'heliosLateFeeReminderBetaAccess': boolean;
    'heliosBulkActionsInvoicesBetaAccess': boolean;
    'autoBankImportAccess': boolean;
    'heliosVirtualTerminalBetaAccess': boolean;
    'heliosExpenseRebillingBetaAccess': boolean;
    'heliosCompanyTaxesBetaAccess': boolean;
    'heliosInvoiceArchiveBetaAccess': boolean;
    'accountantInviteAccess': boolean;
    'premiumContractorRoleAccess': boolean;
    'heliosSyncThrottleBetaAccess': boolean;
    'bankReconciliationAccess': boolean;
    'heliosPushResourceToUseExecuteBetaAccess': boolean;
    'newTimeTrackingAccess': boolean;
    'bankRecSmartMatchAccess': boolean;
    'balanceSheetAccess': boolean;
    'invoiceV2SearchAccess': boolean;
    'importItemsCsvAccess': boolean;
    'exportClientsCsvAccess': boolean;
    'heliosVirtualTerminalTutorialBetaAccess': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "advancedAccountingAccess",
            "baseName": "advanced_accounting.access",
            "type": "boolean"
        },
        {
            "name": "attachmentsAccess",
            "baseName": "attachments.access",
            "type": "boolean"
        },
        {
            "name": "businessAccountantLimit",
            "baseName": "business_accountant.limit",
            "type": "number"
        },
        {
            "name": "clientLimit",
            "baseName": "client.limit",
            "type": "number"
        },
        {
            "name": "proposalsCandidateAccess",
            "baseName": "proposals_candidate.access",
            "type": "boolean"
        },
        {
            "name": "richProposalsAccess",
            "baseName": "rich_proposals.access",
            "type": "boolean"
        },
        {
            "name": "staffLimit",
            "baseName": "staff.limit",
            "type": "number"
        },
        {
            "name": "betaHeliosAsyncExpensesAccess",
            "baseName": "BetaHeliosAsyncExpenses.access",
            "type": "boolean"
        },
        {
            "name": "betaMobileCreateExpenseSubcategoryAccess",
            "baseName": "beta_mobile_create_expense_subcategory.access",
            "type": "boolean"
        },
        {
            "name": "iosBetaZendeskWidgetAccess",
            "baseName": "ios_beta_zendesk_widget.access",
            "type": "boolean"
        },
        {
            "name": "mobileReceiptRebillingAccess",
            "baseName": "mobile_receipt_rebilling.access",
            "type": "boolean"
        },
        {
            "name": "heliosPushnotificationsBetaAccess",
            "baseName": "helios_pushnotifications.beta.access",
            "type": "boolean"
        },
        {
            "name": "iosBetaPaymentSchedulesAccess",
            "baseName": "ios_beta_payment_schedules.access",
            "type": "boolean"
        },
        {
            "name": "heliosRebillTimeAccess",
            "baseName": "helios_rebill_time.access",
            "type": "boolean"
        },
        {
            "name": "esignaturesAccess",
            "baseName": "esignatures.access",
            "type": "boolean"
        },
        {
            "name": "heliosDashboardAccess",
            "baseName": "helios_dashboard.access",
            "type": "boolean"
        },
        {
            "name": "heliosLateFeeReminderBetaAccess",
            "baseName": "helios_late_fee_reminder.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosBulkActionsInvoicesBetaAccess",
            "baseName": "helios_bulk_actions_invoices.beta.access",
            "type": "boolean"
        },
        {
            "name": "autoBankImportAccess",
            "baseName": "auto_bank_import.access",
            "type": "boolean"
        },
        {
            "name": "heliosVirtualTerminalBetaAccess",
            "baseName": "helios_virtual_terminal.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosExpenseRebillingBetaAccess",
            "baseName": "helios_expense_rebilling.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosCompanyTaxesBetaAccess",
            "baseName": "helios_company_taxes.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosInvoiceArchiveBetaAccess",
            "baseName": "helios_invoice_archive.beta.access",
            "type": "boolean"
        },
        {
            "name": "accountantInviteAccess",
            "baseName": "accountant_invite.access",
            "type": "boolean"
        },
        {
            "name": "premiumContractorRoleAccess",
            "baseName": "premium_contractor_role.access",
            "type": "boolean"
        },
        {
            "name": "heliosSyncThrottleBetaAccess",
            "baseName": "helios_sync_throttle.beta.access",
            "type": "boolean"
        },
        {
            "name": "bankReconciliationAccess",
            "baseName": "BankReconciliation.access",
            "type": "boolean"
        },
        {
            "name": "heliosPushResourceToUseExecuteBetaAccess",
            "baseName": "helios_push_resource_to_use_execute.beta.access",
            "type": "boolean"
        },
        {
            "name": "newTimeTrackingAccess",
            "baseName": "new_time_tracking.access",
            "type": "boolean"
        },
        {
            "name": "bankRecSmartMatchAccess",
            "baseName": "bank_rec_smart_match.access",
            "type": "boolean"
        },
        {
            "name": "balanceSheetAccess",
            "baseName": "balance_sheet.access",
            "type": "boolean"
        },
        {
            "name": "invoiceV2SearchAccess",
            "baseName": "invoice_v2_search.access",
            "type": "boolean"
        },
        {
            "name": "importItemsCsvAccess",
            "baseName": "import_items_csv.access",
            "type": "boolean"
        },
        {
            "name": "exportClientsCsvAccess",
            "baseName": "export_clients_csv.access",
            "type": "boolean"
        },
        {
            "name": "heliosVirtualTerminalTutorialBetaAccess",
            "baseName": "helios_virtual_terminal_tutorial.beta.access",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return G2MB3M.attributeTypeMap;
    }
}

export class GatewayConnection {
    'stripe': Stripe;
    'fbpay': Fbpay;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "stripe",
            "baseName": "stripe",
            "type": "Stripe"
        },
        {
            "name": "fbpay",
            "baseName": "fbpay",
            "type": "Fbpay"
        }    ];

    static getAttributeTypeMap() {
        return GatewayConnection.attributeTypeMap;
    }
}

export class GatewayDetails {
    'gatewayConnections': Array<GatewayConnection>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "gatewayConnections",
            "baseName": "gateway_connections",
            "type": "Array<GatewayConnection>"
        }    ];

    static getAttributeTypeMap() {
        return GatewayDetails.attributeTypeMap;
    }
}

export class GeneralLedger {
    'response': Response77;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Response77"
        }    ];

    static getAttributeTypeMap() {
        return GeneralLedger.attributeTypeMap;
    }
}

export class GetSingleInvoiceProfile {
    'response': Response13;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Response13"
        }    ];

    static getAttributeTypeMap() {
        return GetSingleInvoiceProfile.attributeTypeMap;
    }
}

export class GetSingleTax {
    'response': Response85;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Response85"
        }    ];

    static getAttributeTypeMap() {
        return GetSingleTax.attributeTypeMap;
    }
}

export class GetSystem {
    'response': Response91;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Response91"
        }    ];

    static getAttributeTypeMap() {
        return GetSystem.attributeTypeMap;
    }
}

export class GetallretainersSuccess {
    'retainers': Array<Retainer>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "retainers",
            "baseName": "retainers",
            "type": "Array<Retainer>"
        }    ];

    static getAttributeTypeMap() {
        return GetallretainersSuccess.attributeTypeMap;
    }
}

export class Getdefaultinvoicepresentationstyles {
    'response': Response43;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Response43"
        }    ];

    static getAttributeTypeMap() {
        return Getdefaultinvoicepresentationstyles.attributeTypeMap;
    }
}

export class GetindividualRetainersuccess {
    'retainer': Retainer;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "retainer",
            "baseName": "retainer",
            "type": "Retainer"
        }    ];

    static getAttributeTypeMap() {
        return GetindividualRetainersuccess.attributeTypeMap;
    }
}

export class Gr1ndR {
    'attachmentsAccess': boolean;
    'clientLimit': number;
    'richProposalsAccess': boolean;
    'staffLimit': number;
    'advancedAccountingAccess': boolean;
    'businessAccountantLimit': number;
    'proposalsCandidateAccess': boolean;
    'betaMobileCreateExpenseSubcategoryAccess': boolean;
    'iosBetaZendeskWidgetAccess': boolean;
    'mobileReceiptRebillingAccess': boolean;
    'heliosPushnotificationsBetaAccess': boolean;
    'esignaturesAccess': boolean;
    'heliosBulkActionsInvoicesBetaAccess': boolean;
    'autoBankImportAccess': boolean;
    'heliosExpenseRebillingBetaAccess': boolean;
    'heliosCompanyTaxesBetaAccess': boolean;
    'heliosInvoiceArchiveBetaAccess': boolean;
    'heliosSyncThrottleBetaAccess': boolean;
    'heliosPushResourceToUseExecuteBetaAccess': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "attachmentsAccess",
            "baseName": "attachments.access",
            "type": "boolean"
        },
        {
            "name": "clientLimit",
            "baseName": "client.limit",
            "type": "number"
        },
        {
            "name": "richProposalsAccess",
            "baseName": "rich_proposals.access",
            "type": "boolean"
        },
        {
            "name": "staffLimit",
            "baseName": "staff.limit",
            "type": "number"
        },
        {
            "name": "advancedAccountingAccess",
            "baseName": "advanced_accounting.access",
            "type": "boolean"
        },
        {
            "name": "businessAccountantLimit",
            "baseName": "business_accountant.limit",
            "type": "number"
        },
        {
            "name": "proposalsCandidateAccess",
            "baseName": "proposals_candidate.access",
            "type": "boolean"
        },
        {
            "name": "betaMobileCreateExpenseSubcategoryAccess",
            "baseName": "beta_mobile_create_expense_subcategory.access",
            "type": "boolean"
        },
        {
            "name": "iosBetaZendeskWidgetAccess",
            "baseName": "ios_beta_zendesk_widget.access",
            "type": "boolean"
        },
        {
            "name": "mobileReceiptRebillingAccess",
            "baseName": "mobile_receipt_rebilling.access",
            "type": "boolean"
        },
        {
            "name": "heliosPushnotificationsBetaAccess",
            "baseName": "helios_pushnotifications.beta.access",
            "type": "boolean"
        },
        {
            "name": "esignaturesAccess",
            "baseName": "esignatures.access",
            "type": "boolean"
        },
        {
            "name": "heliosBulkActionsInvoicesBetaAccess",
            "baseName": "helios_bulk_actions_invoices.beta.access",
            "type": "boolean"
        },
        {
            "name": "autoBankImportAccess",
            "baseName": "auto_bank_import.access",
            "type": "boolean"
        },
        {
            "name": "heliosExpenseRebillingBetaAccess",
            "baseName": "helios_expense_rebilling.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosCompanyTaxesBetaAccess",
            "baseName": "helios_company_taxes.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosInvoiceArchiveBetaAccess",
            "baseName": "helios_invoice_archive.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosSyncThrottleBetaAccess",
            "baseName": "helios_sync_throttle.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosPushResourceToUseExecuteBetaAccess",
            "baseName": "helios_push_resource_to_use_execute.beta.access",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Gr1ndR.attributeTypeMap;
    }
}

export class Group {
    'id': number;
    'groupId': number;
    'role': string;
    'identityId': number;
    'businessId': number;
    'active': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "groupId",
            "baseName": "group_id",
            "type": "number"
        },
        {
            "name": "role",
            "baseName": "role",
            "type": "string"
        },
        {
            "name": "identityId",
            "baseName": "identity_id",
            "type": "number"
        },
        {
            "name": "businessId",
            "baseName": "business_id",
            "type": "number"
        },
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Group.attributeTypeMap;
    }
}

export class Group2 {
    'id': number;
    'members': Array<Member>;
    'pendingInvitations': Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "members",
            "baseName": "members",
            "type": "Array<Member>"
        },
        {
            "name": "pendingInvitations",
            "baseName": "pending_invitations",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return Group2.attributeTypeMap;
    }
}

export class Group3 {
    'id': number;
    'members': Array<Member>;
    'pendingInvitations': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "members",
            "baseName": "members",
            "type": "Array<Member>"
        },
        {
            "name": "pendingInvitations",
            "baseName": "pending_invitations",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Group3.attributeTypeMap;
    }
}

export class GstAmount {
    'amount': string;
    'code': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "string"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GstAmount.attributeTypeMap;
    }
}

export class IdentityInfoCall {
    'response': Response;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Response"
        }    ];

    static getAttributeTypeMap() {
        return IdentityInfoCall.attributeTypeMap;
    }
}

export class Image {
    'jwt': string;
    'publicId': string;
    'filename': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "jwt",
            "baseName": "jwt",
            "type": "string"
        },
        {
            "name": "publicId",
            "baseName": "public_id",
            "type": "string"
        },
        {
            "name": "filename",
            "baseName": "filename",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Image.attributeTypeMap;
    }
}

export class Income {
    'children': Array<string>;
    'data': Array<string>;
    'description': string;
    'entryType': string;
    'total': Total;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "children",
            "baseName": "children",
            "type": "Array<string>"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<string>"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "entryType",
            "baseName": "entry_type",
            "type": "string"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "Total"
        }    ];

    static getAttributeTypeMap() {
        return Income.attributeTypeMap;
    }
}

export class InvitationRates {
    'invitationRates': Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "invitationRates",
            "baseName": "invitation_rates",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return InvitationRates.attributeTypeMap;
    }
}

export class Invoice {
    'accountid': string;
    'accountingSystemid': string;
    'address': string;
    'amount': Amount;
    'autoBill': boolean;
    'autobillStatus': string;
    'basecampid': number;
    'city': string;
    'code': string;
    'country': string;
    'createDate': string;
    'createdAt': string;
    'currencyCode': string;
    'currentOrganization': string;
    'customerid': number;
    'datePaid': string;
    'depositAmount': string;
    'depositPercentage': string;
    'depositStatus': string;
    'description': string;
    'discountDescription': string;
    'discountTotal': DiscountTotal;
    'discountValue': string;
    'displayStatus': string;
    'disputeStatus': string;
    'dueDate': string;
    'dueOffsetDays': number;
    'estimateid': number;
    'extArchive': number;
    'fname': string;
    'fulfillmentDate': string;
    'generationDate': string;
    'gmail': boolean;
    'id': number;
    'invoiceNumber': string;
    'invoiceid': number;
    'language': string;
    'lastOrderStatus': string;
    'lname': string;
    'notes': string;
    'organization': string;
    'outstanding': Outstanding;
    'ownerid': number;
    'paid': Paid;
    'parent': number;
    'paymentDetails': string;
    'paymentStatus': string;
    'poNumber': string;
    'province': string;
    'returnUri': string;
    'sentid': number;
    'showAttachments': boolean;
    'status': number;
    'street': string;
    'street2': string;
    'template': string;
    'terms': string;
    'updated': string;
    'v3Status': string;
    'vatName': string;
    'vatNumber': string;
    'visState': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountid",
            "baseName": "accountid",
            "type": "string"
        },
        {
            "name": "accountingSystemid",
            "baseName": "accounting_systemid",
            "type": "string"
        },
        {
            "name": "address",
            "baseName": "address",
            "type": "string"
        },
        {
            "name": "amount",
            "baseName": "amount",
            "type": "Amount"
        },
        {
            "name": "autoBill",
            "baseName": "auto_bill",
            "type": "boolean"
        },
        {
            "name": "autobillStatus",
            "baseName": "autobill_status",
            "type": "string"
        },
        {
            "name": "basecampid",
            "baseName": "basecampid",
            "type": "number"
        },
        {
            "name": "city",
            "baseName": "city",
            "type": "string"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "createDate",
            "baseName": "create_date",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "currencyCode",
            "baseName": "currency_code",
            "type": "string"
        },
        {
            "name": "currentOrganization",
            "baseName": "current_organization",
            "type": "string"
        },
        {
            "name": "customerid",
            "baseName": "customerid",
            "type": "number"
        },
        {
            "name": "datePaid",
            "baseName": "date_paid",
            "type": "string"
        },
        {
            "name": "depositAmount",
            "baseName": "deposit_amount",
            "type": "string"
        },
        {
            "name": "depositPercentage",
            "baseName": "deposit_percentage",
            "type": "string"
        },
        {
            "name": "depositStatus",
            "baseName": "deposit_status",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "discountDescription",
            "baseName": "discount_description",
            "type": "string"
        },
        {
            "name": "discountTotal",
            "baseName": "discount_total",
            "type": "DiscountTotal"
        },
        {
            "name": "discountValue",
            "baseName": "discount_value",
            "type": "string"
        },
        {
            "name": "displayStatus",
            "baseName": "display_status",
            "type": "string"
        },
        {
            "name": "disputeStatus",
            "baseName": "dispute_status",
            "type": "string"
        },
        {
            "name": "dueDate",
            "baseName": "due_date",
            "type": "string"
        },
        {
            "name": "dueOffsetDays",
            "baseName": "due_offset_days",
            "type": "number"
        },
        {
            "name": "estimateid",
            "baseName": "estimateid",
            "type": "number"
        },
        {
            "name": "extArchive",
            "baseName": "ext_archive",
            "type": "number"
        },
        {
            "name": "fname",
            "baseName": "fname",
            "type": "string"
        },
        {
            "name": "fulfillmentDate",
            "baseName": "fulfillment_date",
            "type": "string"
        },
        {
            "name": "generationDate",
            "baseName": "generation_date",
            "type": "string"
        },
        {
            "name": "gmail",
            "baseName": "gmail",
            "type": "boolean"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "invoiceNumber",
            "baseName": "invoice_number",
            "type": "string"
        },
        {
            "name": "invoiceid",
            "baseName": "invoiceid",
            "type": "number"
        },
        {
            "name": "language",
            "baseName": "language",
            "type": "string"
        },
        {
            "name": "lastOrderStatus",
            "baseName": "last_order_status",
            "type": "string"
        },
        {
            "name": "lname",
            "baseName": "lname",
            "type": "string"
        },
        {
            "name": "notes",
            "baseName": "notes",
            "type": "string"
        },
        {
            "name": "organization",
            "baseName": "organization",
            "type": "string"
        },
        {
            "name": "outstanding",
            "baseName": "outstanding",
            "type": "Outstanding"
        },
        {
            "name": "ownerid",
            "baseName": "ownerid",
            "type": "number"
        },
        {
            "name": "paid",
            "baseName": "paid",
            "type": "Paid"
        },
        {
            "name": "parent",
            "baseName": "parent",
            "type": "number"
        },
        {
            "name": "paymentDetails",
            "baseName": "payment_details",
            "type": "string"
        },
        {
            "name": "paymentStatus",
            "baseName": "payment_status",
            "type": "string"
        },
        {
            "name": "poNumber",
            "baseName": "po_number",
            "type": "string"
        },
        {
            "name": "province",
            "baseName": "province",
            "type": "string"
        },
        {
            "name": "returnUri",
            "baseName": "return_uri",
            "type": "string"
        },
        {
            "name": "sentid",
            "baseName": "sentid",
            "type": "number"
        },
        {
            "name": "showAttachments",
            "baseName": "show_attachments",
            "type": "boolean"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "number"
        },
        {
            "name": "street",
            "baseName": "street",
            "type": "string"
        },
        {
            "name": "street2",
            "baseName": "street2",
            "type": "string"
        },
        {
            "name": "template",
            "baseName": "template",
            "type": "string"
        },
        {
            "name": "terms",
            "baseName": "terms",
            "type": "string"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "string"
        },
        {
            "name": "v3Status",
            "baseName": "v3_status",
            "type": "string"
        },
        {
            "name": "vatName",
            "baseName": "vat_name",
            "type": "string"
        },
        {
            "name": "vatNumber",
            "baseName": "vat_number",
            "type": "string"
        },
        {
            "name": "visState",
            "baseName": "vis_state",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Invoice.attributeTypeMap;
    }
}

export class Invoice1 {
    'accountid': string;
    'accountingSystemid': string;
    'address': string;
    'amount': Amount;
    'autoBill': boolean;
    'autobillStatus': string;
    'basecampid': number;
    'city': string;
    'code': string;
    'country': string;
    'createDate': string;
    'createdAt': string;
    'currencyCode': string;
    'currentOrganization': string;
    'customerid': number;
    'datePaid': string;
    'depositAmount': string;
    'depositPercentage': string;
    'depositStatus': string;
    'description': string;
    'discountDescription': string;
    'discountTotal': DiscountTotal;
    'discountValue': string;
    'displayStatus': string;
    'disputeStatus': string;
    'dueDate': string;
    'dueOffsetDays': number;
    'estimateid': number;
    'extArchive': number;
    'fname': string;
    'fulfillmentDate': string;
    'generationDate': string;
    'gmail': boolean;
    'id': number;
    'invoiceNumber': string;
    'invoiceid': number;
    'language': string;
    'lastOrderStatus': string;
    'lname': string;
    'notes': string;
    'organization': string;
    'outstanding': Outstanding;
    'ownerid': number;
    'paid': Paid;
    'parent': number;
    'paymentDetails': string;
    'paymentStatus': string;
    'poNumber': string;
    'province': string;
    'returnUri': string;
    'sentid': number;
    'showAttachments': boolean;
    'status': number;
    'street': string;
    'street2': string;
    'template': string;
    'terms': string;
    'updated': string;
    'v3Status': string;
    'vatName': string;
    'vatNumber': string;
    'visState': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountid",
            "baseName": "accountid",
            "type": "string"
        },
        {
            "name": "accountingSystemid",
            "baseName": "accounting_systemid",
            "type": "string"
        },
        {
            "name": "address",
            "baseName": "address",
            "type": "string"
        },
        {
            "name": "amount",
            "baseName": "amount",
            "type": "Amount"
        },
        {
            "name": "autoBill",
            "baseName": "auto_bill",
            "type": "boolean"
        },
        {
            "name": "autobillStatus",
            "baseName": "autobill_status",
            "type": "string"
        },
        {
            "name": "basecampid",
            "baseName": "basecampid",
            "type": "number"
        },
        {
            "name": "city",
            "baseName": "city",
            "type": "string"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "createDate",
            "baseName": "create_date",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "currencyCode",
            "baseName": "currency_code",
            "type": "string"
        },
        {
            "name": "currentOrganization",
            "baseName": "current_organization",
            "type": "string"
        },
        {
            "name": "customerid",
            "baseName": "customerid",
            "type": "number"
        },
        {
            "name": "datePaid",
            "baseName": "date_paid",
            "type": "string"
        },
        {
            "name": "depositAmount",
            "baseName": "deposit_amount",
            "type": "string"
        },
        {
            "name": "depositPercentage",
            "baseName": "deposit_percentage",
            "type": "string"
        },
        {
            "name": "depositStatus",
            "baseName": "deposit_status",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "discountDescription",
            "baseName": "discount_description",
            "type": "string"
        },
        {
            "name": "discountTotal",
            "baseName": "discount_total",
            "type": "DiscountTotal"
        },
        {
            "name": "discountValue",
            "baseName": "discount_value",
            "type": "string"
        },
        {
            "name": "displayStatus",
            "baseName": "display_status",
            "type": "string"
        },
        {
            "name": "disputeStatus",
            "baseName": "dispute_status",
            "type": "string"
        },
        {
            "name": "dueDate",
            "baseName": "due_date",
            "type": "string"
        },
        {
            "name": "dueOffsetDays",
            "baseName": "due_offset_days",
            "type": "number"
        },
        {
            "name": "estimateid",
            "baseName": "estimateid",
            "type": "number"
        },
        {
            "name": "extArchive",
            "baseName": "ext_archive",
            "type": "number"
        },
        {
            "name": "fname",
            "baseName": "fname",
            "type": "string"
        },
        {
            "name": "fulfillmentDate",
            "baseName": "fulfillment_date",
            "type": "string"
        },
        {
            "name": "generationDate",
            "baseName": "generation_date",
            "type": "string"
        },
        {
            "name": "gmail",
            "baseName": "gmail",
            "type": "boolean"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "invoiceNumber",
            "baseName": "invoice_number",
            "type": "string"
        },
        {
            "name": "invoiceid",
            "baseName": "invoiceid",
            "type": "number"
        },
        {
            "name": "language",
            "baseName": "language",
            "type": "string"
        },
        {
            "name": "lastOrderStatus",
            "baseName": "last_order_status",
            "type": "string"
        },
        {
            "name": "lname",
            "baseName": "lname",
            "type": "string"
        },
        {
            "name": "notes",
            "baseName": "notes",
            "type": "string"
        },
        {
            "name": "organization",
            "baseName": "organization",
            "type": "string"
        },
        {
            "name": "outstanding",
            "baseName": "outstanding",
            "type": "Outstanding"
        },
        {
            "name": "ownerid",
            "baseName": "ownerid",
            "type": "number"
        },
        {
            "name": "paid",
            "baseName": "paid",
            "type": "Paid"
        },
        {
            "name": "parent",
            "baseName": "parent",
            "type": "number"
        },
        {
            "name": "paymentDetails",
            "baseName": "payment_details",
            "type": "string"
        },
        {
            "name": "paymentStatus",
            "baseName": "payment_status",
            "type": "string"
        },
        {
            "name": "poNumber",
            "baseName": "po_number",
            "type": "string"
        },
        {
            "name": "province",
            "baseName": "province",
            "type": "string"
        },
        {
            "name": "returnUri",
            "baseName": "return_uri",
            "type": "string"
        },
        {
            "name": "sentid",
            "baseName": "sentid",
            "type": "number"
        },
        {
            "name": "showAttachments",
            "baseName": "show_attachments",
            "type": "boolean"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "number"
        },
        {
            "name": "street",
            "baseName": "street",
            "type": "string"
        },
        {
            "name": "street2",
            "baseName": "street2",
            "type": "string"
        },
        {
            "name": "template",
            "baseName": "template",
            "type": "string"
        },
        {
            "name": "terms",
            "baseName": "terms",
            "type": "string"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "string"
        },
        {
            "name": "v3Status",
            "baseName": "v3_status",
            "type": "string"
        },
        {
            "name": "vatName",
            "baseName": "vat_name",
            "type": "string"
        },
        {
            "name": "vatNumber",
            "baseName": "vat_number",
            "type": "string"
        },
        {
            "name": "visState",
            "baseName": "vis_state",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Invoice1.attributeTypeMap;
    }
}

export class Invoice11 {
    'allowedGatewayids': Array<number>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "allowedGatewayids",
            "baseName": "allowed_gatewayids",
            "type": "Array<number>"
        }    ];

    static getAttributeTypeMap() {
        return Invoice11.attributeTypeMap;
    }
}

export class Invoice12 {
    'accountid': string;
    'accountingSystemid': string;
    'address': string;
    'allowedGateways': Array<AllowedGateway>;
    'amount': Amount;
    'autoBill': boolean;
    'autobillStatus': string;
    'basecampid': number;
    'city': string;
    'code': string;
    'country': string;
    'createDate': string;
    'createdAt': string;
    'currencyCode': string;
    'currentOrganization': string;
    'customerid': number;
    'datePaid': string;
    'depositAmount': string;
    'depositPercentage': string;
    'depositStatus': string;
    'description': string;
    'discountDescription': string;
    'discountTotal': DiscountTotal;
    'discountValue': string;
    'displayStatus': string;
    'disputeStatus': string;
    'dueDate': string;
    'dueOffsetDays': number;
    'estimateid': number;
    'extArchive': number;
    'fname': string;
    'fulfillmentDate': string;
    'generationDate': string;
    'gmail': boolean;
    'id': number;
    'invoiceNumber': string;
    'invoiceid': number;
    'language': string;
    'lastOrderStatus': string;
    'lname': string;
    'notes': string;
    'organization': string;
    'outstanding': Outstanding;
    'ownerid': number;
    'paid': Paid;
    'parent': number;
    'paymentDetails': string;
    'paymentStatus': string;
    'poNumber': string;
    'province': string;
    'returnUri': string;
    'sentid': number;
    'showAttachments': boolean;
    'status': number;
    'street': string;
    'street2': string;
    'template': string;
    'terms': string;
    'updated': string;
    'v3Status': string;
    'vatName': string;
    'vatNumber': string;
    'visState': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountid",
            "baseName": "accountid",
            "type": "string"
        },
        {
            "name": "accountingSystemid",
            "baseName": "accounting_systemid",
            "type": "string"
        },
        {
            "name": "address",
            "baseName": "address",
            "type": "string"
        },
        {
            "name": "allowedGateways",
            "baseName": "allowed_gateways",
            "type": "Array<AllowedGateway>"
        },
        {
            "name": "amount",
            "baseName": "amount",
            "type": "Amount"
        },
        {
            "name": "autoBill",
            "baseName": "auto_bill",
            "type": "boolean"
        },
        {
            "name": "autobillStatus",
            "baseName": "autobill_status",
            "type": "string"
        },
        {
            "name": "basecampid",
            "baseName": "basecampid",
            "type": "number"
        },
        {
            "name": "city",
            "baseName": "city",
            "type": "string"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "createDate",
            "baseName": "create_date",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "currencyCode",
            "baseName": "currency_code",
            "type": "string"
        },
        {
            "name": "currentOrganization",
            "baseName": "current_organization",
            "type": "string"
        },
        {
            "name": "customerid",
            "baseName": "customerid",
            "type": "number"
        },
        {
            "name": "datePaid",
            "baseName": "date_paid",
            "type": "string"
        },
        {
            "name": "depositAmount",
            "baseName": "deposit_amount",
            "type": "string"
        },
        {
            "name": "depositPercentage",
            "baseName": "deposit_percentage",
            "type": "string"
        },
        {
            "name": "depositStatus",
            "baseName": "deposit_status",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "discountDescription",
            "baseName": "discount_description",
            "type": "string"
        },
        {
            "name": "discountTotal",
            "baseName": "discount_total",
            "type": "DiscountTotal"
        },
        {
            "name": "discountValue",
            "baseName": "discount_value",
            "type": "string"
        },
        {
            "name": "displayStatus",
            "baseName": "display_status",
            "type": "string"
        },
        {
            "name": "disputeStatus",
            "baseName": "dispute_status",
            "type": "string"
        },
        {
            "name": "dueDate",
            "baseName": "due_date",
            "type": "string"
        },
        {
            "name": "dueOffsetDays",
            "baseName": "due_offset_days",
            "type": "number"
        },
        {
            "name": "estimateid",
            "baseName": "estimateid",
            "type": "number"
        },
        {
            "name": "extArchive",
            "baseName": "ext_archive",
            "type": "number"
        },
        {
            "name": "fname",
            "baseName": "fname",
            "type": "string"
        },
        {
            "name": "fulfillmentDate",
            "baseName": "fulfillment_date",
            "type": "string"
        },
        {
            "name": "generationDate",
            "baseName": "generation_date",
            "type": "string"
        },
        {
            "name": "gmail",
            "baseName": "gmail",
            "type": "boolean"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "invoiceNumber",
            "baseName": "invoice_number",
            "type": "string"
        },
        {
            "name": "invoiceid",
            "baseName": "invoiceid",
            "type": "number"
        },
        {
            "name": "language",
            "baseName": "language",
            "type": "string"
        },
        {
            "name": "lastOrderStatus",
            "baseName": "last_order_status",
            "type": "string"
        },
        {
            "name": "lname",
            "baseName": "lname",
            "type": "string"
        },
        {
            "name": "notes",
            "baseName": "notes",
            "type": "string"
        },
        {
            "name": "organization",
            "baseName": "organization",
            "type": "string"
        },
        {
            "name": "outstanding",
            "baseName": "outstanding",
            "type": "Outstanding"
        },
        {
            "name": "ownerid",
            "baseName": "ownerid",
            "type": "number"
        },
        {
            "name": "paid",
            "baseName": "paid",
            "type": "Paid"
        },
        {
            "name": "parent",
            "baseName": "parent",
            "type": "number"
        },
        {
            "name": "paymentDetails",
            "baseName": "payment_details",
            "type": "string"
        },
        {
            "name": "paymentStatus",
            "baseName": "payment_status",
            "type": "string"
        },
        {
            "name": "poNumber",
            "baseName": "po_number",
            "type": "string"
        },
        {
            "name": "province",
            "baseName": "province",
            "type": "string"
        },
        {
            "name": "returnUri",
            "baseName": "return_uri",
            "type": "string"
        },
        {
            "name": "sentid",
            "baseName": "sentid",
            "type": "number"
        },
        {
            "name": "showAttachments",
            "baseName": "show_attachments",
            "type": "boolean"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "number"
        },
        {
            "name": "street",
            "baseName": "street",
            "type": "string"
        },
        {
            "name": "street2",
            "baseName": "street2",
            "type": "string"
        },
        {
            "name": "template",
            "baseName": "template",
            "type": "string"
        },
        {
            "name": "terms",
            "baseName": "terms",
            "type": "string"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "string"
        },
        {
            "name": "v3Status",
            "baseName": "v3_status",
            "type": "string"
        },
        {
            "name": "vatName",
            "baseName": "vat_name",
            "type": "string"
        },
        {
            "name": "vatNumber",
            "baseName": "vat_number",
            "type": "string"
        },
        {
            "name": "visState",
            "baseName": "vis_state",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Invoice12.attributeTypeMap;
    }
}

export class Invoice13 {
    'amount': Amount;
    'createDate': string;
    'discount': Discount;
    'fname': string;
    'invoiceNumber': string;
    'invoiceid': number;
    'lname': string;
    'organization': string;
    'qty': string;
    'unitCost': UnitCost;
    'v3Status': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "Amount"
        },
        {
            "name": "createDate",
            "baseName": "create_date",
            "type": "string"
        },
        {
            "name": "discount",
            "baseName": "discount",
            "type": "Discount"
        },
        {
            "name": "fname",
            "baseName": "fname",
            "type": "string"
        },
        {
            "name": "invoiceNumber",
            "baseName": "invoice_number",
            "type": "string"
        },
        {
            "name": "invoiceid",
            "baseName": "invoiceid",
            "type": "number"
        },
        {
            "name": "lname",
            "baseName": "lname",
            "type": "string"
        },
        {
            "name": "organization",
            "baseName": "organization",
            "type": "string"
        },
        {
            "name": "qty",
            "baseName": "qty",
            "type": "string"
        },
        {
            "name": "unitCost",
            "baseName": "unit_cost",
            "type": "UnitCost"
        },
        {
            "name": "v3Status",
            "baseName": "v3_status",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Invoice13.attributeTypeMap;
    }
}

export class Invoice2 {
    'accountid': string;
    'accountingSystemid': string;
    'address': string;
    'amount': Amount;
    'autoBill': boolean;
    'autobillStatus': string;
    'basecampid': number;
    'city': string;
    'code': string;
    'country': string;
    'createDate': string;
    'createdAt': string;
    'currencyCode': string;
    'currentOrganization': string;
    'customerid': number;
    'datePaid': string;
    'depositAmount': string;
    'depositPercentage': string;
    'depositStatus': string;
    'description': string;
    'discountDescription': string;
    'discountTotal': DiscountTotal;
    'discountValue': string;
    'displayStatus': string;
    'disputeStatus': string;
    'dueDate': string;
    'dueOffsetDays': number;
    'estimateid': number;
    'extArchive': number;
    'fname': string;
    'fulfillmentDate': string;
    'generationDate': string;
    'gmail': boolean;
    'id': number;
    'invoiceNumber': string;
    'invoiceid': number;
    'language': string;
    'lastOrderStatus': string;
    'lname': string;
    'notes': string;
    'organization': string;
    'outstanding': Outstanding;
    'ownerid': number;
    'paid': Paid;
    'parent': number;
    'paymentDetails': string;
    'paymentStatus': string;
    'poNumber': string;
    'presentation': Presentation;
    'province': string;
    'returnUri': string;
    'sentid': number;
    'showAttachments': boolean;
    'status': number;
    'street': string;
    'street2': string;
    'template': string;
    'terms': string;
    'updated': string;
    'v3Status': string;
    'vatName': string;
    'vatNumber': string;
    'visState': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountid",
            "baseName": "accountid",
            "type": "string"
        },
        {
            "name": "accountingSystemid",
            "baseName": "accounting_systemid",
            "type": "string"
        },
        {
            "name": "address",
            "baseName": "address",
            "type": "string"
        },
        {
            "name": "amount",
            "baseName": "amount",
            "type": "Amount"
        },
        {
            "name": "autoBill",
            "baseName": "auto_bill",
            "type": "boolean"
        },
        {
            "name": "autobillStatus",
            "baseName": "autobill_status",
            "type": "string"
        },
        {
            "name": "basecampid",
            "baseName": "basecampid",
            "type": "number"
        },
        {
            "name": "city",
            "baseName": "city",
            "type": "string"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "createDate",
            "baseName": "create_date",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "currencyCode",
            "baseName": "currency_code",
            "type": "string"
        },
        {
            "name": "currentOrganization",
            "baseName": "current_organization",
            "type": "string"
        },
        {
            "name": "customerid",
            "baseName": "customerid",
            "type": "number"
        },
        {
            "name": "datePaid",
            "baseName": "date_paid",
            "type": "string"
        },
        {
            "name": "depositAmount",
            "baseName": "deposit_amount",
            "type": "string"
        },
        {
            "name": "depositPercentage",
            "baseName": "deposit_percentage",
            "type": "string"
        },
        {
            "name": "depositStatus",
            "baseName": "deposit_status",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "discountDescription",
            "baseName": "discount_description",
            "type": "string"
        },
        {
            "name": "discountTotal",
            "baseName": "discount_total",
            "type": "DiscountTotal"
        },
        {
            "name": "discountValue",
            "baseName": "discount_value",
            "type": "string"
        },
        {
            "name": "displayStatus",
            "baseName": "display_status",
            "type": "string"
        },
        {
            "name": "disputeStatus",
            "baseName": "dispute_status",
            "type": "string"
        },
        {
            "name": "dueDate",
            "baseName": "due_date",
            "type": "string"
        },
        {
            "name": "dueOffsetDays",
            "baseName": "due_offset_days",
            "type": "number"
        },
        {
            "name": "estimateid",
            "baseName": "estimateid",
            "type": "number"
        },
        {
            "name": "extArchive",
            "baseName": "ext_archive",
            "type": "number"
        },
        {
            "name": "fname",
            "baseName": "fname",
            "type": "string"
        },
        {
            "name": "fulfillmentDate",
            "baseName": "fulfillment_date",
            "type": "string"
        },
        {
            "name": "generationDate",
            "baseName": "generation_date",
            "type": "string"
        },
        {
            "name": "gmail",
            "baseName": "gmail",
            "type": "boolean"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "invoiceNumber",
            "baseName": "invoice_number",
            "type": "string"
        },
        {
            "name": "invoiceid",
            "baseName": "invoiceid",
            "type": "number"
        },
        {
            "name": "language",
            "baseName": "language",
            "type": "string"
        },
        {
            "name": "lastOrderStatus",
            "baseName": "last_order_status",
            "type": "string"
        },
        {
            "name": "lname",
            "baseName": "lname",
            "type": "string"
        },
        {
            "name": "notes",
            "baseName": "notes",
            "type": "string"
        },
        {
            "name": "organization",
            "baseName": "organization",
            "type": "string"
        },
        {
            "name": "outstanding",
            "baseName": "outstanding",
            "type": "Outstanding"
        },
        {
            "name": "ownerid",
            "baseName": "ownerid",
            "type": "number"
        },
        {
            "name": "paid",
            "baseName": "paid",
            "type": "Paid"
        },
        {
            "name": "parent",
            "baseName": "parent",
            "type": "number"
        },
        {
            "name": "paymentDetails",
            "baseName": "payment_details",
            "type": "string"
        },
        {
            "name": "paymentStatus",
            "baseName": "payment_status",
            "type": "string"
        },
        {
            "name": "poNumber",
            "baseName": "po_number",
            "type": "string"
        },
        {
            "name": "presentation",
            "baseName": "presentation",
            "type": "Presentation"
        },
        {
            "name": "province",
            "baseName": "province",
            "type": "string"
        },
        {
            "name": "returnUri",
            "baseName": "return_uri",
            "type": "string"
        },
        {
            "name": "sentid",
            "baseName": "sentid",
            "type": "number"
        },
        {
            "name": "showAttachments",
            "baseName": "show_attachments",
            "type": "boolean"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "number"
        },
        {
            "name": "street",
            "baseName": "street",
            "type": "string"
        },
        {
            "name": "street2",
            "baseName": "street2",
            "type": "string"
        },
        {
            "name": "template",
            "baseName": "template",
            "type": "string"
        },
        {
            "name": "terms",
            "baseName": "terms",
            "type": "string"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "string"
        },
        {
            "name": "v3Status",
            "baseName": "v3_status",
            "type": "string"
        },
        {
            "name": "vatName",
            "baseName": "vat_name",
            "type": "string"
        },
        {
            "name": "vatNumber",
            "baseName": "vat_number",
            "type": "string"
        },
        {
            "name": "visState",
            "baseName": "vis_state",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Invoice2.attributeTypeMap;
    }
}

export class Invoice3 {
    'accountid': string;
    'accountingSystemid': string;
    'address': string;
    'amount': Amount;
    'autoBill': boolean;
    'autobillStatus': string;
    'basecampid': number;
    'city': string;
    'code': string;
    'country': string;
    'createDate': string;
    'createdAt': string;
    'currencyCode': string;
    'currentOrganization': string;
    'customerid': number;
    'datePaid': string;
    'depositAmount': string;
    'depositPercentage': string;
    'depositStatus': string;
    'description': string;
    'discountDescription': string;
    'discountTotal': DiscountTotal;
    'discountValue': string;
    'displayStatus': string;
    'disputeStatus': string;
    'dueDate': string;
    'dueOffsetDays': number;
    'estimateid': number;
    'extArchive': number;
    'fname': string;
    'fulfillmentDate': string;
    'generationDate': string;
    'gmail': boolean;
    'id': number;
    'invoiceNumber': string;
    'invoiceid': number;
    'language': string;
    'lastOrderStatus': string;
    'lname': string;
    'notes': string;
    'organization': string;
    'outstanding': Outstanding;
    'ownerid': number;
    'paid': Paid;
    'parent': number;
    'paymentDetails': string;
    'paymentStatus': string;
    'poNumber': string;
    'province': string;
    'returnUri': string;
    'sentid': number;
    'showAttachments': boolean;
    'status': number;
    'street': string;
    'street2': string;
    'template': string;
    'terms': string;
    'updated': string;
    'v3Status': string;
    'vatName': string;
    'vatNumber': string;
    'visState': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountid",
            "baseName": "accountid",
            "type": "string"
        },
        {
            "name": "accountingSystemid",
            "baseName": "accounting_systemid",
            "type": "string"
        },
        {
            "name": "address",
            "baseName": "address",
            "type": "string"
        },
        {
            "name": "amount",
            "baseName": "amount",
            "type": "Amount"
        },
        {
            "name": "autoBill",
            "baseName": "auto_bill",
            "type": "boolean"
        },
        {
            "name": "autobillStatus",
            "baseName": "autobill_status",
            "type": "string"
        },
        {
            "name": "basecampid",
            "baseName": "basecampid",
            "type": "number"
        },
        {
            "name": "city",
            "baseName": "city",
            "type": "string"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "createDate",
            "baseName": "create_date",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "currencyCode",
            "baseName": "currency_code",
            "type": "string"
        },
        {
            "name": "currentOrganization",
            "baseName": "current_organization",
            "type": "string"
        },
        {
            "name": "customerid",
            "baseName": "customerid",
            "type": "number"
        },
        {
            "name": "datePaid",
            "baseName": "date_paid",
            "type": "string"
        },
        {
            "name": "depositAmount",
            "baseName": "deposit_amount",
            "type": "string"
        },
        {
            "name": "depositPercentage",
            "baseName": "deposit_percentage",
            "type": "string"
        },
        {
            "name": "depositStatus",
            "baseName": "deposit_status",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "discountDescription",
            "baseName": "discount_description",
            "type": "string"
        },
        {
            "name": "discountTotal",
            "baseName": "discount_total",
            "type": "DiscountTotal"
        },
        {
            "name": "discountValue",
            "baseName": "discount_value",
            "type": "string"
        },
        {
            "name": "displayStatus",
            "baseName": "display_status",
            "type": "string"
        },
        {
            "name": "disputeStatus",
            "baseName": "dispute_status",
            "type": "string"
        },
        {
            "name": "dueDate",
            "baseName": "due_date",
            "type": "string"
        },
        {
            "name": "dueOffsetDays",
            "baseName": "due_offset_days",
            "type": "number"
        },
        {
            "name": "estimateid",
            "baseName": "estimateid",
            "type": "number"
        },
        {
            "name": "extArchive",
            "baseName": "ext_archive",
            "type": "number"
        },
        {
            "name": "fname",
            "baseName": "fname",
            "type": "string"
        },
        {
            "name": "fulfillmentDate",
            "baseName": "fulfillment_date",
            "type": "string"
        },
        {
            "name": "generationDate",
            "baseName": "generation_date",
            "type": "string"
        },
        {
            "name": "gmail",
            "baseName": "gmail",
            "type": "boolean"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "invoiceNumber",
            "baseName": "invoice_number",
            "type": "string"
        },
        {
            "name": "invoiceid",
            "baseName": "invoiceid",
            "type": "number"
        },
        {
            "name": "language",
            "baseName": "language",
            "type": "string"
        },
        {
            "name": "lastOrderStatus",
            "baseName": "last_order_status",
            "type": "string"
        },
        {
            "name": "lname",
            "baseName": "lname",
            "type": "string"
        },
        {
            "name": "notes",
            "baseName": "notes",
            "type": "string"
        },
        {
            "name": "organization",
            "baseName": "organization",
            "type": "string"
        },
        {
            "name": "outstanding",
            "baseName": "outstanding",
            "type": "Outstanding"
        },
        {
            "name": "ownerid",
            "baseName": "ownerid",
            "type": "number"
        },
        {
            "name": "paid",
            "baseName": "paid",
            "type": "Paid"
        },
        {
            "name": "parent",
            "baseName": "parent",
            "type": "number"
        },
        {
            "name": "paymentDetails",
            "baseName": "payment_details",
            "type": "string"
        },
        {
            "name": "paymentStatus",
            "baseName": "payment_status",
            "type": "string"
        },
        {
            "name": "poNumber",
            "baseName": "po_number",
            "type": "string"
        },
        {
            "name": "province",
            "baseName": "province",
            "type": "string"
        },
        {
            "name": "returnUri",
            "baseName": "return_uri",
            "type": "string"
        },
        {
            "name": "sentid",
            "baseName": "sentid",
            "type": "number"
        },
        {
            "name": "showAttachments",
            "baseName": "show_attachments",
            "type": "boolean"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "number"
        },
        {
            "name": "street",
            "baseName": "street",
            "type": "string"
        },
        {
            "name": "street2",
            "baseName": "street2",
            "type": "string"
        },
        {
            "name": "template",
            "baseName": "template",
            "type": "string"
        },
        {
            "name": "terms",
            "baseName": "terms",
            "type": "string"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "string"
        },
        {
            "name": "v3Status",
            "baseName": "v3_status",
            "type": "string"
        },
        {
            "name": "vatName",
            "baseName": "vat_name",
            "type": "string"
        },
        {
            "name": "vatNumber",
            "baseName": "vat_number",
            "type": "string"
        },
        {
            "name": "visState",
            "baseName": "vis_state",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Invoice3.attributeTypeMap;
    }
}

export class Invoice4 {
    'accountid': string;
    'accountingSystemid': string;
    'address': string;
    'allowedGateways': Array<string>;
    'amount': Amount;
    'autoBill': boolean;
    'autobillStatus': string;
    'basecampid': number;
    'city': string;
    'code': string;
    'country': string;
    'createDate': string;
    'createdAt': string;
    'currencyCode': string;
    'currentOrganization': string;
    'customerid': number;
    'datePaid': string;
    'depositAmount': string;
    'depositPercentage': string;
    'depositStatus': string;
    'description': string;
    'discountDescription': string;
    'discountTotal': DiscountTotal;
    'discountValue': string;
    'displayStatus': string;
    'disputeStatus': string;
    'dueDate': string;
    'dueOffsetDays': number;
    'estimateid': number;
    'extArchive': number;
    'fname': string;
    'fulfillmentDate': string;
    'generationDate': string;
    'gmail': boolean;
    'id': number;
    'invoiceNumber': string;
    'invoiceid': number;
    'language': string;
    'lastOrderStatus': string;
    'lname': string;
    'notes': string;
    'organization': string;
    'outstanding': Outstanding;
    'ownerid': number;
    'paid': Paid;
    'parent': number;
    'paymentDetails': string;
    'paymentStatus': string;
    'poNumber': string;
    'province': string;
    'returnUri': string;
    'sentid': number;
    'showAttachments': boolean;
    'status': number;
    'street': string;
    'street2': string;
    'template': string;
    'terms': string;
    'updated': string;
    'v3Status': string;
    'vatName': string;
    'vatNumber': string;
    'visState': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountid",
            "baseName": "accountid",
            "type": "string"
        },
        {
            "name": "accountingSystemid",
            "baseName": "accounting_systemid",
            "type": "string"
        },
        {
            "name": "address",
            "baseName": "address",
            "type": "string"
        },
        {
            "name": "allowedGateways",
            "baseName": "allowed_gateways",
            "type": "Array<string>"
        },
        {
            "name": "amount",
            "baseName": "amount",
            "type": "Amount"
        },
        {
            "name": "autoBill",
            "baseName": "auto_bill",
            "type": "boolean"
        },
        {
            "name": "autobillStatus",
            "baseName": "autobill_status",
            "type": "string"
        },
        {
            "name": "basecampid",
            "baseName": "basecampid",
            "type": "number"
        },
        {
            "name": "city",
            "baseName": "city",
            "type": "string"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "createDate",
            "baseName": "create_date",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "currencyCode",
            "baseName": "currency_code",
            "type": "string"
        },
        {
            "name": "currentOrganization",
            "baseName": "current_organization",
            "type": "string"
        },
        {
            "name": "customerid",
            "baseName": "customerid",
            "type": "number"
        },
        {
            "name": "datePaid",
            "baseName": "date_paid",
            "type": "string"
        },
        {
            "name": "depositAmount",
            "baseName": "deposit_amount",
            "type": "string"
        },
        {
            "name": "depositPercentage",
            "baseName": "deposit_percentage",
            "type": "string"
        },
        {
            "name": "depositStatus",
            "baseName": "deposit_status",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "discountDescription",
            "baseName": "discount_description",
            "type": "string"
        },
        {
            "name": "discountTotal",
            "baseName": "discount_total",
            "type": "DiscountTotal"
        },
        {
            "name": "discountValue",
            "baseName": "discount_value",
            "type": "string"
        },
        {
            "name": "displayStatus",
            "baseName": "display_status",
            "type": "string"
        },
        {
            "name": "disputeStatus",
            "baseName": "dispute_status",
            "type": "string"
        },
        {
            "name": "dueDate",
            "baseName": "due_date",
            "type": "string"
        },
        {
            "name": "dueOffsetDays",
            "baseName": "due_offset_days",
            "type": "number"
        },
        {
            "name": "estimateid",
            "baseName": "estimateid",
            "type": "number"
        },
        {
            "name": "extArchive",
            "baseName": "ext_archive",
            "type": "number"
        },
        {
            "name": "fname",
            "baseName": "fname",
            "type": "string"
        },
        {
            "name": "fulfillmentDate",
            "baseName": "fulfillment_date",
            "type": "string"
        },
        {
            "name": "generationDate",
            "baseName": "generation_date",
            "type": "string"
        },
        {
            "name": "gmail",
            "baseName": "gmail",
            "type": "boolean"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "invoiceNumber",
            "baseName": "invoice_number",
            "type": "string"
        },
        {
            "name": "invoiceid",
            "baseName": "invoiceid",
            "type": "number"
        },
        {
            "name": "language",
            "baseName": "language",
            "type": "string"
        },
        {
            "name": "lastOrderStatus",
            "baseName": "last_order_status",
            "type": "string"
        },
        {
            "name": "lname",
            "baseName": "lname",
            "type": "string"
        },
        {
            "name": "notes",
            "baseName": "notes",
            "type": "string"
        },
        {
            "name": "organization",
            "baseName": "organization",
            "type": "string"
        },
        {
            "name": "outstanding",
            "baseName": "outstanding",
            "type": "Outstanding"
        },
        {
            "name": "ownerid",
            "baseName": "ownerid",
            "type": "number"
        },
        {
            "name": "paid",
            "baseName": "paid",
            "type": "Paid"
        },
        {
            "name": "parent",
            "baseName": "parent",
            "type": "number"
        },
        {
            "name": "paymentDetails",
            "baseName": "payment_details",
            "type": "string"
        },
        {
            "name": "paymentStatus",
            "baseName": "payment_status",
            "type": "string"
        },
        {
            "name": "poNumber",
            "baseName": "po_number",
            "type": "string"
        },
        {
            "name": "province",
            "baseName": "province",
            "type": "string"
        },
        {
            "name": "returnUri",
            "baseName": "return_uri",
            "type": "string"
        },
        {
            "name": "sentid",
            "baseName": "sentid",
            "type": "number"
        },
        {
            "name": "showAttachments",
            "baseName": "show_attachments",
            "type": "boolean"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "number"
        },
        {
            "name": "street",
            "baseName": "street",
            "type": "string"
        },
        {
            "name": "street2",
            "baseName": "street2",
            "type": "string"
        },
        {
            "name": "template",
            "baseName": "template",
            "type": "string"
        },
        {
            "name": "terms",
            "baseName": "terms",
            "type": "string"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "string"
        },
        {
            "name": "v3Status",
            "baseName": "v3_status",
            "type": "string"
        },
        {
            "name": "vatName",
            "baseName": "vat_name",
            "type": "string"
        },
        {
            "name": "vatNumber",
            "baseName": "vat_number",
            "type": "string"
        },
        {
            "name": "visState",
            "baseName": "vis_state",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Invoice4.attributeTypeMap;
    }
}

export class Invoice6 {
    'visState': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "visState",
            "baseName": "vis_state",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Invoice6.attributeTypeMap;
    }
}

export class Invoice8 {
    'status': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "status",
            "baseName": "status",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Invoice8.attributeTypeMap;
    }
}

export class InvoiceDetails {
    'response': Response67;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Response67"
        }    ];

    static getAttributeTypeMap() {
        return InvoiceDetails.attributeTypeMap;
    }
}

export class InvoiceDetails1 {
    'clientids': Array<string>;
    'clients': Array<string>;
    'companyName': string;
    'currencyCode': string;
    'dateType': string;
    'downloadToken': string;
    'endDate': string;
    'startDate': string;
    'statusids': Array<string>;
    'summary': Summary1;
    'summaryOnly': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "clientids",
            "baseName": "clientids",
            "type": "Array<string>"
        },
        {
            "name": "clients",
            "baseName": "clients",
            "type": "Array<string>"
        },
        {
            "name": "companyName",
            "baseName": "company_name",
            "type": "string"
        },
        {
            "name": "currencyCode",
            "baseName": "currency_code",
            "type": "string"
        },
        {
            "name": "dateType",
            "baseName": "date_type",
            "type": "string"
        },
        {
            "name": "downloadToken",
            "baseName": "download_token",
            "type": "string"
        },
        {
            "name": "endDate",
            "baseName": "end_date",
            "type": "string"
        },
        {
            "name": "startDate",
            "baseName": "start_date",
            "type": "string"
        },
        {
            "name": "statusids",
            "baseName": "statusids",
            "type": "Array<string>"
        },
        {
            "name": "summary",
            "baseName": "summary",
            "type": "Summary1"
        },
        {
            "name": "summaryOnly",
            "baseName": "summary_only",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return InvoiceDetails1.attributeTypeMap;
    }
}

export class InvoiceProfile {
    'accountingSystemid': string;
    'address': string;
    'amount': Amount;
    'autoBill': boolean;
    'billGateway': string;
    'city': string;
    'code': string;
    'country': string;
    'createDate': string;
    'currencyCode': string;
    'customerid': number;
    'description': string;
    'disable': boolean;
    'discountTotal': DiscountTotal;
    'discountValue': string;
    'dueOffsetDays': number;
    'extArchive': string;
    'fname': string;
    'frequency': string;
    'id': number;
    'includeUnbilledTime': boolean;
    'language': string;
    'lname': string;
    'notes': string;
    'numberRecurring': number;
    'occurrencesToDate': number;
    'organization': string;
    'ownerid': number;
    'paymentDetails': string;
    'poNumber': string;
    'profileid': number;
    'province': string;
    'requireAutoBill': boolean;
    'retainerId': string;
    'sendEmail': boolean;
    'sendGmail': boolean;
    'street': string;
    'street2': string;
    'terms': string;
    'totalAccruedRevenue': string;
    'updated': string;
    'vatName': string;
    'vatNumber': string;
    'visState': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountingSystemid",
            "baseName": "accounting_systemid",
            "type": "string"
        },
        {
            "name": "address",
            "baseName": "address",
            "type": "string"
        },
        {
            "name": "amount",
            "baseName": "amount",
            "type": "Amount"
        },
        {
            "name": "autoBill",
            "baseName": "auto_bill",
            "type": "boolean"
        },
        {
            "name": "billGateway",
            "baseName": "bill_gateway",
            "type": "string"
        },
        {
            "name": "city",
            "baseName": "city",
            "type": "string"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "createDate",
            "baseName": "create_date",
            "type": "string"
        },
        {
            "name": "currencyCode",
            "baseName": "currency_code",
            "type": "string"
        },
        {
            "name": "customerid",
            "baseName": "customerid",
            "type": "number"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "disable",
            "baseName": "disable",
            "type": "boolean"
        },
        {
            "name": "discountTotal",
            "baseName": "discount_total",
            "type": "DiscountTotal"
        },
        {
            "name": "discountValue",
            "baseName": "discount_value",
            "type": "string"
        },
        {
            "name": "dueOffsetDays",
            "baseName": "due_offset_days",
            "type": "number"
        },
        {
            "name": "extArchive",
            "baseName": "ext_archive",
            "type": "string"
        },
        {
            "name": "fname",
            "baseName": "fname",
            "type": "string"
        },
        {
            "name": "frequency",
            "baseName": "frequency",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "includeUnbilledTime",
            "baseName": "include_unbilled_time",
            "type": "boolean"
        },
        {
            "name": "language",
            "baseName": "language",
            "type": "string"
        },
        {
            "name": "lname",
            "baseName": "lname",
            "type": "string"
        },
        {
            "name": "notes",
            "baseName": "notes",
            "type": "string"
        },
        {
            "name": "numberRecurring",
            "baseName": "numberRecurring",
            "type": "number"
        },
        {
            "name": "occurrencesToDate",
            "baseName": "occurrences_to_date",
            "type": "number"
        },
        {
            "name": "organization",
            "baseName": "organization",
            "type": "string"
        },
        {
            "name": "ownerid",
            "baseName": "ownerid",
            "type": "number"
        },
        {
            "name": "paymentDetails",
            "baseName": "payment_details",
            "type": "string"
        },
        {
            "name": "poNumber",
            "baseName": "po_number",
            "type": "string"
        },
        {
            "name": "profileid",
            "baseName": "profileid",
            "type": "number"
        },
        {
            "name": "province",
            "baseName": "province",
            "type": "string"
        },
        {
            "name": "requireAutoBill",
            "baseName": "require_auto_bill",
            "type": "boolean"
        },
        {
            "name": "retainerId",
            "baseName": "retainer_id",
            "type": "string"
        },
        {
            "name": "sendEmail",
            "baseName": "send_email",
            "type": "boolean"
        },
        {
            "name": "sendGmail",
            "baseName": "send_gmail",
            "type": "boolean"
        },
        {
            "name": "street",
            "baseName": "street",
            "type": "string"
        },
        {
            "name": "street2",
            "baseName": "street2",
            "type": "string"
        },
        {
            "name": "terms",
            "baseName": "terms",
            "type": "string"
        },
        {
            "name": "totalAccruedRevenue",
            "baseName": "total_accrued_revenue",
            "type": "string"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "string"
        },
        {
            "name": "vatName",
            "baseName": "vat_name",
            "type": "string"
        },
        {
            "name": "vatNumber",
            "baseName": "vat_number",
            "type": "string"
        },
        {
            "name": "visState",
            "baseName": "vis_state",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return InvoiceProfile.attributeTypeMap;
    }
}

export class InvoiceProfile1 {
    'accountingSystemid': string;
    'address': string;
    'amount': Amount;
    'autoBill': boolean;
    'billGateway': string;
    'city': string;
    'code': string;
    'country': string;
    'createDate': string;
    'currencyCode': string;
    'customerid': number;
    'description': string;
    'disable': boolean;
    'discountTotal': DiscountTotal;
    'discountValue': string;
    'dueOffsetDays': number;
    'extArchive': string;
    'fname': string;
    'frequency': string;
    'id': number;
    'includeUnbilledTime': boolean;
    'language': string;
    'lname': string;
    'notes': string;
    'numberRecurring': number;
    'occurrencesToDate': number;
    'organization': string;
    'ownerid': number;
    'paymentDetails': string;
    'poNumber': string;
    'profileid': number;
    'province': string;
    'requireAutoBill': boolean;
    'retainerId': string;
    'sendEmail': boolean;
    'sendGmail': boolean;
    'street': string;
    'street2': string;
    'terms': string;
    'totalAccruedRevenue': string;
    'updated': string;
    'vatName': string;
    'vatNumber': string;
    'visState': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountingSystemid",
            "baseName": "accounting_systemid",
            "type": "string"
        },
        {
            "name": "address",
            "baseName": "address",
            "type": "string"
        },
        {
            "name": "amount",
            "baseName": "amount",
            "type": "Amount"
        },
        {
            "name": "autoBill",
            "baseName": "auto_bill",
            "type": "boolean"
        },
        {
            "name": "billGateway",
            "baseName": "bill_gateway",
            "type": "string"
        },
        {
            "name": "city",
            "baseName": "city",
            "type": "string"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "createDate",
            "baseName": "create_date",
            "type": "string"
        },
        {
            "name": "currencyCode",
            "baseName": "currency_code",
            "type": "string"
        },
        {
            "name": "customerid",
            "baseName": "customerid",
            "type": "number"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "disable",
            "baseName": "disable",
            "type": "boolean"
        },
        {
            "name": "discountTotal",
            "baseName": "discount_total",
            "type": "DiscountTotal"
        },
        {
            "name": "discountValue",
            "baseName": "discount_value",
            "type": "string"
        },
        {
            "name": "dueOffsetDays",
            "baseName": "due_offset_days",
            "type": "number"
        },
        {
            "name": "extArchive",
            "baseName": "ext_archive",
            "type": "string"
        },
        {
            "name": "fname",
            "baseName": "fname",
            "type": "string"
        },
        {
            "name": "frequency",
            "baseName": "frequency",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "includeUnbilledTime",
            "baseName": "include_unbilled_time",
            "type": "boolean"
        },
        {
            "name": "language",
            "baseName": "language",
            "type": "string"
        },
        {
            "name": "lname",
            "baseName": "lname",
            "type": "string"
        },
        {
            "name": "notes",
            "baseName": "notes",
            "type": "string"
        },
        {
            "name": "numberRecurring",
            "baseName": "numberRecurring",
            "type": "number"
        },
        {
            "name": "occurrencesToDate",
            "baseName": "occurrences_to_date",
            "type": "number"
        },
        {
            "name": "organization",
            "baseName": "organization",
            "type": "string"
        },
        {
            "name": "ownerid",
            "baseName": "ownerid",
            "type": "number"
        },
        {
            "name": "paymentDetails",
            "baseName": "payment_details",
            "type": "string"
        },
        {
            "name": "poNumber",
            "baseName": "po_number",
            "type": "string"
        },
        {
            "name": "profileid",
            "baseName": "profileid",
            "type": "number"
        },
        {
            "name": "province",
            "baseName": "province",
            "type": "string"
        },
        {
            "name": "requireAutoBill",
            "baseName": "require_auto_bill",
            "type": "boolean"
        },
        {
            "name": "retainerId",
            "baseName": "retainer_id",
            "type": "string"
        },
        {
            "name": "sendEmail",
            "baseName": "send_email",
            "type": "boolean"
        },
        {
            "name": "sendGmail",
            "baseName": "send_gmail",
            "type": "boolean"
        },
        {
            "name": "street",
            "baseName": "street",
            "type": "string"
        },
        {
            "name": "street2",
            "baseName": "street2",
            "type": "string"
        },
        {
            "name": "terms",
            "baseName": "terms",
            "type": "string"
        },
        {
            "name": "totalAccruedRevenue",
            "baseName": "total_accrued_revenue",
            "type": "string"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "string"
        },
        {
            "name": "vatName",
            "baseName": "vat_name",
            "type": "string"
        },
        {
            "name": "vatNumber",
            "baseName": "vat_number",
            "type": "string"
        },
        {
            "name": "visState",
            "baseName": "vis_state",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return InvoiceProfile1.attributeTypeMap;
    }
}

export class InvoiceProfile2 {
    'accountingSystemid': string;
    'address': string;
    'amount': Amount;
    'autoBill': boolean;
    'billGateway': string;
    'city': string;
    'code': string;
    'country': string;
    'createDate': string;
    'currencyCode': string;
    'customerid': number;
    'description': string;
    'disable': boolean;
    'discountTotal': DiscountTotal;
    'discountValue': string;
    'dueOffsetDays': number;
    'extArchive': string;
    'fname': string;
    'frequency': string;
    'id': number;
    'includeUnbilledTime': boolean;
    'language': string;
    'lname': string;
    'notes': string;
    'numberRecurring': number;
    'occurrencesToDate': number;
    'organization': string;
    'ownerid': number;
    'paymentDetails': string;
    'poNumber': string;
    'profileid': number;
    'province': string;
    'requireAutoBill': boolean;
    'retainerId': string;
    'sendEmail': boolean;
    'sendGmail': boolean;
    'street': string;
    'street2': string;
    'terms': string;
    'totalAccruedRevenue': string;
    'updated': string;
    'vatName': string;
    'vatNumber': string;
    'visState': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountingSystemid",
            "baseName": "accounting_systemid",
            "type": "string"
        },
        {
            "name": "address",
            "baseName": "address",
            "type": "string"
        },
        {
            "name": "amount",
            "baseName": "amount",
            "type": "Amount"
        },
        {
            "name": "autoBill",
            "baseName": "auto_bill",
            "type": "boolean"
        },
        {
            "name": "billGateway",
            "baseName": "bill_gateway",
            "type": "string"
        },
        {
            "name": "city",
            "baseName": "city",
            "type": "string"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "createDate",
            "baseName": "create_date",
            "type": "string"
        },
        {
            "name": "currencyCode",
            "baseName": "currency_code",
            "type": "string"
        },
        {
            "name": "customerid",
            "baseName": "customerid",
            "type": "number"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "disable",
            "baseName": "disable",
            "type": "boolean"
        },
        {
            "name": "discountTotal",
            "baseName": "discount_total",
            "type": "DiscountTotal"
        },
        {
            "name": "discountValue",
            "baseName": "discount_value",
            "type": "string"
        },
        {
            "name": "dueOffsetDays",
            "baseName": "due_offset_days",
            "type": "number"
        },
        {
            "name": "extArchive",
            "baseName": "ext_archive",
            "type": "string"
        },
        {
            "name": "fname",
            "baseName": "fname",
            "type": "string"
        },
        {
            "name": "frequency",
            "baseName": "frequency",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "includeUnbilledTime",
            "baseName": "include_unbilled_time",
            "type": "boolean"
        },
        {
            "name": "language",
            "baseName": "language",
            "type": "string"
        },
        {
            "name": "lname",
            "baseName": "lname",
            "type": "string"
        },
        {
            "name": "notes",
            "baseName": "notes",
            "type": "string"
        },
        {
            "name": "numberRecurring",
            "baseName": "numberRecurring",
            "type": "number"
        },
        {
            "name": "occurrencesToDate",
            "baseName": "occurrences_to_date",
            "type": "number"
        },
        {
            "name": "organization",
            "baseName": "organization",
            "type": "string"
        },
        {
            "name": "ownerid",
            "baseName": "ownerid",
            "type": "number"
        },
        {
            "name": "paymentDetails",
            "baseName": "payment_details",
            "type": "string"
        },
        {
            "name": "poNumber",
            "baseName": "po_number",
            "type": "string"
        },
        {
            "name": "profileid",
            "baseName": "profileid",
            "type": "number"
        },
        {
            "name": "province",
            "baseName": "province",
            "type": "string"
        },
        {
            "name": "requireAutoBill",
            "baseName": "require_auto_bill",
            "type": "boolean"
        },
        {
            "name": "retainerId",
            "baseName": "retainer_id",
            "type": "string"
        },
        {
            "name": "sendEmail",
            "baseName": "send_email",
            "type": "boolean"
        },
        {
            "name": "sendGmail",
            "baseName": "send_gmail",
            "type": "boolean"
        },
        {
            "name": "street",
            "baseName": "street",
            "type": "string"
        },
        {
            "name": "street2",
            "baseName": "street2",
            "type": "string"
        },
        {
            "name": "terms",
            "baseName": "terms",
            "type": "string"
        },
        {
            "name": "totalAccruedRevenue",
            "baseName": "total_accrued_revenue",
            "type": "string"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "string"
        },
        {
            "name": "vatName",
            "baseName": "vat_name",
            "type": "string"
        },
        {
            "name": "vatNumber",
            "baseName": "vat_number",
            "type": "string"
        },
        {
            "name": "visState",
            "baseName": "vis_state",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return InvoiceProfile2.attributeTypeMap;
    }
}

export class InvoiceProfile3 {
    'visState': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "visState",
            "baseName": "vis_state",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return InvoiceProfile3.attributeTypeMap;
    }
}

export class InvoiceProfile5 {
    'frequency': string;
    'numberRecurring': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "frequency",
            "baseName": "frequency",
            "type": "string"
        },
        {
            "name": "numberRecurring",
            "baseName": "numberRecurring",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return InvoiceProfile5.attributeTypeMap;
    }
}

export class Item {
    'accountingSystemid': string;
    'description': string;
    'id': number;
    'inventory': string;
    'itemid': number;
    'name': string;
    'qty': string;
    'tax1': number;
    'tax2': number;
    'unitCost': UnitCost;
    'updated': string;
    'visState': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountingSystemid",
            "baseName": "accounting_systemid",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "inventory",
            "baseName": "inventory",
            "type": "string"
        },
        {
            "name": "itemid",
            "baseName": "itemid",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "qty",
            "baseName": "qty",
            "type": "string"
        },
        {
            "name": "tax1",
            "baseName": "tax1",
            "type": "number"
        },
        {
            "name": "tax2",
            "baseName": "tax2",
            "type": "number"
        },
        {
            "name": "unitCost",
            "baseName": "unit_cost",
            "type": "UnitCost"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "string"
        },
        {
            "name": "visState",
            "baseName": "vis_state",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Item.attributeTypeMap;
    }
}

export class Item1 {
    'name': string;
    'qty': string;
    'inventory': string;
    'unitCost': UnitCost;
    'visState': number;
    'description': string;
    'sku': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "qty",
            "baseName": "qty",
            "type": "string"
        },
        {
            "name": "inventory",
            "baseName": "inventory",
            "type": "string"
        },
        {
            "name": "unitCost",
            "baseName": "unit_cost",
            "type": "UnitCost"
        },
        {
            "name": "visState",
            "baseName": "vis_state",
            "type": "number"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "sku",
            "baseName": "sku",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Item1.attributeTypeMap;
    }
}

export class Item4 {
    'name': string;
    'description': string;
    'inventory': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "inventory",
            "baseName": "inventory",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Item4.attributeTypeMap;
    }
}

export class Item6 {
    'visState': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "visState",
            "baseName": "vis_state",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Item6.attributeTypeMap;
    }
}

export class Item8 {
    'invoices': Array<Invoice13>;
    'name': string;
    'total': Total;
    'totalDiscount': TotalDiscount;
    'totalQty': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "invoices",
            "baseName": "invoices",
            "type": "Array<Invoice13>"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "Total"
        },
        {
            "name": "totalDiscount",
            "baseName": "total_discount",
            "type": "TotalDiscount"
        },
        {
            "name": "totalQty",
            "baseName": "total_qty",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Item8.attributeTypeMap;
    }
}

export class ItemSales {
    'response': Response72;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Response72"
        }    ];

    static getAttributeTypeMap() {
        return ItemSales.attributeTypeMap;
    }
}

export class ItemSales1 {
    'clientids': Array<string>;
    'companyName': string;
    'currencyCode': string;
    'downloadToken': string;
    'endDate': string;
    'itemNames': Array<string>;
    'items': Array<Item8>;
    'startDate': string;
    'statusids': Array<string>;
    'total': Total;
    'totalDiscount': TotalDiscount;
    'totalQty': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "clientids",
            "baseName": "clientids",
            "type": "Array<string>"
        },
        {
            "name": "companyName",
            "baseName": "company_name",
            "type": "string"
        },
        {
            "name": "currencyCode",
            "baseName": "currency_code",
            "type": "string"
        },
        {
            "name": "downloadToken",
            "baseName": "download_token",
            "type": "string"
        },
        {
            "name": "endDate",
            "baseName": "end_date",
            "type": "string"
        },
        {
            "name": "itemNames",
            "baseName": "item_names",
            "type": "Array<string>"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<Item8>"
        },
        {
            "name": "startDate",
            "baseName": "start_date",
            "type": "string"
        },
        {
            "name": "statusids",
            "baseName": "statusids",
            "type": "Array<string>"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "Total"
        },
        {
            "name": "totalDiscount",
            "baseName": "total_discount",
            "type": "TotalDiscount"
        },
        {
            "name": "totalQty",
            "baseName": "total_qty",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ItemSales1.attributeTypeMap;
    }
}

export class J1412 {
    'attachmentsAccess': boolean;
    'clientLimit': number;
    'richProposalsAccess': boolean;
    'staffLimit': number;
    'betaMobileCreateExpenseSubcategoryAccess': boolean;
    'iosBetaZendeskWidgetAccess': boolean;
    'mobileReceiptRebillingAccess': boolean;
    'proposalsCandidateAccess': boolean;
    'heliosPushnotificationsBetaAccess': boolean;
    'esignaturesAccess': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "attachmentsAccess",
            "baseName": "attachments.access",
            "type": "boolean"
        },
        {
            "name": "clientLimit",
            "baseName": "client.limit",
            "type": "number"
        },
        {
            "name": "richProposalsAccess",
            "baseName": "rich_proposals.access",
            "type": "boolean"
        },
        {
            "name": "staffLimit",
            "baseName": "staff.limit",
            "type": "number"
        },
        {
            "name": "betaMobileCreateExpenseSubcategoryAccess",
            "baseName": "beta_mobile_create_expense_subcategory.access",
            "type": "boolean"
        },
        {
            "name": "iosBetaZendeskWidgetAccess",
            "baseName": "ios_beta_zendesk_widget.access",
            "type": "boolean"
        },
        {
            "name": "mobileReceiptRebillingAccess",
            "baseName": "mobile_receipt_rebilling.access",
            "type": "boolean"
        },
        {
            "name": "proposalsCandidateAccess",
            "baseName": "proposals_candidate.access",
            "type": "boolean"
        },
        {
            "name": "heliosPushnotificationsBetaAccess",
            "baseName": "helios_pushnotifications.beta.access",
            "type": "boolean"
        },
        {
            "name": "esignaturesAccess",
            "baseName": "esignatures.access",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return J1412.attributeTypeMap;
    }
}

export class J9hAK {
    'advancedAccountingAccess': boolean;
    'autoBankImportAccess': boolean;
    'autobillLimit': number;
    'bankImportAccess': boolean;
    'clientLimit': number;
    'documentLimit': number;
    'editSubjectLineAccess': boolean;
    'lateFeeAccess': boolean;
    'lateReminderAccess': boolean;
    'recurringRevenueReportAccess': boolean;
    'removeBrandingAccess': boolean;
    'businessAccountantLimit': number;
    'onboardingChecklistAccess': boolean;
    'betaHeliosAsyncExpensesAccess': boolean;
    'betaMobileCreateExpenseSubcategoryAccess': boolean;
    'iosBetaZendeskWidgetAccess': boolean;
    'mobileReceiptRebillingAccess': boolean;
    'heliosPushnotificationsBetaAccess': boolean;
    'iosBetaPaymentSchedulesAccess': boolean;
    'heliosRebillTimeAccess': boolean;
    'esignaturesAccess': boolean;
    'heliosDashboardAccess': boolean;
    'heliosLateFeeReminderBetaAccess': boolean;
    'heliosBulkActionsInvoicesBetaAccess': boolean;
    'heliosVirtualTerminalBetaAccess': boolean;
    'heliosExpenseRebillingBetaAccess': boolean;
    'heliosCompanyTaxesBetaAccess': boolean;
    'heliosInvoiceArchiveBetaAccess': boolean;
    'accountantInviteAccess': boolean;
    'heliosSyncThrottleBetaAccess': boolean;
    'bankReconciliationAccess': boolean;
    'heliosPushResourceToUseExecuteBetaAccess': boolean;
    'newTimeTrackingAccess': boolean;
    'bankRecSmartMatchAccess': boolean;
    'balanceSheetAccess': boolean;
    'invoiceV2SearchAccess': boolean;
    'importItemsCsvAccess': boolean;
    'exportClientsCsvAccess': boolean;
    'heliosVirtualTerminalTutorialBetaAccess': boolean;
    'heliosVirtualTerminalAdvertisingBetaAccess': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "advancedAccountingAccess",
            "baseName": "advanced_accounting.access",
            "type": "boolean"
        },
        {
            "name": "autoBankImportAccess",
            "baseName": "auto_bank_import.access",
            "type": "boolean"
        },
        {
            "name": "autobillLimit",
            "baseName": "autobill.limit",
            "type": "number"
        },
        {
            "name": "bankImportAccess",
            "baseName": "bank_import.access",
            "type": "boolean"
        },
        {
            "name": "clientLimit",
            "baseName": "client.limit",
            "type": "number"
        },
        {
            "name": "documentLimit",
            "baseName": "document.limit",
            "type": "number"
        },
        {
            "name": "editSubjectLineAccess",
            "baseName": "edit_subject_line.access",
            "type": "boolean"
        },
        {
            "name": "lateFeeAccess",
            "baseName": "late_fee.access",
            "type": "boolean"
        },
        {
            "name": "lateReminderAccess",
            "baseName": "late_reminder.access",
            "type": "boolean"
        },
        {
            "name": "recurringRevenueReportAccess",
            "baseName": "recurring_revenue_report.access",
            "type": "boolean"
        },
        {
            "name": "removeBrandingAccess",
            "baseName": "remove_branding.access",
            "type": "boolean"
        },
        {
            "name": "businessAccountantLimit",
            "baseName": "business_accountant.limit",
            "type": "number"
        },
        {
            "name": "onboardingChecklistAccess",
            "baseName": "onboarding_checklist.access",
            "type": "boolean"
        },
        {
            "name": "betaHeliosAsyncExpensesAccess",
            "baseName": "BetaHeliosAsyncExpenses.access",
            "type": "boolean"
        },
        {
            "name": "betaMobileCreateExpenseSubcategoryAccess",
            "baseName": "beta_mobile_create_expense_subcategory.access",
            "type": "boolean"
        },
        {
            "name": "iosBetaZendeskWidgetAccess",
            "baseName": "ios_beta_zendesk_widget.access",
            "type": "boolean"
        },
        {
            "name": "mobileReceiptRebillingAccess",
            "baseName": "mobile_receipt_rebilling.access",
            "type": "boolean"
        },
        {
            "name": "heliosPushnotificationsBetaAccess",
            "baseName": "helios_pushnotifications.beta.access",
            "type": "boolean"
        },
        {
            "name": "iosBetaPaymentSchedulesAccess",
            "baseName": "ios_beta_payment_schedules.access",
            "type": "boolean"
        },
        {
            "name": "heliosRebillTimeAccess",
            "baseName": "helios_rebill_time.access",
            "type": "boolean"
        },
        {
            "name": "esignaturesAccess",
            "baseName": "esignatures.access",
            "type": "boolean"
        },
        {
            "name": "heliosDashboardAccess",
            "baseName": "helios_dashboard.access",
            "type": "boolean"
        },
        {
            "name": "heliosLateFeeReminderBetaAccess",
            "baseName": "helios_late_fee_reminder.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosBulkActionsInvoicesBetaAccess",
            "baseName": "helios_bulk_actions_invoices.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosVirtualTerminalBetaAccess",
            "baseName": "helios_virtual_terminal.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosExpenseRebillingBetaAccess",
            "baseName": "helios_expense_rebilling.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosCompanyTaxesBetaAccess",
            "baseName": "helios_company_taxes.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosInvoiceArchiveBetaAccess",
            "baseName": "helios_invoice_archive.beta.access",
            "type": "boolean"
        },
        {
            "name": "accountantInviteAccess",
            "baseName": "accountant_invite.access",
            "type": "boolean"
        },
        {
            "name": "heliosSyncThrottleBetaAccess",
            "baseName": "helios_sync_throttle.beta.access",
            "type": "boolean"
        },
        {
            "name": "bankReconciliationAccess",
            "baseName": "BankReconciliation.access",
            "type": "boolean"
        },
        {
            "name": "heliosPushResourceToUseExecuteBetaAccess",
            "baseName": "helios_push_resource_to_use_execute.beta.access",
            "type": "boolean"
        },
        {
            "name": "newTimeTrackingAccess",
            "baseName": "new_time_tracking.access",
            "type": "boolean"
        },
        {
            "name": "bankRecSmartMatchAccess",
            "baseName": "bank_rec_smart_match.access",
            "type": "boolean"
        },
        {
            "name": "balanceSheetAccess",
            "baseName": "balance_sheet.access",
            "type": "boolean"
        },
        {
            "name": "invoiceV2SearchAccess",
            "baseName": "invoice_v2_search.access",
            "type": "boolean"
        },
        {
            "name": "importItemsCsvAccess",
            "baseName": "import_items_csv.access",
            "type": "boolean"
        },
        {
            "name": "exportClientsCsvAccess",
            "baseName": "export_clients_csv.access",
            "type": "boolean"
        },
        {
            "name": "heliosVirtualTerminalTutorialBetaAccess",
            "baseName": "helios_virtual_terminal_tutorial.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosVirtualTerminalAdvertisingBetaAccess",
            "baseName": "helios_virtual_terminal_advertising.beta.access",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return J9hAK.attributeTypeMap;
    }
}

export class JournalEntry {
    'details': Array<Detail>;
    'currencyCode': string;
    'description': string;
    'name': string;
    'userEnteredDate': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "details",
            "baseName": "details",
            "type": "Array<Detail>"
        },
        {
            "name": "currencyCode",
            "baseName": "currency_code",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "userEnteredDate",
            "baseName": "user_entered_date",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return JournalEntry.attributeTypeMap;
    }
}

export class JournalEntry1 {
    'currencyCode': string;
    'description': string;
    'details': Array<Detail1>;
    'entryid': number;
    'id': number;
    'name': string;
    'userEnteredDate': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "currencyCode",
            "baseName": "currency_code",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "details",
            "baseName": "details",
            "type": "Array<Detail1>"
        },
        {
            "name": "entryid",
            "baseName": "entryid",
            "type": "number"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "userEnteredDate",
            "baseName": "user_entered_date",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return JournalEntry1.attributeTypeMap;
    }
}

export class JournalEntryAccount {
    'accountName': string;
    'accountNumber': string;
    'accountType': string;
    'accountid': number;
    'balance': string;
    'currencyCode': string;
    'id': number;
    'subAccounts': Array<SubAccount1>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountName",
            "baseName": "account_name",
            "type": "string"
        },
        {
            "name": "accountNumber",
            "baseName": "account_number",
            "type": "string"
        },
        {
            "name": "accountType",
            "baseName": "account_type",
            "type": "string"
        },
        {
            "name": "accountid",
            "baseName": "accountid",
            "type": "number"
        },
        {
            "name": "balance",
            "baseName": "balance",
            "type": "string"
        },
        {
            "name": "currencyCode",
            "baseName": "currency_code",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "subAccounts",
            "baseName": "sub_accounts",
            "type": "Array<SubAccount1>"
        }    ];

    static getAttributeTypeMap() {
        return JournalEntryAccount.attributeTypeMap;
    }
}

export class JournalEntryDetails {
    'response': Response79;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Response79"
        }    ];

    static getAttributeTypeMap() {
        return JournalEntryDetails.attributeTypeMap;
    }
}

export class JournalEntryDetails1 {
    'account': Account2;
    'accountingSystemid': string;
    'balance': Balance;
    'credit': Credit1;
    'debit': Debit1;
    'description': string;
    'detailType': string;
    'detailid': number;
    'entry': Entry;
    'id': number;
    'name': string;
    'subAccount': SubAccount2;
    'userEnteredDate': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "account",
            "baseName": "account",
            "type": "Account2"
        },
        {
            "name": "accountingSystemid",
            "baseName": "accounting_systemid",
            "type": "string"
        },
        {
            "name": "balance",
            "baseName": "balance",
            "type": "Balance"
        },
        {
            "name": "credit",
            "baseName": "credit",
            "type": "Credit1"
        },
        {
            "name": "debit",
            "baseName": "debit",
            "type": "Debit1"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "detailType",
            "baseName": "detail_type",
            "type": "string"
        },
        {
            "name": "detailid",
            "baseName": "detailid",
            "type": "number"
        },
        {
            "name": "entry",
            "baseName": "entry",
            "type": "Entry"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "subAccount",
            "baseName": "sub_account",
            "type": "SubAccount2"
        },
        {
            "name": "userEnteredDate",
            "baseName": "user_entered_date",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return JournalEntryDetails1.attributeTypeMap;
    }
}

export class LJZ1p3 {
    'advancedAccountingAccess': boolean;
    'attachmentsAccess': boolean;
    'businessAccountantLimit': number;
    'clientLimit': number;
    'proposalsCandidateAccess': boolean;
    'richProposalsAccess': boolean;
    'staffLimit': number;
    'betaHeliosAsyncExpensesAccess': boolean;
    'betaMobileCreateExpenseSubcategoryAccess': boolean;
    'iosBetaZendeskWidgetAccess': boolean;
    'mobileReceiptRebillingAccess': boolean;
    'heliosPushnotificationsBetaAccess': boolean;
    'iosBetaPaymentSchedulesAccess': boolean;
    'heliosRebillTimeAccess': boolean;
    'esignaturesAccess': boolean;
    'heliosDashboardAccess': boolean;
    'heliosLateFeeReminderBetaAccess': boolean;
    'heliosBulkActionsInvoicesBetaAccess': boolean;
    'autoBankImportAccess': boolean;
    'heliosVirtualTerminalBetaAccess': boolean;
    'heliosExpenseRebillingBetaAccess': boolean;
    'heliosCompanyTaxesBetaAccess': boolean;
    'heliosInvoiceArchiveBetaAccess': boolean;
    'accountantInviteAccess': boolean;
    'heliosSyncThrottleBetaAccess': boolean;
    'bankReconciliationAccess': boolean;
    'heliosPushResourceToUseExecuteBetaAccess': boolean;
    'newTimeTrackingAccess': boolean;
    'bankRecSmartMatchAccess': boolean;
    'balanceSheetAccess': boolean;
    'invoiceV2SearchAccess': boolean;
    'importItemsCsvAccess': boolean;
    'exportClientsCsvAccess': boolean;
    'heliosVirtualTerminalTutorialBetaAccess': boolean;
    'inlineExpenseEditAccess': boolean;
    'heliosVirtualTerminalAdvertisingBetaAccess': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "advancedAccountingAccess",
            "baseName": "advanced_accounting.access",
            "type": "boolean"
        },
        {
            "name": "attachmentsAccess",
            "baseName": "attachments.access",
            "type": "boolean"
        },
        {
            "name": "businessAccountantLimit",
            "baseName": "business_accountant.limit",
            "type": "number"
        },
        {
            "name": "clientLimit",
            "baseName": "client.limit",
            "type": "number"
        },
        {
            "name": "proposalsCandidateAccess",
            "baseName": "proposals_candidate.access",
            "type": "boolean"
        },
        {
            "name": "richProposalsAccess",
            "baseName": "rich_proposals.access",
            "type": "boolean"
        },
        {
            "name": "staffLimit",
            "baseName": "staff.limit",
            "type": "number"
        },
        {
            "name": "betaHeliosAsyncExpensesAccess",
            "baseName": "BetaHeliosAsyncExpenses.access",
            "type": "boolean"
        },
        {
            "name": "betaMobileCreateExpenseSubcategoryAccess",
            "baseName": "beta_mobile_create_expense_subcategory.access",
            "type": "boolean"
        },
        {
            "name": "iosBetaZendeskWidgetAccess",
            "baseName": "ios_beta_zendesk_widget.access",
            "type": "boolean"
        },
        {
            "name": "mobileReceiptRebillingAccess",
            "baseName": "mobile_receipt_rebilling.access",
            "type": "boolean"
        },
        {
            "name": "heliosPushnotificationsBetaAccess",
            "baseName": "helios_pushnotifications.beta.access",
            "type": "boolean"
        },
        {
            "name": "iosBetaPaymentSchedulesAccess",
            "baseName": "ios_beta_payment_schedules.access",
            "type": "boolean"
        },
        {
            "name": "heliosRebillTimeAccess",
            "baseName": "helios_rebill_time.access",
            "type": "boolean"
        },
        {
            "name": "esignaturesAccess",
            "baseName": "esignatures.access",
            "type": "boolean"
        },
        {
            "name": "heliosDashboardAccess",
            "baseName": "helios_dashboard.access",
            "type": "boolean"
        },
        {
            "name": "heliosLateFeeReminderBetaAccess",
            "baseName": "helios_late_fee_reminder.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosBulkActionsInvoicesBetaAccess",
            "baseName": "helios_bulk_actions_invoices.beta.access",
            "type": "boolean"
        },
        {
            "name": "autoBankImportAccess",
            "baseName": "auto_bank_import.access",
            "type": "boolean"
        },
        {
            "name": "heliosVirtualTerminalBetaAccess",
            "baseName": "helios_virtual_terminal.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosExpenseRebillingBetaAccess",
            "baseName": "helios_expense_rebilling.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosCompanyTaxesBetaAccess",
            "baseName": "helios_company_taxes.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosInvoiceArchiveBetaAccess",
            "baseName": "helios_invoice_archive.beta.access",
            "type": "boolean"
        },
        {
            "name": "accountantInviteAccess",
            "baseName": "accountant_invite.access",
            "type": "boolean"
        },
        {
            "name": "heliosSyncThrottleBetaAccess",
            "baseName": "helios_sync_throttle.beta.access",
            "type": "boolean"
        },
        {
            "name": "bankReconciliationAccess",
            "baseName": "BankReconciliation.access",
            "type": "boolean"
        },
        {
            "name": "heliosPushResourceToUseExecuteBetaAccess",
            "baseName": "helios_push_resource_to_use_execute.beta.access",
            "type": "boolean"
        },
        {
            "name": "newTimeTrackingAccess",
            "baseName": "new_time_tracking.access",
            "type": "boolean"
        },
        {
            "name": "bankRecSmartMatchAccess",
            "baseName": "bank_rec_smart_match.access",
            "type": "boolean"
        },
        {
            "name": "balanceSheetAccess",
            "baseName": "balance_sheet.access",
            "type": "boolean"
        },
        {
            "name": "invoiceV2SearchAccess",
            "baseName": "invoice_v2_search.access",
            "type": "boolean"
        },
        {
            "name": "importItemsCsvAccess",
            "baseName": "import_items_csv.access",
            "type": "boolean"
        },
        {
            "name": "exportClientsCsvAccess",
            "baseName": "export_clients_csv.access",
            "type": "boolean"
        },
        {
            "name": "heliosVirtualTerminalTutorialBetaAccess",
            "baseName": "helios_virtual_terminal_tutorial.beta.access",
            "type": "boolean"
        },
        {
            "name": "inlineExpenseEditAccess",
            "baseName": "inline_expense_edit.access",
            "type": "boolean"
        },
        {
            "name": "heliosVirtualTerminalAdvertisingBetaAccess",
            "baseName": "helios_virtual_terminal_advertising.beta.access",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return LJZ1p3.attributeTypeMap;
    }
}

export class LWn0vG {
    'advancedAccountingAccess': boolean;
    'attachmentsAccess': boolean;
    'businessAccountantLimit': number;
    'clientLimit': number;
    'proposalsCandidateAccess': boolean;
    'richProposalsAccess': boolean;
    'staffLimit': number;
    'betaHeliosAsyncExpensesAccess': boolean;
    'betaMobileCreateExpenseSubcategoryAccess': boolean;
    'iosBetaZendeskWidgetAccess': boolean;
    'mobileReceiptRebillingAccess': boolean;
    'heliosPushnotificationsBetaAccess': boolean;
    'iosBetaPaymentSchedulesAccess': boolean;
    'heliosRebillTimeAccess': boolean;
    'esignaturesAccess': boolean;
    'heliosDashboardAccess': boolean;
    'heliosLateFeeReminderBetaAccess': boolean;
    'heliosBulkActionsInvoicesBetaAccess': boolean;
    'autoBankImportAccess': boolean;
    'heliosVirtualTerminalBetaAccess': boolean;
    'heliosExpenseRebillingBetaAccess': boolean;
    'heliosCompanyTaxesBetaAccess': boolean;
    'heliosInvoiceArchiveBetaAccess': boolean;
    'accountantInviteAccess': boolean;
    'heliosSyncThrottleBetaAccess': boolean;
    'bankReconciliationAccess': boolean;
    'heliosPushResourceToUseExecuteBetaAccess': boolean;
    'newTimeTrackingAccess': boolean;
    'bankRecSmartMatchAccess': boolean;
    'balanceSheetAccess': boolean;
    'invoiceV2SearchAccess': boolean;
    'importItemsCsvAccess': boolean;
    'exportClientsCsvAccess': boolean;
    'heliosVirtualTerminalTutorialBetaAccess': boolean;
    'heliosVirtualTerminalAdvertisingBetaAccess': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "advancedAccountingAccess",
            "baseName": "advanced_accounting.access",
            "type": "boolean"
        },
        {
            "name": "attachmentsAccess",
            "baseName": "attachments.access",
            "type": "boolean"
        },
        {
            "name": "businessAccountantLimit",
            "baseName": "business_accountant.limit",
            "type": "number"
        },
        {
            "name": "clientLimit",
            "baseName": "client.limit",
            "type": "number"
        },
        {
            "name": "proposalsCandidateAccess",
            "baseName": "proposals_candidate.access",
            "type": "boolean"
        },
        {
            "name": "richProposalsAccess",
            "baseName": "rich_proposals.access",
            "type": "boolean"
        },
        {
            "name": "staffLimit",
            "baseName": "staff.limit",
            "type": "number"
        },
        {
            "name": "betaHeliosAsyncExpensesAccess",
            "baseName": "BetaHeliosAsyncExpenses.access",
            "type": "boolean"
        },
        {
            "name": "betaMobileCreateExpenseSubcategoryAccess",
            "baseName": "beta_mobile_create_expense_subcategory.access",
            "type": "boolean"
        },
        {
            "name": "iosBetaZendeskWidgetAccess",
            "baseName": "ios_beta_zendesk_widget.access",
            "type": "boolean"
        },
        {
            "name": "mobileReceiptRebillingAccess",
            "baseName": "mobile_receipt_rebilling.access",
            "type": "boolean"
        },
        {
            "name": "heliosPushnotificationsBetaAccess",
            "baseName": "helios_pushnotifications.beta.access",
            "type": "boolean"
        },
        {
            "name": "iosBetaPaymentSchedulesAccess",
            "baseName": "ios_beta_payment_schedules.access",
            "type": "boolean"
        },
        {
            "name": "heliosRebillTimeAccess",
            "baseName": "helios_rebill_time.access",
            "type": "boolean"
        },
        {
            "name": "esignaturesAccess",
            "baseName": "esignatures.access",
            "type": "boolean"
        },
        {
            "name": "heliosDashboardAccess",
            "baseName": "helios_dashboard.access",
            "type": "boolean"
        },
        {
            "name": "heliosLateFeeReminderBetaAccess",
            "baseName": "helios_late_fee_reminder.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosBulkActionsInvoicesBetaAccess",
            "baseName": "helios_bulk_actions_invoices.beta.access",
            "type": "boolean"
        },
        {
            "name": "autoBankImportAccess",
            "baseName": "auto_bank_import.access",
            "type": "boolean"
        },
        {
            "name": "heliosVirtualTerminalBetaAccess",
            "baseName": "helios_virtual_terminal.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosExpenseRebillingBetaAccess",
            "baseName": "helios_expense_rebilling.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosCompanyTaxesBetaAccess",
            "baseName": "helios_company_taxes.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosInvoiceArchiveBetaAccess",
            "baseName": "helios_invoice_archive.beta.access",
            "type": "boolean"
        },
        {
            "name": "accountantInviteAccess",
            "baseName": "accountant_invite.access",
            "type": "boolean"
        },
        {
            "name": "heliosSyncThrottleBetaAccess",
            "baseName": "helios_sync_throttle.beta.access",
            "type": "boolean"
        },
        {
            "name": "bankReconciliationAccess",
            "baseName": "BankReconciliation.access",
            "type": "boolean"
        },
        {
            "name": "heliosPushResourceToUseExecuteBetaAccess",
            "baseName": "helios_push_resource_to_use_execute.beta.access",
            "type": "boolean"
        },
        {
            "name": "newTimeTrackingAccess",
            "baseName": "new_time_tracking.access",
            "type": "boolean"
        },
        {
            "name": "bankRecSmartMatchAccess",
            "baseName": "bank_rec_smart_match.access",
            "type": "boolean"
        },
        {
            "name": "balanceSheetAccess",
            "baseName": "balance_sheet.access",
            "type": "boolean"
        },
        {
            "name": "invoiceV2SearchAccess",
            "baseName": "invoice_v2_search.access",
            "type": "boolean"
        },
        {
            "name": "importItemsCsvAccess",
            "baseName": "import_items_csv.access",
            "type": "boolean"
        },
        {
            "name": "exportClientsCsvAccess",
            "baseName": "export_clients_csv.access",
            "type": "boolean"
        },
        {
            "name": "heliosVirtualTerminalTutorialBetaAccess",
            "baseName": "helios_virtual_terminal_tutorial.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosVirtualTerminalAdvertisingBetaAccess",
            "baseName": "helios_virtual_terminal_advertising.beta.access",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return LWn0vG.attributeTypeMap;
    }
}

export class LiabilitiesAndEquityTotal {
    'balance': Balance;
    'date': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "balance",
            "baseName": "balance",
            "type": "Balance"
        },
        {
            "name": "date",
            "baseName": "date",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return LiabilitiesAndEquityTotal.attributeTypeMap;
    }
}

export class Links {
    'me': string;
    'roles': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "me",
            "baseName": "me",
            "type": "string"
        },
        {
            "name": "roles",
            "baseName": "roles",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Links.attributeTypeMap;
    }
}

export class Links1 {
    'destroy': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "destroy",
            "baseName": "destroy",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Links1.attributeTypeMap;
    }
}

export class ListClients {
    'response': Response2;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Response2"
        }    ];

    static getAttributeTypeMap() {
        return ListClients.attributeTypeMap;
    }
}

export class ListEntries {
    'meta': Meta;
    'timeEntries': Array<TimeEntry>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "meta",
            "baseName": "meta",
            "type": "Meta"
        },
        {
            "name": "timeEntries",
            "baseName": "time_entries",
            "type": "Array<TimeEntry>"
        }    ];

    static getAttributeTypeMap() {
        return ListEntries.attributeTypeMap;
    }
}

export class ListEstimates {
    'response': Response52;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Response52"
        }    ];

    static getAttributeTypeMap() {
        return ListEstimates.attributeTypeMap;
    }
}

export class ListExpenseCategories {
    'response': Response50;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Response50"
        }    ];

    static getAttributeTypeMap() {
        return ListExpenseCategories.attributeTypeMap;
    }
}

export class ListExpenses {
    'response': Response44;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Response44"
        }    ];

    static getAttributeTypeMap() {
        return ListExpenses.attributeTypeMap;
    }
}

export class ListGateways {
    'gatewayConnections': Array<GatewayConnection>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "gatewayConnections",
            "baseName": "gateway_connections",
            "type": "Array<GatewayConnection>"
        }    ];

    static getAttributeTypeMap() {
        return ListGateways.attributeTypeMap;
    }
}

export class ListInvoiceProfiles {
    'response': Response12;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Response12"
        }    ];

    static getAttributeTypeMap() {
        return ListInvoiceProfiles.attributeTypeMap;
    }
}

export class ListInvoices {
    'response': Response30;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Response30"
        }    ];

    static getAttributeTypeMap() {
        return ListInvoices.attributeTypeMap;
    }
}

export class ListOtherIncome {
    'response': Response21;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Response21"
        }    ];

    static getAttributeTypeMap() {
        return ListOtherIncome.attributeTypeMap;
    }
}

export class ListPayments {
    'response': Response26;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Response26"
        }    ];

    static getAttributeTypeMap() {
        return ListPayments.attributeTypeMap;
    }
}

export class ListProjects {
    'meta': Meta1;
    'projects': Array<Project1>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "meta",
            "baseName": "meta",
            "type": "Meta1"
        },
        {
            "name": "projects",
            "baseName": "projects",
            "type": "Array<Project1>"
        }    ];

    static getAttributeTypeMap() {
        return ListProjects.attributeTypeMap;
    }
}

export class ListStaff {
    'response': Response64;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Response64"
        }    ];

    static getAttributeTypeMap() {
        return ListStaff.attributeTypeMap;
    }
}

export class ListTasks {
    'response': Response58;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Response58"
        }    ];

    static getAttributeTypeMap() {
        return ListTasks.attributeTypeMap;
    }
}

export class ListTaxes {
    'response': Response84;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Response84"
        }    ];

    static getAttributeTypeMap() {
        return ListTaxes.attributeTypeMap;
    }
}

export class ListUser {
    'response': Response1;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Response1"
        }    ];

    static getAttributeTypeMap() {
        return ListUser.attributeTypeMap;
    }
}

export class ListWebhookCallbacks {
    'response': Response89;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Response89"
        }    ];

    static getAttributeTypeMap() {
        return ListWebhookCallbacks.attributeTypeMap;
    }
}

export class M1GeK {
    'attachmentsAccess': boolean;
    'clientLimit': number;
    'richProposalsAccess': boolean;
    'staffLimit': number;
    'betaMobileCreateExpenseSubcategoryAccess': boolean;
    'iosBetaZendeskWidgetAccess': boolean;
    'mobileReceiptRebillingAccess': boolean;
    'proposalsCandidateAccess': boolean;
    'heliosPushnotificationsBetaAccess': boolean;
    'esignaturesAccess': boolean;
    'autoBankImportAccess': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "attachmentsAccess",
            "baseName": "attachments.access",
            "type": "boolean"
        },
        {
            "name": "clientLimit",
            "baseName": "client.limit",
            "type": "number"
        },
        {
            "name": "richProposalsAccess",
            "baseName": "rich_proposals.access",
            "type": "boolean"
        },
        {
            "name": "staffLimit",
            "baseName": "staff.limit",
            "type": "number"
        },
        {
            "name": "betaMobileCreateExpenseSubcategoryAccess",
            "baseName": "beta_mobile_create_expense_subcategory.access",
            "type": "boolean"
        },
        {
            "name": "iosBetaZendeskWidgetAccess",
            "baseName": "ios_beta_zendesk_widget.access",
            "type": "boolean"
        },
        {
            "name": "mobileReceiptRebillingAccess",
            "baseName": "mobile_receipt_rebilling.access",
            "type": "boolean"
        },
        {
            "name": "proposalsCandidateAccess",
            "baseName": "proposals_candidate.access",
            "type": "boolean"
        },
        {
            "name": "heliosPushnotificationsBetaAccess",
            "baseName": "helios_pushnotifications.beta.access",
            "type": "boolean"
        },
        {
            "name": "esignaturesAccess",
            "baseName": "esignatures.access",
            "type": "boolean"
        },
        {
            "name": "autoBankImportAccess",
            "baseName": "auto_bank_import.access",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return M1GeK.attributeTypeMap;
    }
}

export class M1oaR {
    'clientLimit': number;
    'lateFeeAccess': boolean;
    'lateReminderAccess': boolean;
    'staffLimit': number;
    'betaMobileCreateExpenseSubcategoryAccess': boolean;
    'iosBetaZendeskWidgetAccess': boolean;
    'mobileReceiptRebillingAccess': boolean;
    'proposalsCandidateAccess': boolean;
    'heliosPushnotificationsBetaAccess': boolean;
    'esignaturesAccess': boolean;
    'autoBankImportAccess': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "clientLimit",
            "baseName": "client.limit",
            "type": "number"
        },
        {
            "name": "lateFeeAccess",
            "baseName": "late_fee.access",
            "type": "boolean"
        },
        {
            "name": "lateReminderAccess",
            "baseName": "late_reminder.access",
            "type": "boolean"
        },
        {
            "name": "staffLimit",
            "baseName": "staff.limit",
            "type": "number"
        },
        {
            "name": "betaMobileCreateExpenseSubcategoryAccess",
            "baseName": "beta_mobile_create_expense_subcategory.access",
            "type": "boolean"
        },
        {
            "name": "iosBetaZendeskWidgetAccess",
            "baseName": "ios_beta_zendesk_widget.access",
            "type": "boolean"
        },
        {
            "name": "mobileReceiptRebillingAccess",
            "baseName": "mobile_receipt_rebilling.access",
            "type": "boolean"
        },
        {
            "name": "proposalsCandidateAccess",
            "baseName": "proposals_candidate.access",
            "type": "boolean"
        },
        {
            "name": "heliosPushnotificationsBetaAccess",
            "baseName": "helios_pushnotifications.beta.access",
            "type": "boolean"
        },
        {
            "name": "esignaturesAccess",
            "baseName": "esignatures.access",
            "type": "boolean"
        },
        {
            "name": "autoBankImportAccess",
            "baseName": "auto_bank_import.access",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return M1oaR.attributeTypeMap;
    }
}

export class MakePayment {
    'response': Response27;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Response27"
        }    ];

    static getAttributeTypeMap() {
        return MakePayment.attributeTypeMap;
    }
}

export class Member {
    'id': number;
    'identityId': number;
    'role': string;
    'firstName': string;
    'lastName': string;
    'email': string;
    'company': string;
    'active': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "identityId",
            "baseName": "identity_id",
            "type": "number"
        },
        {
            "name": "role",
            "baseName": "role",
            "type": "string"
        },
        {
            "name": "firstName",
            "baseName": "first_name",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "last_name",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "company",
            "baseName": "company",
            "type": "string"
        },
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Member.attributeTypeMap;
    }
}

export class Member3 {
    'id': number;
    'groupId': number;
    'role': string;
    'identityId': number;
    'firstName': string;
    'lastName': string;
    'email': string;
    'company': string;
    'businessId': number;
    'unacknowledgedChange': boolean;
    'active': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "groupId",
            "baseName": "group_id",
            "type": "number"
        },
        {
            "name": "role",
            "baseName": "role",
            "type": "string"
        },
        {
            "name": "identityId",
            "baseName": "identity_id",
            "type": "number"
        },
        {
            "name": "firstName",
            "baseName": "first_name",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "last_name",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "company",
            "baseName": "company",
            "type": "string"
        },
        {
            "name": "businessId",
            "baseName": "business_id",
            "type": "number"
        },
        {
            "name": "unacknowledgedChange",
            "baseName": "unacknowledged_change",
            "type": "boolean"
        },
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Member3.attributeTypeMap;
    }
}

export class Meta {
    'totalLogged': number;
    'totalUnbilled': number;
    'total': number;
    'perPage': number;
    'page': number;
    'pages': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "totalLogged",
            "baseName": "total_logged",
            "type": "number"
        },
        {
            "name": "totalUnbilled",
            "baseName": "total_unbilled",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "perPage",
            "baseName": "per_page",
            "type": "number"
        },
        {
            "name": "page",
            "baseName": "page",
            "type": "number"
        },
        {
            "name": "pages",
            "baseName": "pages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Meta.attributeTypeMap;
    }
}

export class Meta1 {
    'sort': Array<string>;
    'total': number;
    'perPage': number;
    'page': number;
    'pages': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "sort",
            "baseName": "sort",
            "type": "Array<string>"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "perPage",
            "baseName": "per_page",
            "type": "number"
        },
        {
            "name": "page",
            "baseName": "page",
            "type": "number"
        },
        {
            "name": "pages",
            "baseName": "pages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Meta1.attributeTypeMap;
    }
}

export class Model030 {
    'amount': string;
    'code': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "string"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Model030.attributeTypeMap;
    }
}

export class Model3ErwB {
    'attachmentsAccess': boolean;
    'clientLimit': number;
    'richProposalsAccess': boolean;
    'staffLimit': number;
    'betaMobileCreateExpenseSubcategoryAccess': boolean;
    'iosBetaZendeskWidgetAccess': boolean;
    'mobileReceiptRebillingAccess': boolean;
    'proposalsCandidateAccess': boolean;
    'heliosPushnotificationsBetaAccess': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "attachmentsAccess",
            "baseName": "attachments.access",
            "type": "boolean"
        },
        {
            "name": "clientLimit",
            "baseName": "client.limit",
            "type": "number"
        },
        {
            "name": "richProposalsAccess",
            "baseName": "rich_proposals.access",
            "type": "boolean"
        },
        {
            "name": "staffLimit",
            "baseName": "staff.limit",
            "type": "number"
        },
        {
            "name": "betaMobileCreateExpenseSubcategoryAccess",
            "baseName": "beta_mobile_create_expense_subcategory.access",
            "type": "boolean"
        },
        {
            "name": "iosBetaZendeskWidgetAccess",
            "baseName": "ios_beta_zendesk_widget.access",
            "type": "boolean"
        },
        {
            "name": "mobileReceiptRebillingAccess",
            "baseName": "mobile_receipt_rebilling.access",
            "type": "boolean"
        },
        {
            "name": "proposalsCandidateAccess",
            "baseName": "proposals_candidate.access",
            "type": "boolean"
        },
        {
            "name": "heliosPushnotificationsBetaAccess",
            "baseName": "helios_pushnotifications.beta.access",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Model3ErwB.attributeTypeMap;
    }
}

export class Model3x42x2 {
    'advancedAccountingAccess': boolean;
    'attachmentsAccess': boolean;
    'businessAccountantLimit': number;
    'clientLimit': number;
    'proposalsCandidateAccess': boolean;
    'richProposalsAccess': boolean;
    'staffLimit': number;
    'betaHeliosAsyncExpensesAccess': boolean;
    'betaMobileCreateExpenseSubcategoryAccess': boolean;
    'iosBetaZendeskWidgetAccess': boolean;
    'mobileReceiptRebillingAccess': boolean;
    'heliosPushnotificationsBetaAccess': boolean;
    'iosBetaPaymentSchedulesAccess': boolean;
    'heliosRebillTimeAccess': boolean;
    'esignaturesAccess': boolean;
    'heliosDashboardAccess': boolean;
    'heliosLateFeeReminderBetaAccess': boolean;
    'heliosBulkActionsInvoicesBetaAccess': boolean;
    'autoBankImportAccess': boolean;
    'heliosVirtualTerminalBetaAccess': boolean;
    'heliosExpenseRebillingBetaAccess': boolean;
    'heliosCompanyTaxesBetaAccess': boolean;
    'heliosInvoiceArchiveBetaAccess': boolean;
    'accountantInviteAccess': boolean;
    'heliosSyncThrottleBetaAccess': boolean;
    'bankReconciliationAccess': boolean;
    'heliosPushResourceToUseExecuteBetaAccess': boolean;
    'newTimeTrackingAccess': boolean;
    'bankRecSmartMatchAccess': boolean;
    'balanceSheetAccess': boolean;
    'invoiceV2SearchAccess': boolean;
    'importItemsCsvAccess': boolean;
    'exportClientsCsvAccess': boolean;
    'heliosVirtualTerminalTutorialBetaAccess': boolean;
    'inlineExpenseEditAccess': boolean;
    'heliosVirtualTerminalAdvertisingBetaAccess': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "advancedAccountingAccess",
            "baseName": "advanced_accounting.access",
            "type": "boolean"
        },
        {
            "name": "attachmentsAccess",
            "baseName": "attachments.access",
            "type": "boolean"
        },
        {
            "name": "businessAccountantLimit",
            "baseName": "business_accountant.limit",
            "type": "number"
        },
        {
            "name": "clientLimit",
            "baseName": "client.limit",
            "type": "number"
        },
        {
            "name": "proposalsCandidateAccess",
            "baseName": "proposals_candidate.access",
            "type": "boolean"
        },
        {
            "name": "richProposalsAccess",
            "baseName": "rich_proposals.access",
            "type": "boolean"
        },
        {
            "name": "staffLimit",
            "baseName": "staff.limit",
            "type": "number"
        },
        {
            "name": "betaHeliosAsyncExpensesAccess",
            "baseName": "BetaHeliosAsyncExpenses.access",
            "type": "boolean"
        },
        {
            "name": "betaMobileCreateExpenseSubcategoryAccess",
            "baseName": "beta_mobile_create_expense_subcategory.access",
            "type": "boolean"
        },
        {
            "name": "iosBetaZendeskWidgetAccess",
            "baseName": "ios_beta_zendesk_widget.access",
            "type": "boolean"
        },
        {
            "name": "mobileReceiptRebillingAccess",
            "baseName": "mobile_receipt_rebilling.access",
            "type": "boolean"
        },
        {
            "name": "heliosPushnotificationsBetaAccess",
            "baseName": "helios_pushnotifications.beta.access",
            "type": "boolean"
        },
        {
            "name": "iosBetaPaymentSchedulesAccess",
            "baseName": "ios_beta_payment_schedules.access",
            "type": "boolean"
        },
        {
            "name": "heliosRebillTimeAccess",
            "baseName": "helios_rebill_time.access",
            "type": "boolean"
        },
        {
            "name": "esignaturesAccess",
            "baseName": "esignatures.access",
            "type": "boolean"
        },
        {
            "name": "heliosDashboardAccess",
            "baseName": "helios_dashboard.access",
            "type": "boolean"
        },
        {
            "name": "heliosLateFeeReminderBetaAccess",
            "baseName": "helios_late_fee_reminder.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosBulkActionsInvoicesBetaAccess",
            "baseName": "helios_bulk_actions_invoices.beta.access",
            "type": "boolean"
        },
        {
            "name": "autoBankImportAccess",
            "baseName": "auto_bank_import.access",
            "type": "boolean"
        },
        {
            "name": "heliosVirtualTerminalBetaAccess",
            "baseName": "helios_virtual_terminal.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosExpenseRebillingBetaAccess",
            "baseName": "helios_expense_rebilling.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosCompanyTaxesBetaAccess",
            "baseName": "helios_company_taxes.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosInvoiceArchiveBetaAccess",
            "baseName": "helios_invoice_archive.beta.access",
            "type": "boolean"
        },
        {
            "name": "accountantInviteAccess",
            "baseName": "accountant_invite.access",
            "type": "boolean"
        },
        {
            "name": "heliosSyncThrottleBetaAccess",
            "baseName": "helios_sync_throttle.beta.access",
            "type": "boolean"
        },
        {
            "name": "bankReconciliationAccess",
            "baseName": "BankReconciliation.access",
            "type": "boolean"
        },
        {
            "name": "heliosPushResourceToUseExecuteBetaAccess",
            "baseName": "helios_push_resource_to_use_execute.beta.access",
            "type": "boolean"
        },
        {
            "name": "newTimeTrackingAccess",
            "baseName": "new_time_tracking.access",
            "type": "boolean"
        },
        {
            "name": "bankRecSmartMatchAccess",
            "baseName": "bank_rec_smart_match.access",
            "type": "boolean"
        },
        {
            "name": "balanceSheetAccess",
            "baseName": "balance_sheet.access",
            "type": "boolean"
        },
        {
            "name": "invoiceV2SearchAccess",
            "baseName": "invoice_v2_search.access",
            "type": "boolean"
        },
        {
            "name": "importItemsCsvAccess",
            "baseName": "import_items_csv.access",
            "type": "boolean"
        },
        {
            "name": "exportClientsCsvAccess",
            "baseName": "export_clients_csv.access",
            "type": "boolean"
        },
        {
            "name": "heliosVirtualTerminalTutorialBetaAccess",
            "baseName": "helios_virtual_terminal_tutorial.beta.access",
            "type": "boolean"
        },
        {
            "name": "inlineExpenseEditAccess",
            "baseName": "inline_expense_edit.access",
            "type": "boolean"
        },
        {
            "name": "heliosVirtualTerminalAdvertisingBetaAccess",
            "baseName": "helios_virtual_terminal_advertising.beta.access",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Model3x42x2.attributeTypeMap;
    }
}

export class Model4WMVg {
    'clientLimit': number;
    'lateFeeAccess': boolean;
    'lateReminderAccess': boolean;
    'staffLimit': number;
    'betaHeliosAsyncExpensesAccess': boolean;
    'betaMobileCreateExpenseSubcategoryAccess': boolean;
    'iosBetaZendeskWidgetAccess': boolean;
    'mobileReceiptRebillingAccess': boolean;
    'heliosPushnotificationsBetaAccess': boolean;
    'iosBetaPaymentSchedulesAccess': boolean;
    'heliosRebillTimeAccess': boolean;
    'esignaturesAccess': boolean;
    'heliosDashboardAccess': boolean;
    'heliosLateFeeReminderBetaAccess': boolean;
    'heliosBulkActionsInvoicesBetaAccess': boolean;
    'autoBankImportAccess': boolean;
    'heliosVirtualTerminalBetaAccess': boolean;
    'heliosExpenseRebillingBetaAccess': boolean;
    'heliosCompanyTaxesBetaAccess': boolean;
    'heliosInvoiceArchiveBetaAccess': boolean;
    'accountantInviteAccess': boolean;
    'heliosSyncThrottleBetaAccess': boolean;
    'bankReconciliationAccess': boolean;
    'heliosPushResourceToUseExecuteBetaAccess': boolean;
    'newTimeTrackingAccess': boolean;
    'bankRecSmartMatchAccess': boolean;
    'balanceSheetAccess': boolean;
    'invoiceV2SearchAccess': boolean;
    'importItemsCsvAccess': boolean;
    'exportClientsCsvAccess': boolean;
    'heliosVirtualTerminalTutorialBetaAccess': boolean;
    'heliosVirtualTerminalAdvertisingBetaAccess': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "clientLimit",
            "baseName": "client.limit",
            "type": "number"
        },
        {
            "name": "lateFeeAccess",
            "baseName": "late_fee.access",
            "type": "boolean"
        },
        {
            "name": "lateReminderAccess",
            "baseName": "late_reminder.access",
            "type": "boolean"
        },
        {
            "name": "staffLimit",
            "baseName": "staff.limit",
            "type": "number"
        },
        {
            "name": "betaHeliosAsyncExpensesAccess",
            "baseName": "BetaHeliosAsyncExpenses.access",
            "type": "boolean"
        },
        {
            "name": "betaMobileCreateExpenseSubcategoryAccess",
            "baseName": "beta_mobile_create_expense_subcategory.access",
            "type": "boolean"
        },
        {
            "name": "iosBetaZendeskWidgetAccess",
            "baseName": "ios_beta_zendesk_widget.access",
            "type": "boolean"
        },
        {
            "name": "mobileReceiptRebillingAccess",
            "baseName": "mobile_receipt_rebilling.access",
            "type": "boolean"
        },
        {
            "name": "heliosPushnotificationsBetaAccess",
            "baseName": "helios_pushnotifications.beta.access",
            "type": "boolean"
        },
        {
            "name": "iosBetaPaymentSchedulesAccess",
            "baseName": "ios_beta_payment_schedules.access",
            "type": "boolean"
        },
        {
            "name": "heliosRebillTimeAccess",
            "baseName": "helios_rebill_time.access",
            "type": "boolean"
        },
        {
            "name": "esignaturesAccess",
            "baseName": "esignatures.access",
            "type": "boolean"
        },
        {
            "name": "heliosDashboardAccess",
            "baseName": "helios_dashboard.access",
            "type": "boolean"
        },
        {
            "name": "heliosLateFeeReminderBetaAccess",
            "baseName": "helios_late_fee_reminder.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosBulkActionsInvoicesBetaAccess",
            "baseName": "helios_bulk_actions_invoices.beta.access",
            "type": "boolean"
        },
        {
            "name": "autoBankImportAccess",
            "baseName": "auto_bank_import.access",
            "type": "boolean"
        },
        {
            "name": "heliosVirtualTerminalBetaAccess",
            "baseName": "helios_virtual_terminal.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosExpenseRebillingBetaAccess",
            "baseName": "helios_expense_rebilling.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosCompanyTaxesBetaAccess",
            "baseName": "helios_company_taxes.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosInvoiceArchiveBetaAccess",
            "baseName": "helios_invoice_archive.beta.access",
            "type": "boolean"
        },
        {
            "name": "accountantInviteAccess",
            "baseName": "accountant_invite.access",
            "type": "boolean"
        },
        {
            "name": "heliosSyncThrottleBetaAccess",
            "baseName": "helios_sync_throttle.beta.access",
            "type": "boolean"
        },
        {
            "name": "bankReconciliationAccess",
            "baseName": "BankReconciliation.access",
            "type": "boolean"
        },
        {
            "name": "heliosPushResourceToUseExecuteBetaAccess",
            "baseName": "helios_push_resource_to_use_execute.beta.access",
            "type": "boolean"
        },
        {
            "name": "newTimeTrackingAccess",
            "baseName": "new_time_tracking.access",
            "type": "boolean"
        },
        {
            "name": "bankRecSmartMatchAccess",
            "baseName": "bank_rec_smart_match.access",
            "type": "boolean"
        },
        {
            "name": "balanceSheetAccess",
            "baseName": "balance_sheet.access",
            "type": "boolean"
        },
        {
            "name": "invoiceV2SearchAccess",
            "baseName": "invoice_v2_search.access",
            "type": "boolean"
        },
        {
            "name": "importItemsCsvAccess",
            "baseName": "import_items_csv.access",
            "type": "boolean"
        },
        {
            "name": "exportClientsCsvAccess",
            "baseName": "export_clients_csv.access",
            "type": "boolean"
        },
        {
            "name": "heliosVirtualTerminalTutorialBetaAccess",
            "baseName": "helios_virtual_terminal_tutorial.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosVirtualTerminalAdvertisingBetaAccess",
            "baseName": "helios_virtual_terminal_advertising.beta.access",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Model4WMVg.attributeTypeMap;
    }
}

export class Model5o0MVd {
    'advancedAccountingAccess': boolean;
    'attachmentsAccess': boolean;
    'businessAccountantLimit': number;
    'clientLimit': number;
    'proposalsCandidateAccess': boolean;
    'richProposalsAccess': boolean;
    'staffLimit': number;
    'betaHeliosAsyncExpensesAccess': boolean;
    'betaMobileCreateExpenseSubcategoryAccess': boolean;
    'iosBetaZendeskWidgetAccess': boolean;
    'mobileReceiptRebillingAccess': boolean;
    'heliosPushnotificationsBetaAccess': boolean;
    'iosBetaPaymentSchedulesAccess': boolean;
    'heliosRebillTimeAccess': boolean;
    'esignaturesAccess': boolean;
    'heliosDashboardAccess': boolean;
    'heliosLateFeeReminderBetaAccess': boolean;
    'heliosBulkActionsInvoicesBetaAccess': boolean;
    'autoBankImportAccess': boolean;
    'heliosVirtualTerminalBetaAccess': boolean;
    'heliosExpenseRebillingBetaAccess': boolean;
    'heliosCompanyTaxesBetaAccess': boolean;
    'heliosInvoiceArchiveBetaAccess': boolean;
    'accountantInviteAccess': boolean;
    'heliosSyncThrottleBetaAccess': boolean;
    'bankReconciliationAccess': boolean;
    'heliosPushResourceToUseExecuteBetaAccess': boolean;
    'newTimeTrackingAccess': boolean;
    'bankRecSmartMatchAccess': boolean;
    'balanceSheetAccess': boolean;
    'invoiceV2SearchAccess': boolean;
    'importItemsCsvAccess': boolean;
    'exportClientsCsvAccess': boolean;
    'heliosVirtualTerminalTutorialBetaAccess': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "advancedAccountingAccess",
            "baseName": "advanced_accounting.access",
            "type": "boolean"
        },
        {
            "name": "attachmentsAccess",
            "baseName": "attachments.access",
            "type": "boolean"
        },
        {
            "name": "businessAccountantLimit",
            "baseName": "business_accountant.limit",
            "type": "number"
        },
        {
            "name": "clientLimit",
            "baseName": "client.limit",
            "type": "number"
        },
        {
            "name": "proposalsCandidateAccess",
            "baseName": "proposals_candidate.access",
            "type": "boolean"
        },
        {
            "name": "richProposalsAccess",
            "baseName": "rich_proposals.access",
            "type": "boolean"
        },
        {
            "name": "staffLimit",
            "baseName": "staff.limit",
            "type": "number"
        },
        {
            "name": "betaHeliosAsyncExpensesAccess",
            "baseName": "BetaHeliosAsyncExpenses.access",
            "type": "boolean"
        },
        {
            "name": "betaMobileCreateExpenseSubcategoryAccess",
            "baseName": "beta_mobile_create_expense_subcategory.access",
            "type": "boolean"
        },
        {
            "name": "iosBetaZendeskWidgetAccess",
            "baseName": "ios_beta_zendesk_widget.access",
            "type": "boolean"
        },
        {
            "name": "mobileReceiptRebillingAccess",
            "baseName": "mobile_receipt_rebilling.access",
            "type": "boolean"
        },
        {
            "name": "heliosPushnotificationsBetaAccess",
            "baseName": "helios_pushnotifications.beta.access",
            "type": "boolean"
        },
        {
            "name": "iosBetaPaymentSchedulesAccess",
            "baseName": "ios_beta_payment_schedules.access",
            "type": "boolean"
        },
        {
            "name": "heliosRebillTimeAccess",
            "baseName": "helios_rebill_time.access",
            "type": "boolean"
        },
        {
            "name": "esignaturesAccess",
            "baseName": "esignatures.access",
            "type": "boolean"
        },
        {
            "name": "heliosDashboardAccess",
            "baseName": "helios_dashboard.access",
            "type": "boolean"
        },
        {
            "name": "heliosLateFeeReminderBetaAccess",
            "baseName": "helios_late_fee_reminder.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosBulkActionsInvoicesBetaAccess",
            "baseName": "helios_bulk_actions_invoices.beta.access",
            "type": "boolean"
        },
        {
            "name": "autoBankImportAccess",
            "baseName": "auto_bank_import.access",
            "type": "boolean"
        },
        {
            "name": "heliosVirtualTerminalBetaAccess",
            "baseName": "helios_virtual_terminal.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosExpenseRebillingBetaAccess",
            "baseName": "helios_expense_rebilling.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosCompanyTaxesBetaAccess",
            "baseName": "helios_company_taxes.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosInvoiceArchiveBetaAccess",
            "baseName": "helios_invoice_archive.beta.access",
            "type": "boolean"
        },
        {
            "name": "accountantInviteAccess",
            "baseName": "accountant_invite.access",
            "type": "boolean"
        },
        {
            "name": "heliosSyncThrottleBetaAccess",
            "baseName": "helios_sync_throttle.beta.access",
            "type": "boolean"
        },
        {
            "name": "bankReconciliationAccess",
            "baseName": "BankReconciliation.access",
            "type": "boolean"
        },
        {
            "name": "heliosPushResourceToUseExecuteBetaAccess",
            "baseName": "helios_push_resource_to_use_execute.beta.access",
            "type": "boolean"
        },
        {
            "name": "newTimeTrackingAccess",
            "baseName": "new_time_tracking.access",
            "type": "boolean"
        },
        {
            "name": "bankRecSmartMatchAccess",
            "baseName": "bank_rec_smart_match.access",
            "type": "boolean"
        },
        {
            "name": "balanceSheetAccess",
            "baseName": "balance_sheet.access",
            "type": "boolean"
        },
        {
            "name": "invoiceV2SearchAccess",
            "baseName": "invoice_v2_search.access",
            "type": "boolean"
        },
        {
            "name": "importItemsCsvAccess",
            "baseName": "import_items_csv.access",
            "type": "boolean"
        },
        {
            "name": "exportClientsCsvAccess",
            "baseName": "export_clients_csv.access",
            "type": "boolean"
        },
        {
            "name": "heliosVirtualTerminalTutorialBetaAccess",
            "baseName": "helios_virtual_terminal_tutorial.beta.access",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Model5o0MVd.attributeTypeMap;
    }
}

export class Model7Po26 {
    'attachmentsAccess': boolean;
    'clientLimit': number;
    'richProposalsAccess': boolean;
    'staffLimit': number;
    'advancedAccountingAccess': boolean;
    'betaMobileCreateExpenseSubcategoryAccess': boolean;
    'iosBetaZendeskWidgetAccess': boolean;
    'mobileReceiptRebillingAccess': boolean;
    'proposalsCandidateAccess': boolean;
    'heliosPushnotificationsBetaAccess': boolean;
    'esignaturesAccess': boolean;
    'autoBankImportAccess': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "attachmentsAccess",
            "baseName": "attachments.access",
            "type": "boolean"
        },
        {
            "name": "clientLimit",
            "baseName": "client.limit",
            "type": "number"
        },
        {
            "name": "richProposalsAccess",
            "baseName": "rich_proposals.access",
            "type": "boolean"
        },
        {
            "name": "staffLimit",
            "baseName": "staff.limit",
            "type": "number"
        },
        {
            "name": "advancedAccountingAccess",
            "baseName": "advanced_accounting.access",
            "type": "boolean"
        },
        {
            "name": "betaMobileCreateExpenseSubcategoryAccess",
            "baseName": "beta_mobile_create_expense_subcategory.access",
            "type": "boolean"
        },
        {
            "name": "iosBetaZendeskWidgetAccess",
            "baseName": "ios_beta_zendesk_widget.access",
            "type": "boolean"
        },
        {
            "name": "mobileReceiptRebillingAccess",
            "baseName": "mobile_receipt_rebilling.access",
            "type": "boolean"
        },
        {
            "name": "proposalsCandidateAccess",
            "baseName": "proposals_candidate.access",
            "type": "boolean"
        },
        {
            "name": "heliosPushnotificationsBetaAccess",
            "baseName": "helios_pushnotifications.beta.access",
            "type": "boolean"
        },
        {
            "name": "esignaturesAccess",
            "baseName": "esignatures.access",
            "type": "boolean"
        },
        {
            "name": "autoBankImportAccess",
            "baseName": "auto_bank_import.access",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Model7Po26.attributeTypeMap;
    }
}

export class Model7lwxR {
    'attachmentsAccess': boolean;
    'clientLimit': number;
    'richProposalsAccess': boolean;
    'staffLimit': number;
    'advancedAccountingAccess': boolean;
    'businessAccountantLimit': number;
    'proposalsCandidateAccess': boolean;
    'betaHeliosAsyncExpensesAccess': boolean;
    'betaMobileCreateExpenseSubcategoryAccess': boolean;
    'iosBetaZendeskWidgetAccess': boolean;
    'mobileReceiptRebillingAccess': boolean;
    'heliosPushnotificationsBetaAccess': boolean;
    'iosBetaPaymentSchedulesAccess': boolean;
    'heliosRebillTimeAccess': boolean;
    'esignaturesAccess': boolean;
    'heliosDashboardAccess': boolean;
    'heliosLateFeeReminderBetaAccess': boolean;
    'heliosBulkActionsInvoicesBetaAccess': boolean;
    'autoBankImportAccess': boolean;
    'heliosVirtualTerminalBetaAccess': boolean;
    'heliosExpenseRebillingBetaAccess': boolean;
    'heliosCompanyTaxesBetaAccess': boolean;
    'heliosInvoiceArchiveBetaAccess': boolean;
    'accountantInviteAccess': boolean;
    'heliosSyncThrottleBetaAccess': boolean;
    'bankReconciliationAccess': boolean;
    'heliosPushResourceToUseExecuteBetaAccess': boolean;
    'newTimeTrackingAccess': boolean;
    'bankRecSmartMatchAccess': boolean;
    'balanceSheetAccess': boolean;
    'invoiceV2SearchAccess': boolean;
    'importItemsCsvAccess': boolean;
    'exportClientsCsvAccess': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "attachmentsAccess",
            "baseName": "attachments.access",
            "type": "boolean"
        },
        {
            "name": "clientLimit",
            "baseName": "client.limit",
            "type": "number"
        },
        {
            "name": "richProposalsAccess",
            "baseName": "rich_proposals.access",
            "type": "boolean"
        },
        {
            "name": "staffLimit",
            "baseName": "staff.limit",
            "type": "number"
        },
        {
            "name": "advancedAccountingAccess",
            "baseName": "advanced_accounting.access",
            "type": "boolean"
        },
        {
            "name": "businessAccountantLimit",
            "baseName": "business_accountant.limit",
            "type": "number"
        },
        {
            "name": "proposalsCandidateAccess",
            "baseName": "proposals_candidate.access",
            "type": "boolean"
        },
        {
            "name": "betaHeliosAsyncExpensesAccess",
            "baseName": "BetaHeliosAsyncExpenses.access",
            "type": "boolean"
        },
        {
            "name": "betaMobileCreateExpenseSubcategoryAccess",
            "baseName": "beta_mobile_create_expense_subcategory.access",
            "type": "boolean"
        },
        {
            "name": "iosBetaZendeskWidgetAccess",
            "baseName": "ios_beta_zendesk_widget.access",
            "type": "boolean"
        },
        {
            "name": "mobileReceiptRebillingAccess",
            "baseName": "mobile_receipt_rebilling.access",
            "type": "boolean"
        },
        {
            "name": "heliosPushnotificationsBetaAccess",
            "baseName": "helios_pushnotifications.beta.access",
            "type": "boolean"
        },
        {
            "name": "iosBetaPaymentSchedulesAccess",
            "baseName": "ios_beta_payment_schedules.access",
            "type": "boolean"
        },
        {
            "name": "heliosRebillTimeAccess",
            "baseName": "helios_rebill_time.access",
            "type": "boolean"
        },
        {
            "name": "esignaturesAccess",
            "baseName": "esignatures.access",
            "type": "boolean"
        },
        {
            "name": "heliosDashboardAccess",
            "baseName": "helios_dashboard.access",
            "type": "boolean"
        },
        {
            "name": "heliosLateFeeReminderBetaAccess",
            "baseName": "helios_late_fee_reminder.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosBulkActionsInvoicesBetaAccess",
            "baseName": "helios_bulk_actions_invoices.beta.access",
            "type": "boolean"
        },
        {
            "name": "autoBankImportAccess",
            "baseName": "auto_bank_import.access",
            "type": "boolean"
        },
        {
            "name": "heliosVirtualTerminalBetaAccess",
            "baseName": "helios_virtual_terminal.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosExpenseRebillingBetaAccess",
            "baseName": "helios_expense_rebilling.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosCompanyTaxesBetaAccess",
            "baseName": "helios_company_taxes.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosInvoiceArchiveBetaAccess",
            "baseName": "helios_invoice_archive.beta.access",
            "type": "boolean"
        },
        {
            "name": "accountantInviteAccess",
            "baseName": "accountant_invite.access",
            "type": "boolean"
        },
        {
            "name": "heliosSyncThrottleBetaAccess",
            "baseName": "helios_sync_throttle.beta.access",
            "type": "boolean"
        },
        {
            "name": "bankReconciliationAccess",
            "baseName": "BankReconciliation.access",
            "type": "boolean"
        },
        {
            "name": "heliosPushResourceToUseExecuteBetaAccess",
            "baseName": "helios_push_resource_to_use_execute.beta.access",
            "type": "boolean"
        },
        {
            "name": "newTimeTrackingAccess",
            "baseName": "new_time_tracking.access",
            "type": "boolean"
        },
        {
            "name": "bankRecSmartMatchAccess",
            "baseName": "bank_rec_smart_match.access",
            "type": "boolean"
        },
        {
            "name": "balanceSheetAccess",
            "baseName": "balance_sheet.access",
            "type": "boolean"
        },
        {
            "name": "invoiceV2SearchAccess",
            "baseName": "invoice_v2_search.access",
            "type": "boolean"
        },
        {
            "name": "importItemsCsvAccess",
            "baseName": "import_items_csv.access",
            "type": "boolean"
        },
        {
            "name": "exportClientsCsvAccess",
            "baseName": "export_clients_csv.access",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Model7lwxR.attributeTypeMap;
    }
}

export class Model85lLQg {
    'advancedAccountingAccess': boolean;
    'attachmentsAccess': boolean;
    'businessAccountantLimit': number;
    'clientLimit': number;
    'proposalsCandidateAccess': boolean;
    'richProposalsAccess': boolean;
    'staffLimit': number;
    'betaHeliosAsyncExpensesAccess': boolean;
    'betaMobileCreateExpenseSubcategoryAccess': boolean;
    'iosBetaZendeskWidgetAccess': boolean;
    'mobileReceiptRebillingAccess': boolean;
    'heliosPushnotificationsBetaAccess': boolean;
    'iosBetaPaymentSchedulesAccess': boolean;
    'heliosRebillTimeAccess': boolean;
    'esignaturesAccess': boolean;
    'heliosDashboardAccess': boolean;
    'heliosLateFeeReminderBetaAccess': boolean;
    'heliosBulkActionsInvoicesBetaAccess': boolean;
    'autoBankImportAccess': boolean;
    'heliosVirtualTerminalBetaAccess': boolean;
    'heliosExpenseRebillingBetaAccess': boolean;
    'heliosCompanyTaxesBetaAccess': boolean;
    'heliosInvoiceArchiveBetaAccess': boolean;
    'accountantInviteAccess': boolean;
    'heliosSyncThrottleBetaAccess': boolean;
    'bankReconciliationAccess': boolean;
    'heliosPushResourceToUseExecuteBetaAccess': boolean;
    'newTimeTrackingAccess': boolean;
    'bankRecSmartMatchAccess': boolean;
    'balanceSheetAccess': boolean;
    'invoiceV2SearchAccess': boolean;
    'importItemsCsvAccess': boolean;
    'exportClientsCsvAccess': boolean;
    'heliosVirtualTerminalTutorialBetaAccess': boolean;
    'heliosVirtualTerminalAdvertisingBetaAccess': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "advancedAccountingAccess",
            "baseName": "advanced_accounting.access",
            "type": "boolean"
        },
        {
            "name": "attachmentsAccess",
            "baseName": "attachments.access",
            "type": "boolean"
        },
        {
            "name": "businessAccountantLimit",
            "baseName": "business_accountant.limit",
            "type": "number"
        },
        {
            "name": "clientLimit",
            "baseName": "client.limit",
            "type": "number"
        },
        {
            "name": "proposalsCandidateAccess",
            "baseName": "proposals_candidate.access",
            "type": "boolean"
        },
        {
            "name": "richProposalsAccess",
            "baseName": "rich_proposals.access",
            "type": "boolean"
        },
        {
            "name": "staffLimit",
            "baseName": "staff.limit",
            "type": "number"
        },
        {
            "name": "betaHeliosAsyncExpensesAccess",
            "baseName": "BetaHeliosAsyncExpenses.access",
            "type": "boolean"
        },
        {
            "name": "betaMobileCreateExpenseSubcategoryAccess",
            "baseName": "beta_mobile_create_expense_subcategory.access",
            "type": "boolean"
        },
        {
            "name": "iosBetaZendeskWidgetAccess",
            "baseName": "ios_beta_zendesk_widget.access",
            "type": "boolean"
        },
        {
            "name": "mobileReceiptRebillingAccess",
            "baseName": "mobile_receipt_rebilling.access",
            "type": "boolean"
        },
        {
            "name": "heliosPushnotificationsBetaAccess",
            "baseName": "helios_pushnotifications.beta.access",
            "type": "boolean"
        },
        {
            "name": "iosBetaPaymentSchedulesAccess",
            "baseName": "ios_beta_payment_schedules.access",
            "type": "boolean"
        },
        {
            "name": "heliosRebillTimeAccess",
            "baseName": "helios_rebill_time.access",
            "type": "boolean"
        },
        {
            "name": "esignaturesAccess",
            "baseName": "esignatures.access",
            "type": "boolean"
        },
        {
            "name": "heliosDashboardAccess",
            "baseName": "helios_dashboard.access",
            "type": "boolean"
        },
        {
            "name": "heliosLateFeeReminderBetaAccess",
            "baseName": "helios_late_fee_reminder.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosBulkActionsInvoicesBetaAccess",
            "baseName": "helios_bulk_actions_invoices.beta.access",
            "type": "boolean"
        },
        {
            "name": "autoBankImportAccess",
            "baseName": "auto_bank_import.access",
            "type": "boolean"
        },
        {
            "name": "heliosVirtualTerminalBetaAccess",
            "baseName": "helios_virtual_terminal.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosExpenseRebillingBetaAccess",
            "baseName": "helios_expense_rebilling.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosCompanyTaxesBetaAccess",
            "baseName": "helios_company_taxes.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosInvoiceArchiveBetaAccess",
            "baseName": "helios_invoice_archive.beta.access",
            "type": "boolean"
        },
        {
            "name": "accountantInviteAccess",
            "baseName": "accountant_invite.access",
            "type": "boolean"
        },
        {
            "name": "heliosSyncThrottleBetaAccess",
            "baseName": "helios_sync_throttle.beta.access",
            "type": "boolean"
        },
        {
            "name": "bankReconciliationAccess",
            "baseName": "BankReconciliation.access",
            "type": "boolean"
        },
        {
            "name": "heliosPushResourceToUseExecuteBetaAccess",
            "baseName": "helios_push_resource_to_use_execute.beta.access",
            "type": "boolean"
        },
        {
            "name": "newTimeTrackingAccess",
            "baseName": "new_time_tracking.access",
            "type": "boolean"
        },
        {
            "name": "bankRecSmartMatchAccess",
            "baseName": "bank_rec_smart_match.access",
            "type": "boolean"
        },
        {
            "name": "balanceSheetAccess",
            "baseName": "balance_sheet.access",
            "type": "boolean"
        },
        {
            "name": "invoiceV2SearchAccess",
            "baseName": "invoice_v2_search.access",
            "type": "boolean"
        },
        {
            "name": "importItemsCsvAccess",
            "baseName": "import_items_csv.access",
            "type": "boolean"
        },
        {
            "name": "exportClientsCsvAccess",
            "baseName": "export_clients_csv.access",
            "type": "boolean"
        },
        {
            "name": "heliosVirtualTerminalTutorialBetaAccess",
            "baseName": "helios_virtual_terminal_tutorial.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosVirtualTerminalAdvertisingBetaAccess",
            "baseName": "helios_virtual_terminal_advertising.beta.access",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Model85lLQg.attributeTypeMap;
    }
}

export class Model8NppA {
    'advancedAccountingAccess': boolean;
    'advancedPaymentsAccess': boolean;
    'autoBankImportAccess': boolean;
    'autobillLimit': number;
    'bankImportAccess': boolean;
    'businessAccountantLimit': number;
    'clientLimit': number;
    'documentLimit': number;
    'editSubjectLineAccess': boolean;
    'lateFeeAccess': boolean;
    'lateReminderAccess': boolean;
    'paymentsFeesReportAccess': boolean;
    'recurringRevenueReportAccess': boolean;
    'removeBrandingAccess': boolean;
    'staffLimit': number;
    'betaHeliosAsyncExpensesAccess': boolean;
    'betaMobileCreateExpenseSubcategoryAccess': boolean;
    'iosBetaZendeskWidgetAccess': boolean;
    'mobileReceiptRebillingAccess': boolean;
    'richProposalsAccess': boolean;
    'proposalsCandidateAccess': boolean;
    'heliosPushnotificationsBetaAccess': boolean;
    'iosBetaPaymentSchedulesAccess': boolean;
    'heliosRebillTimeAccess': boolean;
    'esignaturesAccess': boolean;
    'heliosDashboardAccess': boolean;
    'heliosLateFeeReminderBetaAccess': boolean;
    'heliosBulkActionsInvoicesBetaAccess': boolean;
    'heliosVirtualTerminalBetaAccess': boolean;
    'heliosExpenseRebillingBetaAccess': boolean;
    'heliosCompanyTaxesBetaAccess': boolean;
    'heliosInvoiceArchiveBetaAccess': boolean;
    'accountantInviteAccess': boolean;
    'heliosSyncThrottleBetaAccess': boolean;
    'bankReconciliationAccess': boolean;
    'heliosPushResourceToUseExecuteBetaAccess': boolean;
    'newTimeTrackingAccess': boolean;
    'bankRecSmartMatchAccess': boolean;
    'balanceSheetAccess': boolean;
    'invoiceV2SearchAccess': boolean;
    'importItemsCsvAccess': boolean;
    'exportClientsCsvAccess': boolean;
    'heliosVirtualTerminalTutorialBetaAccess': boolean;
    'inlineExpenseEditAccess': boolean;
    'heliosVirtualTerminalAdvertisingBetaAccess': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "advancedAccountingAccess",
            "baseName": "advanced_accounting.access",
            "type": "boolean"
        },
        {
            "name": "advancedPaymentsAccess",
            "baseName": "advanced_payments.access",
            "type": "boolean"
        },
        {
            "name": "autoBankImportAccess",
            "baseName": "auto_bank_import.access",
            "type": "boolean"
        },
        {
            "name": "autobillLimit",
            "baseName": "autobill.limit",
            "type": "number"
        },
        {
            "name": "bankImportAccess",
            "baseName": "bank_import.access",
            "type": "boolean"
        },
        {
            "name": "businessAccountantLimit",
            "baseName": "business_accountant.limit",
            "type": "number"
        },
        {
            "name": "clientLimit",
            "baseName": "client.limit",
            "type": "number"
        },
        {
            "name": "documentLimit",
            "baseName": "document.limit",
            "type": "number"
        },
        {
            "name": "editSubjectLineAccess",
            "baseName": "edit_subject_line.access",
            "type": "boolean"
        },
        {
            "name": "lateFeeAccess",
            "baseName": "late_fee.access",
            "type": "boolean"
        },
        {
            "name": "lateReminderAccess",
            "baseName": "late_reminder.access",
            "type": "boolean"
        },
        {
            "name": "paymentsFeesReportAccess",
            "baseName": "payments_fees_report.access",
            "type": "boolean"
        },
        {
            "name": "recurringRevenueReportAccess",
            "baseName": "recurring_revenue_report.access",
            "type": "boolean"
        },
        {
            "name": "removeBrandingAccess",
            "baseName": "remove_branding.access",
            "type": "boolean"
        },
        {
            "name": "staffLimit",
            "baseName": "staff.limit",
            "type": "number"
        },
        {
            "name": "betaHeliosAsyncExpensesAccess",
            "baseName": "BetaHeliosAsyncExpenses.access",
            "type": "boolean"
        },
        {
            "name": "betaMobileCreateExpenseSubcategoryAccess",
            "baseName": "beta_mobile_create_expense_subcategory.access",
            "type": "boolean"
        },
        {
            "name": "iosBetaZendeskWidgetAccess",
            "baseName": "ios_beta_zendesk_widget.access",
            "type": "boolean"
        },
        {
            "name": "mobileReceiptRebillingAccess",
            "baseName": "mobile_receipt_rebilling.access",
            "type": "boolean"
        },
        {
            "name": "richProposalsAccess",
            "baseName": "rich_proposals.access",
            "type": "boolean"
        },
        {
            "name": "proposalsCandidateAccess",
            "baseName": "proposals_candidate.access",
            "type": "boolean"
        },
        {
            "name": "heliosPushnotificationsBetaAccess",
            "baseName": "helios_pushnotifications.beta.access",
            "type": "boolean"
        },
        {
            "name": "iosBetaPaymentSchedulesAccess",
            "baseName": "ios_beta_payment_schedules.access",
            "type": "boolean"
        },
        {
            "name": "heliosRebillTimeAccess",
            "baseName": "helios_rebill_time.access",
            "type": "boolean"
        },
        {
            "name": "esignaturesAccess",
            "baseName": "esignatures.access",
            "type": "boolean"
        },
        {
            "name": "heliosDashboardAccess",
            "baseName": "helios_dashboard.access",
            "type": "boolean"
        },
        {
            "name": "heliosLateFeeReminderBetaAccess",
            "baseName": "helios_late_fee_reminder.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosBulkActionsInvoicesBetaAccess",
            "baseName": "helios_bulk_actions_invoices.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosVirtualTerminalBetaAccess",
            "baseName": "helios_virtual_terminal.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosExpenseRebillingBetaAccess",
            "baseName": "helios_expense_rebilling.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosCompanyTaxesBetaAccess",
            "baseName": "helios_company_taxes.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosInvoiceArchiveBetaAccess",
            "baseName": "helios_invoice_archive.beta.access",
            "type": "boolean"
        },
        {
            "name": "accountantInviteAccess",
            "baseName": "accountant_invite.access",
            "type": "boolean"
        },
        {
            "name": "heliosSyncThrottleBetaAccess",
            "baseName": "helios_sync_throttle.beta.access",
            "type": "boolean"
        },
        {
            "name": "bankReconciliationAccess",
            "baseName": "BankReconciliation.access",
            "type": "boolean"
        },
        {
            "name": "heliosPushResourceToUseExecuteBetaAccess",
            "baseName": "helios_push_resource_to_use_execute.beta.access",
            "type": "boolean"
        },
        {
            "name": "newTimeTrackingAccess",
            "baseName": "new_time_tracking.access",
            "type": "boolean"
        },
        {
            "name": "bankRecSmartMatchAccess",
            "baseName": "bank_rec_smart_match.access",
            "type": "boolean"
        },
        {
            "name": "balanceSheetAccess",
            "baseName": "balance_sheet.access",
            "type": "boolean"
        },
        {
            "name": "invoiceV2SearchAccess",
            "baseName": "invoice_v2_search.access",
            "type": "boolean"
        },
        {
            "name": "importItemsCsvAccess",
            "baseName": "import_items_csv.access",
            "type": "boolean"
        },
        {
            "name": "exportClientsCsvAccess",
            "baseName": "export_clients_csv.access",
            "type": "boolean"
        },
        {
            "name": "heliosVirtualTerminalTutorialBetaAccess",
            "baseName": "helios_virtual_terminal_tutorial.beta.access",
            "type": "boolean"
        },
        {
            "name": "inlineExpenseEditAccess",
            "baseName": "inline_expense_edit.access",
            "type": "boolean"
        },
        {
            "name": "heliosVirtualTerminalAdvertisingBetaAccess",
            "baseName": "helios_virtual_terminal_advertising.beta.access",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Model8NppA.attributeTypeMap;
    }
}

export class ModelError {
    'errno': number;
    'field': string;
    'message': string;
    'object': string;
    'value': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errno",
            "baseName": "errno",
            "type": "number"
        },
        {
            "name": "field",
            "baseName": "field",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "object",
            "baseName": "object",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ModelError.attributeTypeMap;
    }
}

export class NetProfit {
    'children': Array<string>;
    'data': Array<string>;
    'description': string;
    'entryType': string;
    'total': Total;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "children",
            "baseName": "children",
            "type": "Array<string>"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<string>"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "entryType",
            "baseName": "entry_type",
            "type": "string"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "Total"
        }    ];

    static getAttributeTypeMap() {
        return NetProfit.attributeTypeMap;
    }
}

export class NetTax {
    'amount': string;
    'code': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "string"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return NetTax.attributeTypeMap;
    }
}

export class NetTaxableAmount {
    'amount': string;
    'code': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "string"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return NetTaxableAmount.attributeTypeMap;
    }
}

export class NewClient {
    'response': Response5;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Response5"
        }    ];

    static getAttributeTypeMap() {
        return NewClient.attributeTypeMap;
    }
}

export class NewClientRequest {
    'client': Client2;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "client",
            "baseName": "client",
            "type": "Client2"
        }    ];

    static getAttributeTypeMap() {
        return NewClientRequest.attributeTypeMap;
    }
}

export class ON6yL {
    'advancedAccountingAccess': boolean;
    'advancedPaymentsAccess': boolean;
    'autoBankImportAccess': boolean;
    'autobillLimit': number;
    'bankImportAccess': boolean;
    'clientLimit': number;
    'documentLimit': number;
    'editSubjectLineAccess': boolean;
    'lateFeeAccess': boolean;
    'lateReminderAccess': boolean;
    'removeBrandingAccess': boolean;
    'staffLimit': number;
    'businessAccountantLimit': number;
    'betaHeliosAsyncExpensesAccess': boolean;
    'betaMobileCreateExpenseSubcategoryAccess': boolean;
    'iosBetaZendeskWidgetAccess': boolean;
    'mobileReceiptRebillingAccess': boolean;
    'richProposalsAccess': boolean;
    'proposalsCandidateAccess': boolean;
    'heliosPushnotificationsBetaAccess': boolean;
    'iosBetaPaymentSchedulesAccess': boolean;
    'heliosRebillTimeAccess': boolean;
    'esignaturesAccess': boolean;
    'heliosDashboardAccess': boolean;
    'heliosLateFeeReminderBetaAccess': boolean;
    'heliosBulkActionsInvoicesBetaAccess': boolean;
    'heliosVirtualTerminalBetaAccess': boolean;
    'heliosExpenseRebillingBetaAccess': boolean;
    'heliosCompanyTaxesBetaAccess': boolean;
    'heliosInvoiceArchiveBetaAccess': boolean;
    'accountantInviteAccess': boolean;
    'heliosSyncThrottleBetaAccess': boolean;
    'bankReconciliationAccess': boolean;
    'heliosPushResourceToUseExecuteBetaAccess': boolean;
    'newTimeTrackingAccess': boolean;
    'bankRecSmartMatchAccess': boolean;
    'balanceSheetAccess': boolean;
    'invoiceV2SearchAccess': boolean;
    'importItemsCsvAccess': boolean;
    'exportClientsCsvAccess': boolean;
    'heliosVirtualTerminalTutorialBetaAccess': boolean;
    'inlineExpenseEditAccess': boolean;
    'heliosVirtualTerminalAdvertisingBetaAccess': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "advancedAccountingAccess",
            "baseName": "advanced_accounting.access",
            "type": "boolean"
        },
        {
            "name": "advancedPaymentsAccess",
            "baseName": "advanced_payments.access",
            "type": "boolean"
        },
        {
            "name": "autoBankImportAccess",
            "baseName": "auto_bank_import.access",
            "type": "boolean"
        },
        {
            "name": "autobillLimit",
            "baseName": "autobill.limit",
            "type": "number"
        },
        {
            "name": "bankImportAccess",
            "baseName": "bank_import.access",
            "type": "boolean"
        },
        {
            "name": "clientLimit",
            "baseName": "client.limit",
            "type": "number"
        },
        {
            "name": "documentLimit",
            "baseName": "document.limit",
            "type": "number"
        },
        {
            "name": "editSubjectLineAccess",
            "baseName": "edit_subject_line.access",
            "type": "boolean"
        },
        {
            "name": "lateFeeAccess",
            "baseName": "late_fee.access",
            "type": "boolean"
        },
        {
            "name": "lateReminderAccess",
            "baseName": "late_reminder.access",
            "type": "boolean"
        },
        {
            "name": "removeBrandingAccess",
            "baseName": "remove_branding.access",
            "type": "boolean"
        },
        {
            "name": "staffLimit",
            "baseName": "staff.limit",
            "type": "number"
        },
        {
            "name": "businessAccountantLimit",
            "baseName": "business_accountant.limit",
            "type": "number"
        },
        {
            "name": "betaHeliosAsyncExpensesAccess",
            "baseName": "BetaHeliosAsyncExpenses.access",
            "type": "boolean"
        },
        {
            "name": "betaMobileCreateExpenseSubcategoryAccess",
            "baseName": "beta_mobile_create_expense_subcategory.access",
            "type": "boolean"
        },
        {
            "name": "iosBetaZendeskWidgetAccess",
            "baseName": "ios_beta_zendesk_widget.access",
            "type": "boolean"
        },
        {
            "name": "mobileReceiptRebillingAccess",
            "baseName": "mobile_receipt_rebilling.access",
            "type": "boolean"
        },
        {
            "name": "richProposalsAccess",
            "baseName": "rich_proposals.access",
            "type": "boolean"
        },
        {
            "name": "proposalsCandidateAccess",
            "baseName": "proposals_candidate.access",
            "type": "boolean"
        },
        {
            "name": "heliosPushnotificationsBetaAccess",
            "baseName": "helios_pushnotifications.beta.access",
            "type": "boolean"
        },
        {
            "name": "iosBetaPaymentSchedulesAccess",
            "baseName": "ios_beta_payment_schedules.access",
            "type": "boolean"
        },
        {
            "name": "heliosRebillTimeAccess",
            "baseName": "helios_rebill_time.access",
            "type": "boolean"
        },
        {
            "name": "esignaturesAccess",
            "baseName": "esignatures.access",
            "type": "boolean"
        },
        {
            "name": "heliosDashboardAccess",
            "baseName": "helios_dashboard.access",
            "type": "boolean"
        },
        {
            "name": "heliosLateFeeReminderBetaAccess",
            "baseName": "helios_late_fee_reminder.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosBulkActionsInvoicesBetaAccess",
            "baseName": "helios_bulk_actions_invoices.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosVirtualTerminalBetaAccess",
            "baseName": "helios_virtual_terminal.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosExpenseRebillingBetaAccess",
            "baseName": "helios_expense_rebilling.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosCompanyTaxesBetaAccess",
            "baseName": "helios_company_taxes.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosInvoiceArchiveBetaAccess",
            "baseName": "helios_invoice_archive.beta.access",
            "type": "boolean"
        },
        {
            "name": "accountantInviteAccess",
            "baseName": "accountant_invite.access",
            "type": "boolean"
        },
        {
            "name": "heliosSyncThrottleBetaAccess",
            "baseName": "helios_sync_throttle.beta.access",
            "type": "boolean"
        },
        {
            "name": "bankReconciliationAccess",
            "baseName": "BankReconciliation.access",
            "type": "boolean"
        },
        {
            "name": "heliosPushResourceToUseExecuteBetaAccess",
            "baseName": "helios_push_resource_to_use_execute.beta.access",
            "type": "boolean"
        },
        {
            "name": "newTimeTrackingAccess",
            "baseName": "new_time_tracking.access",
            "type": "boolean"
        },
        {
            "name": "bankRecSmartMatchAccess",
            "baseName": "bank_rec_smart_match.access",
            "type": "boolean"
        },
        {
            "name": "balanceSheetAccess",
            "baseName": "balance_sheet.access",
            "type": "boolean"
        },
        {
            "name": "invoiceV2SearchAccess",
            "baseName": "invoice_v2_search.access",
            "type": "boolean"
        },
        {
            "name": "importItemsCsvAccess",
            "baseName": "import_items_csv.access",
            "type": "boolean"
        },
        {
            "name": "exportClientsCsvAccess",
            "baseName": "export_clients_csv.access",
            "type": "boolean"
        },
        {
            "name": "heliosVirtualTerminalTutorialBetaAccess",
            "baseName": "helios_virtual_terminal_tutorial.beta.access",
            "type": "boolean"
        },
        {
            "name": "inlineExpenseEditAccess",
            "baseName": "inline_expense_edit.access",
            "type": "boolean"
        },
        {
            "name": "heliosVirtualTerminalAdvertisingBetaAccess",
            "baseName": "helios_virtual_terminal_advertising.beta.access",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return ON6yL.attributeTypeMap;
    }
}

export class OtherIncome {
    'amount': Amount;
    'categoryName': string;
    'createdAt': string;
    'date': string;
    'incomeid': number;
    'note': string;
    'paymentType': string;
    'source': string;
    'taxes': Array<Taxis>;
    'updatedAt': string;
    'visState': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "Amount"
        },
        {
            "name": "categoryName",
            "baseName": "category_name",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "date",
            "baseName": "date",
            "type": "string"
        },
        {
            "name": "incomeid",
            "baseName": "incomeid",
            "type": "number"
        },
        {
            "name": "note",
            "baseName": "note",
            "type": "string"
        },
        {
            "name": "paymentType",
            "baseName": "payment_type",
            "type": "string"
        },
        {
            "name": "source",
            "baseName": "source",
            "type": "string"
        },
        {
            "name": "taxes",
            "baseName": "taxes",
            "type": "Array<Taxis>"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        },
        {
            "name": "visState",
            "baseName": "vis_state",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return OtherIncome.attributeTypeMap;
    }
}

export class OtherIncome1 {
    'amount': Amount;
    'categoryName': string;
    'date': string;
    'note': string;
    'paymentType': string;
    'source': string;
    'taxes': Array<Taxis1>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "Amount"
        },
        {
            "name": "categoryName",
            "baseName": "category_name",
            "type": "string"
        },
        {
            "name": "date",
            "baseName": "date",
            "type": "string"
        },
        {
            "name": "note",
            "baseName": "note",
            "type": "string"
        },
        {
            "name": "paymentType",
            "baseName": "payment_type",
            "type": "string"
        },
        {
            "name": "source",
            "baseName": "source",
            "type": "string"
        },
        {
            "name": "taxes",
            "baseName": "taxes",
            "type": "Array<Taxis1>"
        }    ];

    static getAttributeTypeMap() {
        return OtherIncome1.attributeTypeMap;
    }
}

export class OtherIncome2 {
    'amount': Amount;
    'categoryName': string;
    'createdAt': string;
    'date': string;
    'incomeid': number;
    'note': string;
    'paymentType': string;
    'source': string;
    'taxes': Array<Taxis1>;
    'updatedAt': string;
    'visState': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "Amount"
        },
        {
            "name": "categoryName",
            "baseName": "category_name",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "date",
            "baseName": "date",
            "type": "string"
        },
        {
            "name": "incomeid",
            "baseName": "incomeid",
            "type": "number"
        },
        {
            "name": "note",
            "baseName": "note",
            "type": "string"
        },
        {
            "name": "paymentType",
            "baseName": "payment_type",
            "type": "string"
        },
        {
            "name": "source",
            "baseName": "source",
            "type": "string"
        },
        {
            "name": "taxes",
            "baseName": "taxes",
            "type": "Array<Taxis1>"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        },
        {
            "name": "visState",
            "baseName": "vis_state",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return OtherIncome2.attributeTypeMap;
    }
}

export class OtherIncome3 {
    'amount': Amount;
    'date': string;
    'source': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "Amount"
        },
        {
            "name": "date",
            "baseName": "date",
            "type": "string"
        },
        {
            "name": "source",
            "baseName": "source",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OtherIncome3.attributeTypeMap;
    }
}

export class OtherIncome4 {
    'amount': Amount;
    'categoryName': string;
    'createdAt': string;
    'date': string;
    'incomeid': number;
    'note': string;
    'paymentType': string;
    'source': string;
    'taxes': Array<string>;
    'updatedAt': string;
    'visState': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "Amount"
        },
        {
            "name": "categoryName",
            "baseName": "category_name",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "date",
            "baseName": "date",
            "type": "string"
        },
        {
            "name": "incomeid",
            "baseName": "incomeid",
            "type": "number"
        },
        {
            "name": "note",
            "baseName": "note",
            "type": "string"
        },
        {
            "name": "paymentType",
            "baseName": "payment_type",
            "type": "string"
        },
        {
            "name": "source",
            "baseName": "source",
            "type": "string"
        },
        {
            "name": "taxes",
            "baseName": "taxes",
            "type": "Array<string>"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        },
        {
            "name": "visState",
            "baseName": "vis_state",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return OtherIncome4.attributeTypeMap;
    }
}

export class OtherIncome5 {
    'visState': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "visState",
            "baseName": "vis_state",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return OtherIncome5.attributeTypeMap;
    }
}

export class Outstanding {
    'amount': string;
    'code': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "string"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Outstanding.attributeTypeMap;
    }
}

export class PPLMZ {
    'advancedAccountingAccess': boolean;
    'attachmentsAccess': boolean;
    'clientLimit': number;
    'richProposalsAccess': boolean;
    'staffLimit': number;
    'businessAccountantLimit': number;
    'proposalsCandidateAccess': boolean;
    'betaMobileCreateExpenseSubcategoryAccess': boolean;
    'iosBetaZendeskWidgetAccess': boolean;
    'mobileReceiptRebillingAccess': boolean;
    'heliosPushnotificationsBetaAccess': boolean;
    'esignaturesAccess': boolean;
    'heliosBulkActionsInvoicesBetaAccess': boolean;
    'autoBankImportAccess': boolean;
    'heliosExpenseRebillingBetaAccess': boolean;
    'heliosCompanyTaxesBetaAccess': boolean;
    'heliosInvoiceArchiveBetaAccess': boolean;
    'heliosSyncThrottleBetaAccess': boolean;
    'heliosPushResourceToUseExecuteBetaAccess': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "advancedAccountingAccess",
            "baseName": "advanced_accounting.access",
            "type": "boolean"
        },
        {
            "name": "attachmentsAccess",
            "baseName": "attachments.access",
            "type": "boolean"
        },
        {
            "name": "clientLimit",
            "baseName": "client.limit",
            "type": "number"
        },
        {
            "name": "richProposalsAccess",
            "baseName": "rich_proposals.access",
            "type": "boolean"
        },
        {
            "name": "staffLimit",
            "baseName": "staff.limit",
            "type": "number"
        },
        {
            "name": "businessAccountantLimit",
            "baseName": "business_accountant.limit",
            "type": "number"
        },
        {
            "name": "proposalsCandidateAccess",
            "baseName": "proposals_candidate.access",
            "type": "boolean"
        },
        {
            "name": "betaMobileCreateExpenseSubcategoryAccess",
            "baseName": "beta_mobile_create_expense_subcategory.access",
            "type": "boolean"
        },
        {
            "name": "iosBetaZendeskWidgetAccess",
            "baseName": "ios_beta_zendesk_widget.access",
            "type": "boolean"
        },
        {
            "name": "mobileReceiptRebillingAccess",
            "baseName": "mobile_receipt_rebilling.access",
            "type": "boolean"
        },
        {
            "name": "heliosPushnotificationsBetaAccess",
            "baseName": "helios_pushnotifications.beta.access",
            "type": "boolean"
        },
        {
            "name": "esignaturesAccess",
            "baseName": "esignatures.access",
            "type": "boolean"
        },
        {
            "name": "heliosBulkActionsInvoicesBetaAccess",
            "baseName": "helios_bulk_actions_invoices.beta.access",
            "type": "boolean"
        },
        {
            "name": "autoBankImportAccess",
            "baseName": "auto_bank_import.access",
            "type": "boolean"
        },
        {
            "name": "heliosExpenseRebillingBetaAccess",
            "baseName": "helios_expense_rebilling.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosCompanyTaxesBetaAccess",
            "baseName": "helios_company_taxes.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosInvoiceArchiveBetaAccess",
            "baseName": "helios_invoice_archive.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosSyncThrottleBetaAccess",
            "baseName": "helios_sync_throttle.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosPushResourceToUseExecuteBetaAccess",
            "baseName": "helios_push_resource_to_use_execute.beta.access",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return PPLMZ.attributeTypeMap;
    }
}

export class Paid {
    'amount': string;
    'code': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "string"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Paid.attributeTypeMap;
    }
}

export class Payment {
    'accountingSystemid': string;
    'amount': Amount;
    'clientid': number;
    'creditid': string;
    'date': string;
    'fromCredit': boolean;
    'gateway': string;
    'id': number;
    'invoiceid': number;
    'logid': number;
    'note': string;
    'orderid': string;
    'overpaymentid': string;
    'transactionid': string;
    'type': string;
    'updated': string;
    'visState': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountingSystemid",
            "baseName": "accounting_systemid",
            "type": "string"
        },
        {
            "name": "amount",
            "baseName": "amount",
            "type": "Amount"
        },
        {
            "name": "clientid",
            "baseName": "clientid",
            "type": "number"
        },
        {
            "name": "creditid",
            "baseName": "creditid",
            "type": "string"
        },
        {
            "name": "date",
            "baseName": "date",
            "type": "string"
        },
        {
            "name": "fromCredit",
            "baseName": "from_credit",
            "type": "boolean"
        },
        {
            "name": "gateway",
            "baseName": "gateway",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "invoiceid",
            "baseName": "invoiceid",
            "type": "number"
        },
        {
            "name": "logid",
            "baseName": "logid",
            "type": "number"
        },
        {
            "name": "note",
            "baseName": "note",
            "type": "string"
        },
        {
            "name": "orderid",
            "baseName": "orderid",
            "type": "string"
        },
        {
            "name": "overpaymentid",
            "baseName": "overpaymentid",
            "type": "string"
        },
        {
            "name": "transactionid",
            "baseName": "transactionid",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "string"
        },
        {
            "name": "visState",
            "baseName": "vis_state",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Payment.attributeTypeMap;
    }
}

export class Payment2 {
    'accountingSystemid': string;
    'amount': Amount;
    'clientid': number;
    'creditid': string;
    'date': string;
    'fromCredit': boolean;
    'gateway': string;
    'id': number;
    'invoiceid': number;
    'logid': number;
    'note': string;
    'orderid': string;
    'overpaymentid': number;
    'transactionid': string;
    'type': string;
    'updated': string;
    'visState': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountingSystemid",
            "baseName": "accounting_systemid",
            "type": "string"
        },
        {
            "name": "amount",
            "baseName": "amount",
            "type": "Amount"
        },
        {
            "name": "clientid",
            "baseName": "clientid",
            "type": "number"
        },
        {
            "name": "creditid",
            "baseName": "creditid",
            "type": "string"
        },
        {
            "name": "date",
            "baseName": "date",
            "type": "string"
        },
        {
            "name": "fromCredit",
            "baseName": "from_credit",
            "type": "boolean"
        },
        {
            "name": "gateway",
            "baseName": "gateway",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "invoiceid",
            "baseName": "invoiceid",
            "type": "number"
        },
        {
            "name": "logid",
            "baseName": "logid",
            "type": "number"
        },
        {
            "name": "note",
            "baseName": "note",
            "type": "string"
        },
        {
            "name": "orderid",
            "baseName": "orderid",
            "type": "string"
        },
        {
            "name": "overpaymentid",
            "baseName": "overpaymentid",
            "type": "number"
        },
        {
            "name": "transactionid",
            "baseName": "transactionid",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "string"
        },
        {
            "name": "visState",
            "baseName": "vis_state",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Payment2.attributeTypeMap;
    }
}

export class Payment3 {
    'visState': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "visState",
            "baseName": "vis_state",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Payment3.attributeTypeMap;
    }
}

export class Payment5 {
    'amount': Amount;
    'note': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "Amount"
        },
        {
            "name": "note",
            "baseName": "note",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Payment5.attributeTypeMap;
    }
}

export class PaymentAmount {
    'amount': string;
    'code': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "string"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PaymentAmount.attributeTypeMap;
    }
}

export class PaymentsCollected {
    'response': Response71;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Response71"
        }    ];

    static getAttributeTypeMap() {
        return PaymentsCollected.attributeTypeMap;
    }
}

export class PaymentsCollected1 {
    'clientids': Array<string>;
    'currencyCodes': Array<string>;
    'downloadToken': string;
    'endDate': string;
    'paymentMethods': Array<string>;
    'payments': Array<string>;
    'startDate': string;
    'totals': Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "clientids",
            "baseName": "clientids",
            "type": "Array<string>"
        },
        {
            "name": "currencyCodes",
            "baseName": "currency_codes",
            "type": "Array<string>"
        },
        {
            "name": "downloadToken",
            "baseName": "download_token",
            "type": "string"
        },
        {
            "name": "endDate",
            "baseName": "end_date",
            "type": "string"
        },
        {
            "name": "paymentMethods",
            "baseName": "payment_methods",
            "type": "Array<string>"
        },
        {
            "name": "payments",
            "baseName": "payments",
            "type": "Array<string>"
        },
        {
            "name": "startDate",
            "baseName": "start_date",
            "type": "string"
        },
        {
            "name": "totals",
            "baseName": "totals",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return PaymentsCollected1.attributeTypeMap;
    }
}

export class Pe4MW {
    'advancedAccountingAccess': boolean;
    'attachmentsAccess': boolean;
    'clientLimit': number;
    'richProposalsAccess': boolean;
    'staffLimit': number;
    'betaMobileCreateExpenseSubcategoryAccess': boolean;
    'iosBetaZendeskWidgetAccess': boolean;
    'mobileReceiptRebillingAccess': boolean;
    'proposalsCandidateAccess': boolean;
    'heliosPushnotificationsBetaAccess': boolean;
    'esignaturesAccess': boolean;
    'heliosBulkActionsInvoicesBetaAccess': boolean;
    'autoBankImportAccess': boolean;
    'heliosExpenseRebillingBetaAccess': boolean;
    'heliosCompanyTaxesBetaAccess': boolean;
    'heliosInvoiceArchiveBetaAccess': boolean;
    'heliosSyncThrottleBetaAccess': boolean;
    'heliosPushResourceToUseExecuteBetaAccess': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "advancedAccountingAccess",
            "baseName": "advanced_accounting.access",
            "type": "boolean"
        },
        {
            "name": "attachmentsAccess",
            "baseName": "attachments.access",
            "type": "boolean"
        },
        {
            "name": "clientLimit",
            "baseName": "client.limit",
            "type": "number"
        },
        {
            "name": "richProposalsAccess",
            "baseName": "rich_proposals.access",
            "type": "boolean"
        },
        {
            "name": "staffLimit",
            "baseName": "staff.limit",
            "type": "number"
        },
        {
            "name": "betaMobileCreateExpenseSubcategoryAccess",
            "baseName": "beta_mobile_create_expense_subcategory.access",
            "type": "boolean"
        },
        {
            "name": "iosBetaZendeskWidgetAccess",
            "baseName": "ios_beta_zendesk_widget.access",
            "type": "boolean"
        },
        {
            "name": "mobileReceiptRebillingAccess",
            "baseName": "mobile_receipt_rebilling.access",
            "type": "boolean"
        },
        {
            "name": "proposalsCandidateAccess",
            "baseName": "proposals_candidate.access",
            "type": "boolean"
        },
        {
            "name": "heliosPushnotificationsBetaAccess",
            "baseName": "helios_pushnotifications.beta.access",
            "type": "boolean"
        },
        {
            "name": "esignaturesAccess",
            "baseName": "esignatures.access",
            "type": "boolean"
        },
        {
            "name": "heliosBulkActionsInvoicesBetaAccess",
            "baseName": "helios_bulk_actions_invoices.beta.access",
            "type": "boolean"
        },
        {
            "name": "autoBankImportAccess",
            "baseName": "auto_bank_import.access",
            "type": "boolean"
        },
        {
            "name": "heliosExpenseRebillingBetaAccess",
            "baseName": "helios_expense_rebilling.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosCompanyTaxesBetaAccess",
            "baseName": "helios_company_taxes.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosInvoiceArchiveBetaAccess",
            "baseName": "helios_invoice_archive.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosSyncThrottleBetaAccess",
            "baseName": "helios_sync_throttle.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosPushResourceToUseExecuteBetaAccess",
            "baseName": "helios_push_resource_to_use_execute.beta.access",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Pe4MW.attributeTypeMap;
    }
}

export class Permissions {
    'rAlTo': RAlTo;
    'e86QZ': E86QZ;
    'rmpKp': RmpKp;
    'j9hAK': J9hAK;
    'gr1ndR': Gr1ndR;
    'apwodA': ApwodA;
    'xgGiT': XgGiT;
    '_7lwxR': Model7lwxR;
    '_4WMVg': Model4WMVg;
    'x34yX': X34yX;
    'e1rYq': E1rYq;
    '_3ErwB': Model3ErwB;
    '_8NppA': Model8NppA;
    'j1412': J1412;
    'bRAVo': BRAVo;
    'm1oaR': M1oaR;
    'e4MaY': E4MaY;
    'm1GeK': M1GeK;
    '_7Po26': Model7Po26;
    'zaZdo': ZaZdo;
    'pPLMZ': PPLMZ;
    'eeCnZ': EeCnZ;
    'pe4MW': Pe4MW;
    'oN6yL': ON6yL;
    'dowO0g': DowO0g;
    'yA0R2P': YA0R2P;
    'lJZ1p3': LJZ1p3;
    'wkMd2g': WkMd2g;
    '_3x42x2': Model3x42x2;
    'lWn0vG': LWn0vG;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "rAlTo",
            "baseName": "rAlTo",
            "type": "RAlTo"
        },
        {
            "name": "e86QZ",
            "baseName": "E86QZ",
            "type": "E86QZ"
        },
        {
            "name": "rmpKp",
            "baseName": "RmpKp",
            "type": "RmpKp"
        },
        {
            "name": "j9hAK",
            "baseName": "J9hAK",
            "type": "J9hAK"
        },
        {
            "name": "gr1ndR",
            "baseName": "gr1ndR",
            "type": "Gr1ndR"
        },
        {
            "name": "apwodA",
            "baseName": "apwodA",
            "type": "ApwodA"
        },
        {
            "name": "xgGiT",
            "baseName": "XgGiT",
            "type": "XgGiT"
        },
        {
            "name": "_7lwxR",
            "baseName": "7lwxR",
            "type": "Model7lwxR"
        },
        {
            "name": "_4WMVg",
            "baseName": "4WMVg",
            "type": "Model4WMVg"
        },
        {
            "name": "x34yX",
            "baseName": "x34yX",
            "type": "X34yX"
        },
        {
            "name": "e1rYq",
            "baseName": "e1rYq",
            "type": "E1rYq"
        },
        {
            "name": "_3ErwB",
            "baseName": "3ErwB",
            "type": "Model3ErwB"
        },
        {
            "name": "_8NppA",
            "baseName": "8NppA",
            "type": "Model8NppA"
        },
        {
            "name": "j1412",
            "baseName": "j1412",
            "type": "J1412"
        },
        {
            "name": "bRAVo",
            "baseName": "BRAVo",
            "type": "BRAVo"
        },
        {
            "name": "m1oaR",
            "baseName": "M1oaR",
            "type": "M1oaR"
        },
        {
            "name": "e4MaY",
            "baseName": "E4MaY",
            "type": "E4MaY"
        },
        {
            "name": "m1GeK",
            "baseName": "M1GeK",
            "type": "M1GeK"
        },
        {
            "name": "_7Po26",
            "baseName": "7Po26",
            "type": "Model7Po26"
        },
        {
            "name": "zaZdo",
            "baseName": "ZaZdo",
            "type": "ZaZdo"
        },
        {
            "name": "pPLMZ",
            "baseName": "pPLMZ",
            "type": "PPLMZ"
        },
        {
            "name": "eeCnZ",
            "baseName": "EeCnZ",
            "type": "EeCnZ"
        },
        {
            "name": "pe4MW",
            "baseName": "pe4MW",
            "type": "Pe4MW"
        },
        {
            "name": "oN6yL",
            "baseName": "oN6yL",
            "type": "ON6yL"
        },
        {
            "name": "dowO0g",
            "baseName": "dowO0g",
            "type": "DowO0g"
        },
        {
            "name": "yA0R2P",
            "baseName": "yA0R2P",
            "type": "YA0R2P"
        },
        {
            "name": "lJZ1p3",
            "baseName": "LJZ1p3",
            "type": "LJZ1p3"
        },
        {
            "name": "wkMd2g",
            "baseName": "wkMd2g",
            "type": "WkMd2g"
        },
        {
            "name": "_3x42x2",
            "baseName": "3x42x2",
            "type": "Model3x42x2"
        },
        {
            "name": "lWn0vG",
            "baseName": "lWn0vG",
            "type": "LWn0vG"
        }    ];

    static getAttributeTypeMap() {
        return Permissions.attributeTypeMap;
    }
}

export class Permissions1 {
    'g2MB3M': G2MB3M;
    'wk6N3K': Wk6N3K;
    '_85lLQg': Model85lLQg;
    'wkMd2g': WkMd2g1;
    '_5o0MVd': Model5o0MVd;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "g2MB3M",
            "baseName": "G2MB3M",
            "type": "G2MB3M"
        },
        {
            "name": "wk6N3K",
            "baseName": "wk6N3K",
            "type": "Wk6N3K"
        },
        {
            "name": "_85lLQg",
            "baseName": "85lLQg",
            "type": "Model85lLQg"
        },
        {
            "name": "wkMd2g",
            "baseName": "wkMd2g",
            "type": "WkMd2g1"
        },
        {
            "name": "_5o0MVd",
            "baseName": "5o0MVd",
            "type": "Model5o0MVd"
        }    ];

    static getAttributeTypeMap() {
        return Permissions1.attributeTypeMap;
    }
}

export class PhoneNumber {
    'title': string;
    'phoneNumber': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "phoneNumber",
            "baseName": "phone_number",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PhoneNumber.attributeTypeMap;
    }
}

export class PhoneNumber1 {
    'id'?: number;
    'phoneNumber'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "phoneNumber",
            "baseName": "phone_number",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PhoneNumber1.attributeTypeMap;
    }
}

export class Presentation {
    'dateFormat': string;
    'descriptionHeading': string;
    'hoursHeading': string;
    'imageBannerPositionY': number;
    'imageBannerSrc': string;
    'imageLogoSrc': string;
    'invoiceid': number;
    'itemHeading': string;
    'label': string;
    'quantityHeading': string;
    'rateHeading': string;
    'taskHeading': string;
    'themeFontName': string;
    'themeLayout': string;
    'themePrimaryColor': string;
    'timeEntryNotesHeading': string;
    'unitCostHeading': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "dateFormat",
            "baseName": "date_format",
            "type": "string"
        },
        {
            "name": "descriptionHeading",
            "baseName": "description_heading",
            "type": "string"
        },
        {
            "name": "hoursHeading",
            "baseName": "hours_heading",
            "type": "string"
        },
        {
            "name": "imageBannerPositionY",
            "baseName": "image_banner_position_y",
            "type": "number"
        },
        {
            "name": "imageBannerSrc",
            "baseName": "image_banner_src",
            "type": "string"
        },
        {
            "name": "imageLogoSrc",
            "baseName": "image_logo_src",
            "type": "string"
        },
        {
            "name": "invoiceid",
            "baseName": "invoiceid",
            "type": "number"
        },
        {
            "name": "itemHeading",
            "baseName": "item_heading",
            "type": "string"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        },
        {
            "name": "quantityHeading",
            "baseName": "quantity_heading",
            "type": "string"
        },
        {
            "name": "rateHeading",
            "baseName": "rate_heading",
            "type": "string"
        },
        {
            "name": "taskHeading",
            "baseName": "task_heading",
            "type": "string"
        },
        {
            "name": "themeFontName",
            "baseName": "theme_font_name",
            "type": "string"
        },
        {
            "name": "themeLayout",
            "baseName": "theme_layout",
            "type": "string"
        },
        {
            "name": "themePrimaryColor",
            "baseName": "theme_primary_color",
            "type": "string"
        },
        {
            "name": "timeEntryNotesHeading",
            "baseName": "time_entry_notes_heading",
            "type": "string"
        },
        {
            "name": "unitCostHeading",
            "baseName": "unit_cost_heading",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Presentation.attributeTypeMap;
    }
}

export class Presentation1 {
    'dateFormat': string;
    'descriptionHeading': string;
    'hoursHeading': string;
    'imageBannerPositionY': number;
    'imageBannerSrc': string;
    'imageLogoSrc': string;
    'invoiceid': number;
    'itemHeading': string;
    'label': string;
    'quantityHeading': string;
    'rateHeading': string;
    'taskHeading': string;
    'themeFontName': string;
    'themeLayout': string;
    'themePrimaryColor': string;
    'timeEntryNotesHeading': string;
    'unitCostHeading': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "dateFormat",
            "baseName": "date_format",
            "type": "string"
        },
        {
            "name": "descriptionHeading",
            "baseName": "description_heading",
            "type": "string"
        },
        {
            "name": "hoursHeading",
            "baseName": "hours_heading",
            "type": "string"
        },
        {
            "name": "imageBannerPositionY",
            "baseName": "image_banner_position_y",
            "type": "number"
        },
        {
            "name": "imageBannerSrc",
            "baseName": "image_banner_src",
            "type": "string"
        },
        {
            "name": "imageLogoSrc",
            "baseName": "image_logo_src",
            "type": "string"
        },
        {
            "name": "invoiceid",
            "baseName": "invoiceid",
            "type": "number"
        },
        {
            "name": "itemHeading",
            "baseName": "item_heading",
            "type": "string"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        },
        {
            "name": "quantityHeading",
            "baseName": "quantity_heading",
            "type": "string"
        },
        {
            "name": "rateHeading",
            "baseName": "rate_heading",
            "type": "string"
        },
        {
            "name": "taskHeading",
            "baseName": "task_heading",
            "type": "string"
        },
        {
            "name": "themeFontName",
            "baseName": "theme_font_name",
            "type": "string"
        },
        {
            "name": "themeLayout",
            "baseName": "theme_layout",
            "type": "string"
        },
        {
            "name": "themePrimaryColor",
            "baseName": "theme_primary_color",
            "type": "string"
        },
        {
            "name": "timeEntryNotesHeading",
            "baseName": "time_entry_notes_heading",
            "type": "string"
        },
        {
            "name": "unitCostHeading",
            "baseName": "unit_cost_heading",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Presentation1.attributeTypeMap;
    }
}

export class Pricing {
    'achTier3': string;
    'percentAmex': string;
    'percentNonAmexWithCard': string;
    'percentNonAmex': string;
    'percentVirtualTerminal': string;
    'percentAmexWithCard': string;
    'achTier1': string;
    'achTier2': string;
    'tierId': number;
    'perTransactionFee': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "achTier3",
            "baseName": "ach_tier_3",
            "type": "string"
        },
        {
            "name": "percentAmex",
            "baseName": "percent_amex",
            "type": "string"
        },
        {
            "name": "percentNonAmexWithCard",
            "baseName": "percent_non_amex_with_card",
            "type": "string"
        },
        {
            "name": "percentNonAmex",
            "baseName": "percent_non_amex",
            "type": "string"
        },
        {
            "name": "percentVirtualTerminal",
            "baseName": "percent_virtual_terminal",
            "type": "string"
        },
        {
            "name": "percentAmexWithCard",
            "baseName": "percent_amex_with_card",
            "type": "string"
        },
        {
            "name": "achTier1",
            "baseName": "ach_tier_1",
            "type": "string"
        },
        {
            "name": "achTier2",
            "baseName": "ach_tier_2",
            "type": "string"
        },
        {
            "name": "tierId",
            "baseName": "tier_id",
            "type": "number"
        },
        {
            "name": "perTransactionFee",
            "baseName": "per_transaction_fee",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Pricing.attributeTypeMap;
    }
}

export class Profession {
    'id': number;
    'businessId': string;
    'title': string;
    'company': string;
    'designation': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "businessId",
            "baseName": "business_id",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "company",
            "baseName": "company",
            "type": "string"
        },
        {
            "name": "designation",
            "baseName": "designation",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Profession.attributeTypeMap;
    }
}

export class Profession2 {
    'id': number;
    'businessId': number;
    'title': string;
    'company': string;
    'designation': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "businessId",
            "baseName": "business_id",
            "type": "number"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "company",
            "baseName": "company",
            "type": "string"
        },
        {
            "name": "designation",
            "baseName": "designation",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Profession2.attributeTypeMap;
    }
}

export class Profile {
    'setupComplete': boolean;
    'firstName': string;
    'lastName': string;
    'phoneNumber': string;
    'address': string;
    'professions': Array<Profession>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "setupComplete",
            "baseName": "setup_complete",
            "type": "boolean"
        },
        {
            "name": "firstName",
            "baseName": "first_name",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "last_name",
            "type": "string"
        },
        {
            "name": "phoneNumber",
            "baseName": "phone_number",
            "type": "string"
        },
        {
            "name": "address",
            "baseName": "address",
            "type": "string"
        },
        {
            "name": "professions",
            "baseName": "professions",
            "type": "Array<Profession>"
        }    ];

    static getAttributeTypeMap() {
        return Profile.attributeTypeMap;
    }
}

export class Profile1 {
    'setupComplete': boolean;
    'firstName': string;
    'lastName': string;
    'phoneNumber': string;
    'address': string;
    'professions': Array<Profession2>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "setupComplete",
            "baseName": "setup_complete",
            "type": "boolean"
        },
        {
            "name": "firstName",
            "baseName": "first_name",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "last_name",
            "type": "string"
        },
        {
            "name": "phoneNumber",
            "baseName": "phone_number",
            "type": "string"
        },
        {
            "name": "address",
            "baseName": "address",
            "type": "string"
        },
        {
            "name": "professions",
            "baseName": "professions",
            "type": "Array<Profession2>"
        }    ];

    static getAttributeTypeMap() {
        return Profile1.attributeTypeMap;
    }
}

export class ProfitLossReport {
    'response': Response68;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Response68"
        }    ];

    static getAttributeTypeMap() {
        return ProfitLossReport.attributeTypeMap;
    }
}

export class Profitloss {
    'cashBased': boolean;
    'companyName': string;
    'currencyCode': string;
    'downloadToken': string;
    'endDate': string;
    'expenses': Array<Expense9>;
    'income': Array<Income>;
    'labels': Array<string>;
    'netProfit': NetProfit;
    'resolution': string;
    'startDate': string;
    'totalExpenses': TotalExpenses;
    'totalIncome': TotalIncome;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cashBased",
            "baseName": "cash_based",
            "type": "boolean"
        },
        {
            "name": "companyName",
            "baseName": "company_name",
            "type": "string"
        },
        {
            "name": "currencyCode",
            "baseName": "currency_code",
            "type": "string"
        },
        {
            "name": "downloadToken",
            "baseName": "download_token",
            "type": "string"
        },
        {
            "name": "endDate",
            "baseName": "end_date",
            "type": "string"
        },
        {
            "name": "expenses",
            "baseName": "expenses",
            "type": "Array<Expense9>"
        },
        {
            "name": "income",
            "baseName": "income",
            "type": "Array<Income>"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "Array<string>"
        },
        {
            "name": "netProfit",
            "baseName": "net_profit",
            "type": "NetProfit"
        },
        {
            "name": "resolution",
            "baseName": "resolution",
            "type": "string"
        },
        {
            "name": "startDate",
            "baseName": "start_date",
            "type": "string"
        },
        {
            "name": "totalExpenses",
            "baseName": "total_expenses",
            "type": "TotalExpenses"
        },
        {
            "name": "totalIncome",
            "baseName": "total_income",
            "type": "TotalIncome"
        }    ];

    static getAttributeTypeMap() {
        return Profitloss.attributeTypeMap;
    }
}

export class Project {
    'id': number;
    'title': string;
    'description': string;
    'dueDate': string;
    'clientId': number;
    'internal': boolean;
    'budget': string;
    'fixedPrice': string;
    'rate': string;
    'billingMethod': string;
    'projectType': string;
    'active': boolean;
    'complete': boolean;
    'sample': boolean;
    'createdAt': string;
    'updatedAt': string;
    'loggedDuration': string;
    'services': Array<Service>;
    'billedAmount': string;
    'billedStatus': string;
    'retainerId': string;
    'group': Group2;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "dueDate",
            "baseName": "due_date",
            "type": "string"
        },
        {
            "name": "clientId",
            "baseName": "client_id",
            "type": "number"
        },
        {
            "name": "internal",
            "baseName": "internal",
            "type": "boolean"
        },
        {
            "name": "budget",
            "baseName": "budget",
            "type": "string"
        },
        {
            "name": "fixedPrice",
            "baseName": "fixed_price",
            "type": "string"
        },
        {
            "name": "rate",
            "baseName": "rate",
            "type": "string"
        },
        {
            "name": "billingMethod",
            "baseName": "billing_method",
            "type": "string"
        },
        {
            "name": "projectType",
            "baseName": "project_type",
            "type": "string"
        },
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "complete",
            "baseName": "complete",
            "type": "boolean"
        },
        {
            "name": "sample",
            "baseName": "sample",
            "type": "boolean"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        },
        {
            "name": "loggedDuration",
            "baseName": "logged_duration",
            "type": "string"
        },
        {
            "name": "services",
            "baseName": "services",
            "type": "Array<Service>"
        },
        {
            "name": "billedAmount",
            "baseName": "billed_amount",
            "type": "string"
        },
        {
            "name": "billedStatus",
            "baseName": "billed_status",
            "type": "string"
        },
        {
            "name": "retainerId",
            "baseName": "retainer_id",
            "type": "string"
        },
        {
            "name": "group",
            "baseName": "group",
            "type": "Group2"
        }    ];

    static getAttributeTypeMap() {
        return Project.attributeTypeMap;
    }
}

export class Project1 {
    'id': number;
    'title': string;
    'description': string;
    'dueDate': string;
    'clientId': number;
    'internal': boolean;
    'budget': string;
    'fixedPrice': string;
    'rate': string;
    'billingMethod': string;
    'projectType': string;
    'active': boolean;
    'complete': boolean;
    'sample': boolean;
    'createdAt': string;
    'updatedAt': string;
    'loggedDuration': string;
    'services': Array<Service1>;
    'billedAmount': string;
    'billedStatus': string;
    'groupId': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "dueDate",
            "baseName": "due_date",
            "type": "string"
        },
        {
            "name": "clientId",
            "baseName": "client_id",
            "type": "number"
        },
        {
            "name": "internal",
            "baseName": "internal",
            "type": "boolean"
        },
        {
            "name": "budget",
            "baseName": "budget",
            "type": "string"
        },
        {
            "name": "fixedPrice",
            "baseName": "fixed_price",
            "type": "string"
        },
        {
            "name": "rate",
            "baseName": "rate",
            "type": "string"
        },
        {
            "name": "billingMethod",
            "baseName": "billing_method",
            "type": "string"
        },
        {
            "name": "projectType",
            "baseName": "project_type",
            "type": "string"
        },
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "complete",
            "baseName": "complete",
            "type": "boolean"
        },
        {
            "name": "sample",
            "baseName": "sample",
            "type": "boolean"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        },
        {
            "name": "loggedDuration",
            "baseName": "logged_duration",
            "type": "string"
        },
        {
            "name": "services",
            "baseName": "services",
            "type": "Array<Service1>"
        },
        {
            "name": "billedAmount",
            "baseName": "billed_amount",
            "type": "string"
        },
        {
            "name": "billedStatus",
            "baseName": "billed_status",
            "type": "string"
        },
        {
            "name": "groupId",
            "baseName": "group_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Project1.attributeTypeMap;
    }
}

export class Project2 {
    'id': number;
    'title': string;
    'description': string;
    'dueDate': string;
    'clientId': number;
    'internal': boolean;
    'budget': string;
    'fixedPrice': string;
    'rate': string;
    'billingMethod': string;
    'projectType': string;
    'active': boolean;
    'complete': boolean;
    'sample': boolean;
    'createdAt': string;
    'updatedAt': string;
    'loggedDuration': string;
    'services': Array<string>;
    'billedAmount': string;
    'billedStatus': string;
    'retainerId': string;
    'group': Group3;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "dueDate",
            "baseName": "due_date",
            "type": "string"
        },
        {
            "name": "clientId",
            "baseName": "client_id",
            "type": "number"
        },
        {
            "name": "internal",
            "baseName": "internal",
            "type": "boolean"
        },
        {
            "name": "budget",
            "baseName": "budget",
            "type": "string"
        },
        {
            "name": "fixedPrice",
            "baseName": "fixed_price",
            "type": "string"
        },
        {
            "name": "rate",
            "baseName": "rate",
            "type": "string"
        },
        {
            "name": "billingMethod",
            "baseName": "billing_method",
            "type": "string"
        },
        {
            "name": "projectType",
            "baseName": "project_type",
            "type": "string"
        },
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "complete",
            "baseName": "complete",
            "type": "boolean"
        },
        {
            "name": "sample",
            "baseName": "sample",
            "type": "boolean"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        },
        {
            "name": "loggedDuration",
            "baseName": "logged_duration",
            "type": "string"
        },
        {
            "name": "services",
            "baseName": "services",
            "type": "Array<string>"
        },
        {
            "name": "billedAmount",
            "baseName": "billed_amount",
            "type": "string"
        },
        {
            "name": "billedStatus",
            "baseName": "billed_status",
            "type": "string"
        },
        {
            "name": "retainerId",
            "baseName": "retainer_id",
            "type": "string"
        },
        {
            "name": "group",
            "baseName": "group",
            "type": "Group3"
        }    ];

    static getAttributeTypeMap() {
        return Project2.attributeTypeMap;
    }
}

export class Project3 {
    'id': number;
    'title': string;
    'description': string;
    'dueDate': string;
    'clientId': number;
    'internal': boolean;
    'budget': string;
    'fixedPrice': string;
    'rate': string;
    'billingMethod': string;
    'projectType': string;
    'active': boolean;
    'complete': boolean;
    'sample': boolean;
    'createdAt': string;
    'updatedAt': string;
    'loggedDuration': string;
    'services': Array<string>;
    'billedAmount': string;
    'billedStatus': string;
    'retainerId': string;
    'group': Group2;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "dueDate",
            "baseName": "due_date",
            "type": "string"
        },
        {
            "name": "clientId",
            "baseName": "client_id",
            "type": "number"
        },
        {
            "name": "internal",
            "baseName": "internal",
            "type": "boolean"
        },
        {
            "name": "budget",
            "baseName": "budget",
            "type": "string"
        },
        {
            "name": "fixedPrice",
            "baseName": "fixed_price",
            "type": "string"
        },
        {
            "name": "rate",
            "baseName": "rate",
            "type": "string"
        },
        {
            "name": "billingMethod",
            "baseName": "billing_method",
            "type": "string"
        },
        {
            "name": "projectType",
            "baseName": "project_type",
            "type": "string"
        },
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "complete",
            "baseName": "complete",
            "type": "boolean"
        },
        {
            "name": "sample",
            "baseName": "sample",
            "type": "boolean"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        },
        {
            "name": "loggedDuration",
            "baseName": "logged_duration",
            "type": "string"
        },
        {
            "name": "services",
            "baseName": "services",
            "type": "Array<string>"
        },
        {
            "name": "billedAmount",
            "baseName": "billed_amount",
            "type": "string"
        },
        {
            "name": "billedStatus",
            "baseName": "billed_status",
            "type": "string"
        },
        {
            "name": "retainerId",
            "baseName": "retainer_id",
            "type": "string"
        },
        {
            "name": "group",
            "baseName": "group",
            "type": "Group2"
        }    ];

    static getAttributeTypeMap() {
        return Project3.attributeTypeMap;
    }
}

export class Project4 {
    'visState': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "visState",
            "baseName": "vis_state",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Project4.attributeTypeMap;
    }
}

export class ProjectServiceRate {
    'rate': number;
    'serviceId': string;
    'projectId': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "rate",
            "baseName": "rate",
            "type": "number"
        },
        {
            "name": "serviceId",
            "baseName": "service_id",
            "type": "string"
        },
        {
            "name": "projectId",
            "baseName": "project_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ProjectServiceRate.attributeTypeMap;
    }
}

export class ProjectServiceRate1 {
    'rate': string;
    'serviceId': number;
    'businessId': number;
    'projectId': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "rate",
            "baseName": "rate",
            "type": "string"
        },
        {
            "name": "serviceId",
            "baseName": "service_id",
            "type": "number"
        },
        {
            "name": "businessId",
            "baseName": "business_id",
            "type": "number"
        },
        {
            "name": "projectId",
            "baseName": "project_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ProjectServiceRate1.attributeTypeMap;
    }
}

export class ProvisionFreshBooksPaymentsRequest {
    'fname': string;
    'lname': string;
    'email': string;
    'orgname': string;
    'redirectBaseUri': string;
    'country': string;
    'allowMultipleProvision': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "fname",
            "baseName": "fname",
            "type": "string"
        },
        {
            "name": "lname",
            "baseName": "lname",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "orgname",
            "baseName": "orgname",
            "type": "string"
        },
        {
            "name": "redirectBaseUri",
            "baseName": "redirect_base_uri",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "allowMultipleProvision",
            "baseName": "allow_multiple_provision",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return ProvisionFreshBooksPaymentsRequest.attributeTypeMap;
    }
}

export class RAlTo {
    'advancedAccountingAccess': boolean;
    'advancedPaymentsAccess': boolean;
    'autoBankImportAccess': boolean;
    'autobillLimit': number;
    'bankImportAccess': boolean;
    'clientLimit': number;
    'documentLimit': number;
    'editSubjectLineAccess': boolean;
    'lateFeeAccess': boolean;
    'lateReminderAccess': boolean;
    'paymentsFeesReportAccess': boolean;
    'recurringRevenueReportAccess': boolean;
    'removeBrandingAccess': boolean;
    'staffLimit': number;
    'businessAccountantLimit': number;
    'onboardingChecklistAccess': boolean;
    'betaHeliosAsyncExpensesAccess': boolean;
    'betaMobileCreateExpenseSubcategoryAccess': boolean;
    'iosBetaZendeskWidgetAccess': boolean;
    'mobileReceiptRebillingAccess': boolean;
    'heliosPushnotificationsBetaAccess': boolean;
    'iosBetaPaymentSchedulesAccess': boolean;
    'heliosRebillTimeAccess': boolean;
    'esignaturesAccess': boolean;
    'heliosDashboardAccess': boolean;
    'heliosLateFeeReminderBetaAccess': boolean;
    'heliosBulkActionsInvoicesBetaAccess': boolean;
    'heliosVirtualTerminalBetaAccess': boolean;
    'heliosExpenseRebillingBetaAccess': boolean;
    'heliosCompanyTaxesBetaAccess': boolean;
    'heliosInvoiceArchiveBetaAccess': boolean;
    'accountantInviteAccess': boolean;
    'heliosSyncThrottleBetaAccess': boolean;
    'bankReconciliationAccess': boolean;
    'heliosPushResourceToUseExecuteBetaAccess': boolean;
    'newTimeTrackingAccess': boolean;
    'bankRecSmartMatchAccess': boolean;
    'balanceSheetAccess': boolean;
    'invoiceV2SearchAccess': boolean;
    'importItemsCsvAccess': boolean;
    'exportClientsCsvAccess': boolean;
    'heliosVirtualTerminalTutorialBetaAccess': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "advancedAccountingAccess",
            "baseName": "advanced_accounting.access",
            "type": "boolean"
        },
        {
            "name": "advancedPaymentsAccess",
            "baseName": "advanced_payments.access",
            "type": "boolean"
        },
        {
            "name": "autoBankImportAccess",
            "baseName": "auto_bank_import.access",
            "type": "boolean"
        },
        {
            "name": "autobillLimit",
            "baseName": "autobill.limit",
            "type": "number"
        },
        {
            "name": "bankImportAccess",
            "baseName": "bank_import.access",
            "type": "boolean"
        },
        {
            "name": "clientLimit",
            "baseName": "client.limit",
            "type": "number"
        },
        {
            "name": "documentLimit",
            "baseName": "document.limit",
            "type": "number"
        },
        {
            "name": "editSubjectLineAccess",
            "baseName": "edit_subject_line.access",
            "type": "boolean"
        },
        {
            "name": "lateFeeAccess",
            "baseName": "late_fee.access",
            "type": "boolean"
        },
        {
            "name": "lateReminderAccess",
            "baseName": "late_reminder.access",
            "type": "boolean"
        },
        {
            "name": "paymentsFeesReportAccess",
            "baseName": "payments_fees_report.access",
            "type": "boolean"
        },
        {
            "name": "recurringRevenueReportAccess",
            "baseName": "recurring_revenue_report.access",
            "type": "boolean"
        },
        {
            "name": "removeBrandingAccess",
            "baseName": "remove_branding.access",
            "type": "boolean"
        },
        {
            "name": "staffLimit",
            "baseName": "staff.limit",
            "type": "number"
        },
        {
            "name": "businessAccountantLimit",
            "baseName": "business_accountant.limit",
            "type": "number"
        },
        {
            "name": "onboardingChecklistAccess",
            "baseName": "onboarding_checklist.access",
            "type": "boolean"
        },
        {
            "name": "betaHeliosAsyncExpensesAccess",
            "baseName": "BetaHeliosAsyncExpenses.access",
            "type": "boolean"
        },
        {
            "name": "betaMobileCreateExpenseSubcategoryAccess",
            "baseName": "beta_mobile_create_expense_subcategory.access",
            "type": "boolean"
        },
        {
            "name": "iosBetaZendeskWidgetAccess",
            "baseName": "ios_beta_zendesk_widget.access",
            "type": "boolean"
        },
        {
            "name": "mobileReceiptRebillingAccess",
            "baseName": "mobile_receipt_rebilling.access",
            "type": "boolean"
        },
        {
            "name": "heliosPushnotificationsBetaAccess",
            "baseName": "helios_pushnotifications.beta.access",
            "type": "boolean"
        },
        {
            "name": "iosBetaPaymentSchedulesAccess",
            "baseName": "ios_beta_payment_schedules.access",
            "type": "boolean"
        },
        {
            "name": "heliosRebillTimeAccess",
            "baseName": "helios_rebill_time.access",
            "type": "boolean"
        },
        {
            "name": "esignaturesAccess",
            "baseName": "esignatures.access",
            "type": "boolean"
        },
        {
            "name": "heliosDashboardAccess",
            "baseName": "helios_dashboard.access",
            "type": "boolean"
        },
        {
            "name": "heliosLateFeeReminderBetaAccess",
            "baseName": "helios_late_fee_reminder.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosBulkActionsInvoicesBetaAccess",
            "baseName": "helios_bulk_actions_invoices.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosVirtualTerminalBetaAccess",
            "baseName": "helios_virtual_terminal.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosExpenseRebillingBetaAccess",
            "baseName": "helios_expense_rebilling.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosCompanyTaxesBetaAccess",
            "baseName": "helios_company_taxes.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosInvoiceArchiveBetaAccess",
            "baseName": "helios_invoice_archive.beta.access",
            "type": "boolean"
        },
        {
            "name": "accountantInviteAccess",
            "baseName": "accountant_invite.access",
            "type": "boolean"
        },
        {
            "name": "heliosSyncThrottleBetaAccess",
            "baseName": "helios_sync_throttle.beta.access",
            "type": "boolean"
        },
        {
            "name": "bankReconciliationAccess",
            "baseName": "BankReconciliation.access",
            "type": "boolean"
        },
        {
            "name": "heliosPushResourceToUseExecuteBetaAccess",
            "baseName": "helios_push_resource_to_use_execute.beta.access",
            "type": "boolean"
        },
        {
            "name": "newTimeTrackingAccess",
            "baseName": "new_time_tracking.access",
            "type": "boolean"
        },
        {
            "name": "bankRecSmartMatchAccess",
            "baseName": "bank_rec_smart_match.access",
            "type": "boolean"
        },
        {
            "name": "balanceSheetAccess",
            "baseName": "balance_sheet.access",
            "type": "boolean"
        },
        {
            "name": "invoiceV2SearchAccess",
            "baseName": "invoice_v2_search.access",
            "type": "boolean"
        },
        {
            "name": "importItemsCsvAccess",
            "baseName": "import_items_csv.access",
            "type": "boolean"
        },
        {
            "name": "exportClientsCsvAccess",
            "baseName": "export_clients_csv.access",
            "type": "boolean"
        },
        {
            "name": "heliosVirtualTerminalTutorialBetaAccess",
            "baseName": "helios_virtual_terminal_tutorial.beta.access",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return RAlTo.attributeTypeMap;
    }
}

export class Rate {
    'amount': string;
    'code': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "string"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Rate.attributeTypeMap;
    }
}

export class RegisterasanewuserRequest {
    'id': string;
    'companyName': string;
    'email': string;
    'password': string;
    'country': string;
    'currencyCode': string;
    'accessToken': string;
    'directBuy': boolean;
    'skipSystem': boolean;
    'skipBusiness': boolean;
    'sendConfirmationNotification': boolean;
    'capacity': string;
    'provisioner': string;
    'referringUrl': string;
    'landingUrl': string;
    'referralid': string;
    'webPromo': string;
    'visitorId': string;
    'optimizelyUserId': string;
    'optimizelyBuckets': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "companyName",
            "baseName": "company_name",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "password",
            "baseName": "password",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "currencyCode",
            "baseName": "currencyCode",
            "type": "string"
        },
        {
            "name": "accessToken",
            "baseName": "access_token",
            "type": "string"
        },
        {
            "name": "directBuy",
            "baseName": "direct_buy",
            "type": "boolean"
        },
        {
            "name": "skipSystem",
            "baseName": "skip_system",
            "type": "boolean"
        },
        {
            "name": "skipBusiness",
            "baseName": "skip_business",
            "type": "boolean"
        },
        {
            "name": "sendConfirmationNotification",
            "baseName": "send_confirmation_notification",
            "type": "boolean"
        },
        {
            "name": "capacity",
            "baseName": "capacity",
            "type": "string"
        },
        {
            "name": "provisioner",
            "baseName": "provisioner",
            "type": "string"
        },
        {
            "name": "referringUrl",
            "baseName": "referring_url",
            "type": "string"
        },
        {
            "name": "landingUrl",
            "baseName": "landing_url",
            "type": "string"
        },
        {
            "name": "referralid",
            "baseName": "referralid",
            "type": "string"
        },
        {
            "name": "webPromo",
            "baseName": "web_promo",
            "type": "string"
        },
        {
            "name": "visitorId",
            "baseName": "visitor_id",
            "type": "string"
        },
        {
            "name": "optimizelyUserId",
            "baseName": "optimizely_user_id",
            "type": "string"
        },
        {
            "name": "optimizelyBuckets",
            "baseName": "optimizely_buckets",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RegisterasanewuserRequest.attributeTypeMap;
    }
}

export class RegisterforCallbackRequest {
    'callback': Callback;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "callback",
            "baseName": "callback",
            "type": "Callback"
        }    ];

    static getAttributeTypeMap() {
        return RegisterforCallbackRequest.attributeTypeMap;
    }
}

export class RemoveAllSecondaryContactsRequest {
    'client': Client6;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "client",
            "baseName": "client",
            "type": "Client6"
        }    ];

    static getAttributeTypeMap() {
        return RemoveAllSecondaryContactsRequest.attributeTypeMap;
    }
}

export class ResendVerificationCodeRequest {
    'callback': Callback1;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "callback",
            "baseName": "callback",
            "type": "Callback1"
        }    ];

    static getAttributeTypeMap() {
        return ResendVerificationCodeRequest.attributeTypeMap;
    }
}

export class Response {
    'id': number;
    'profile': Profile;
    'firstName': string;
    'lastName': string;
    'email': string;
    'language': string;
    'confirmedAt': string;
    'createdAt': string;
    'unconfirmedEmail': string;
    'setupComplete': boolean;
    'phoneNumbers': Array<PhoneNumber>;
    'addresses': Array<string>;
    'profession': Profession;
    'links': Links;
    'permissions': Permissions;
    'groups': Array<Group>;
    'subscriptionStatuses': SubscriptionStatuses;
    'integrations': any;
    'businessMemberships': Array<BusinessMembership>;
    'identityOrigin': string;
    'roles': Array<Role>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "profile",
            "baseName": "profile",
            "type": "Profile"
        },
        {
            "name": "firstName",
            "baseName": "first_name",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "last_name",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "language",
            "baseName": "language",
            "type": "string"
        },
        {
            "name": "confirmedAt",
            "baseName": "confirmed_at",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "unconfirmedEmail",
            "baseName": "unconfirmed_email",
            "type": "string"
        },
        {
            "name": "setupComplete",
            "baseName": "setup_complete",
            "type": "boolean"
        },
        {
            "name": "phoneNumbers",
            "baseName": "phone_numbers",
            "type": "Array<PhoneNumber>"
        },
        {
            "name": "addresses",
            "baseName": "addresses",
            "type": "Array<string>"
        },
        {
            "name": "profession",
            "baseName": "profession",
            "type": "Profession"
        },
        {
            "name": "links",
            "baseName": "links",
            "type": "Links"
        },
        {
            "name": "permissions",
            "baseName": "permissions",
            "type": "Permissions"
        },
        {
            "name": "groups",
            "baseName": "groups",
            "type": "Array<Group>"
        },
        {
            "name": "subscriptionStatuses",
            "baseName": "subscription_statuses",
            "type": "SubscriptionStatuses"
        },
        {
            "name": "integrations",
            "baseName": "integrations",
            "type": "any"
        },
        {
            "name": "businessMemberships",
            "baseName": "business_memberships",
            "type": "Array<BusinessMembership>"
        },
        {
            "name": "identityOrigin",
            "baseName": "identity_origin",
            "type": "string"
        },
        {
            "name": "roles",
            "baseName": "roles",
            "type": "Array<Role>"
        }    ];

    static getAttributeTypeMap() {
        return Response.attributeTypeMap;
    }
}

export class Response1 {
    'id': number;
    'profile': Profile1;
    'firstName': string;
    'lastName': string;
    'email': string;
    'language': string;
    'confirmedAt': string;
    'createdAt': string;
    'unconfirmedEmail': string;
    'setupComplete': boolean;
    'phoneNumbers': Array<PhoneNumber>;
    'addresses': Array<string>;
    'profession': Profession2;
    'links': Links;
    'permissions': Permissions1;
    'groups': Array<Group>;
    'subscriptionStatuses': SubscriptionStatuses1;
    'integrations': any;
    'businessMemberships': Array<BusinessMembership1>;
    'identityOrigin': string;
    'roles': Array<Role>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "profile",
            "baseName": "profile",
            "type": "Profile1"
        },
        {
            "name": "firstName",
            "baseName": "first_name",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "last_name",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "language",
            "baseName": "language",
            "type": "string"
        },
        {
            "name": "confirmedAt",
            "baseName": "confirmed_at",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "unconfirmedEmail",
            "baseName": "unconfirmed_email",
            "type": "string"
        },
        {
            "name": "setupComplete",
            "baseName": "setup_complete",
            "type": "boolean"
        },
        {
            "name": "phoneNumbers",
            "baseName": "phone_numbers",
            "type": "Array<PhoneNumber>"
        },
        {
            "name": "addresses",
            "baseName": "addresses",
            "type": "Array<string>"
        },
        {
            "name": "profession",
            "baseName": "profession",
            "type": "Profession2"
        },
        {
            "name": "links",
            "baseName": "links",
            "type": "Links"
        },
        {
            "name": "permissions",
            "baseName": "permissions",
            "type": "Permissions1"
        },
        {
            "name": "groups",
            "baseName": "groups",
            "type": "Array<Group>"
        },
        {
            "name": "subscriptionStatuses",
            "baseName": "subscription_statuses",
            "type": "SubscriptionStatuses1"
        },
        {
            "name": "integrations",
            "baseName": "integrations",
            "type": "any"
        },
        {
            "name": "businessMemberships",
            "baseName": "business_memberships",
            "type": "Array<BusinessMembership1>"
        },
        {
            "name": "identityOrigin",
            "baseName": "identity_origin",
            "type": "string"
        },
        {
            "name": "roles",
            "baseName": "roles",
            "type": "Array<Role>"
        }    ];

    static getAttributeTypeMap() {
        return Response1.attributeTypeMap;
    }
}

export class Response12 {
    'result': Result9;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "result",
            "baseName": "result",
            "type": "Result9"
        }    ];

    static getAttributeTypeMap() {
        return Response12.attributeTypeMap;
    }
}

export class Response13 {
    'result': Result10;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "result",
            "baseName": "result",
            "type": "Result10"
        }    ];

    static getAttributeTypeMap() {
        return Response13.attributeTypeMap;
    }
}

export class Response15 {
    'result': Result11;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "result",
            "baseName": "result",
            "type": "Result11"
        }    ];

    static getAttributeTypeMap() {
        return Response15.attributeTypeMap;
    }
}

export class Response18 {
    'result': Result14;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "result",
            "baseName": "result",
            "type": "Result14"
        }    ];

    static getAttributeTypeMap() {
        return Response18.attributeTypeMap;
    }
}

export class Response2 {
    'result': Result;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "result",
            "baseName": "result",
            "type": "Result"
        }    ];

    static getAttributeTypeMap() {
        return Response2.attributeTypeMap;
    }
}

export class Response21 {
    'result': Result16;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "result",
            "baseName": "result",
            "type": "Result16"
        }    ];

    static getAttributeTypeMap() {
        return Response21.attributeTypeMap;
    }
}

export class Response22 {
    'result': Result17;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "result",
            "baseName": "result",
            "type": "Result17"
        }    ];

    static getAttributeTypeMap() {
        return Response22.attributeTypeMap;
    }
}

export class Response23 {
    'result': Result18;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "result",
            "baseName": "result",
            "type": "Result18"
        }    ];

    static getAttributeTypeMap() {
        return Response23.attributeTypeMap;
    }
}

export class Response25 {
    'result': Result20;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "result",
            "baseName": "result",
            "type": "Result20"
        }    ];

    static getAttributeTypeMap() {
        return Response25.attributeTypeMap;
    }
}

export class Response26 {
    'result': Result21;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "result",
            "baseName": "result",
            "type": "Result21"
        }    ];

    static getAttributeTypeMap() {
        return Response26.attributeTypeMap;
    }
}

export class Response27 {
    'result': Result22;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "result",
            "baseName": "result",
            "type": "Result22"
        }    ];

    static getAttributeTypeMap() {
        return Response27.attributeTypeMap;
    }
}

export class Response3 {
    'result': Result1;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "result",
            "baseName": "result",
            "type": "Result1"
        }    ];

    static getAttributeTypeMap() {
        return Response3.attributeTypeMap;
    }
}

export class Response30 {
    'result': Result25;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "result",
            "baseName": "result",
            "type": "Result25"
        }    ];

    static getAttributeTypeMap() {
        return Response30.attributeTypeMap;
    }
}

export class Response31 {
    'result': Result26;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "result",
            "baseName": "result",
            "type": "Result26"
        }    ];

    static getAttributeTypeMap() {
        return Response31.attributeTypeMap;
    }
}

export class Response32 {
    'result': Result27;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "result",
            "baseName": "result",
            "type": "Result27"
        }    ];

    static getAttributeTypeMap() {
        return Response32.attributeTypeMap;
    }
}

export class Response33 {
    'result': Result28;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "result",
            "baseName": "result",
            "type": "Result28"
        }    ];

    static getAttributeTypeMap() {
        return Response33.attributeTypeMap;
    }
}

export class Response34 {
    'result': Result29;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "result",
            "baseName": "result",
            "type": "Result29"
        }    ];

    static getAttributeTypeMap() {
        return Response34.attributeTypeMap;
    }
}

export class Response39 {
    'errors': Array<Error5>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error5>"
        }    ];

    static getAttributeTypeMap() {
        return Response39.attributeTypeMap;
    }
}

export class Response4 {
    'errors': Array<Error>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        }    ];

    static getAttributeTypeMap() {
        return Response4.attributeTypeMap;
    }
}

export class Response42 {
    'result': Result34;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "result",
            "baseName": "result",
            "type": "Result34"
        }    ];

    static getAttributeTypeMap() {
        return Response42.attributeTypeMap;
    }
}

export class Response43 {
    'result': Result35;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "result",
            "baseName": "result",
            "type": "Result35"
        }    ];

    static getAttributeTypeMap() {
        return Response43.attributeTypeMap;
    }
}

export class Response44 {
    'result': Result36;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "result",
            "baseName": "result",
            "type": "Result36"
        }    ];

    static getAttributeTypeMap() {
        return Response44.attributeTypeMap;
    }
}

export class Response45 {
    'result': Result37;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "result",
            "baseName": "result",
            "type": "Result37"
        }    ];

    static getAttributeTypeMap() {
        return Response45.attributeTypeMap;
    }
}

export class Response47 {
    'result': Result39;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "result",
            "baseName": "result",
            "type": "Result39"
        }    ];

    static getAttributeTypeMap() {
        return Response47.attributeTypeMap;
    }
}

export class Response48 {
    'result': Result40;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "result",
            "baseName": "result",
            "type": "Result40"
        }    ];

    static getAttributeTypeMap() {
        return Response48.attributeTypeMap;
    }
}

export class Response49 {
    'result': Result41;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "result",
            "baseName": "result",
            "type": "Result41"
        }    ];

    static getAttributeTypeMap() {
        return Response49.attributeTypeMap;
    }
}

export class Response5 {
    'result': Result2;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "result",
            "baseName": "result",
            "type": "Result2"
        }    ];

    static getAttributeTypeMap() {
        return Response5.attributeTypeMap;
    }
}

export class Response50 {
    'result': Result42;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "result",
            "baseName": "result",
            "type": "Result42"
        }    ];

    static getAttributeTypeMap() {
        return Response50.attributeTypeMap;
    }
}

export class Response52 {
    'result': Result44;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "result",
            "baseName": "result",
            "type": "Result44"
        }    ];

    static getAttributeTypeMap() {
        return Response52.attributeTypeMap;
    }
}

export class Response53 {
    'result': Result45;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "result",
            "baseName": "result",
            "type": "Result45"
        }    ];

    static getAttributeTypeMap() {
        return Response53.attributeTypeMap;
    }
}

export class Response54 {
    'result': Result46;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "result",
            "baseName": "result",
            "type": "Result46"
        }    ];

    static getAttributeTypeMap() {
        return Response54.attributeTypeMap;
    }
}

export class Response58 {
    'result': Result50;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "result",
            "baseName": "result",
            "type": "Result50"
        }    ];

    static getAttributeTypeMap() {
        return Response58.attributeTypeMap;
    }
}

export class Response59 {
    'result': Result51;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "result",
            "baseName": "result",
            "type": "Result51"
        }    ];

    static getAttributeTypeMap() {
        return Response59.attributeTypeMap;
    }
}

export class Response63 {
    'result': Result55;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "result",
            "baseName": "result",
            "type": "Result55"
        }    ];

    static getAttributeTypeMap() {
        return Response63.attributeTypeMap;
    }
}

export class Response64 {
    'id': number;
    'name': string;
    'accountId': string;
    'businessGroup': BusinessGroup;
    'dateFormat': string;
    'address': Address;
    'phoneNumber': string;
    'businessClients': Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "accountId",
            "baseName": "account_id",
            "type": "string"
        },
        {
            "name": "businessGroup",
            "baseName": "business_group",
            "type": "BusinessGroup"
        },
        {
            "name": "dateFormat",
            "baseName": "date_format",
            "type": "string"
        },
        {
            "name": "address",
            "baseName": "address",
            "type": "Address"
        },
        {
            "name": "phoneNumber",
            "baseName": "phone_number",
            "type": "string"
        },
        {
            "name": "businessClients",
            "baseName": "business_clients",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return Response64.attributeTypeMap;
    }
}

export class Response67 {
    'result': Result57;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "result",
            "baseName": "result",
            "type": "Result57"
        }    ];

    static getAttributeTypeMap() {
        return Response67.attributeTypeMap;
    }
}

export class Response68 {
    'result': Result58;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "result",
            "baseName": "result",
            "type": "Result58"
        }    ];

    static getAttributeTypeMap() {
        return Response68.attributeTypeMap;
    }
}

export class Response69 {
    'result': Result59;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "result",
            "baseName": "result",
            "type": "Result59"
        }    ];

    static getAttributeTypeMap() {
        return Response69.attributeTypeMap;
    }
}

export class Response7 {
    'result': Result4;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "result",
            "baseName": "result",
            "type": "Result4"
        }    ];

    static getAttributeTypeMap() {
        return Response7.attributeTypeMap;
    }
}

export class Response70 {
    'result': Result60;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "result",
            "baseName": "result",
            "type": "Result60"
        }    ];

    static getAttributeTypeMap() {
        return Response70.attributeTypeMap;
    }
}

export class Response71 {
    'result': Result61;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "result",
            "baseName": "result",
            "type": "Result61"
        }    ];

    static getAttributeTypeMap() {
        return Response71.attributeTypeMap;
    }
}

export class Response72 {
    'result': Result62;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "result",
            "baseName": "result",
            "type": "Result62"
        }    ];

    static getAttributeTypeMap() {
        return Response72.attributeTypeMap;
    }
}

export class Response73 {
    'result': Result63;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "result",
            "baseName": "result",
            "type": "Result63"
        }    ];

    static getAttributeTypeMap() {
        return Response73.attributeTypeMap;
    }
}

export class Response75 {
    'result': Result64;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "result",
            "baseName": "result",
            "type": "Result64"
        }    ];

    static getAttributeTypeMap() {
        return Response75.attributeTypeMap;
    }
}

export class Response76 {
    'result': Result65;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "result",
            "baseName": "result",
            "type": "Result65"
        }    ];

    static getAttributeTypeMap() {
        return Response76.attributeTypeMap;
    }
}

export class Response77 {
    'result': Result66;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "result",
            "baseName": "result",
            "type": "Result66"
        }    ];

    static getAttributeTypeMap() {
        return Response77.attributeTypeMap;
    }
}

export class Response78 {
    'result': Result67;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "result",
            "baseName": "result",
            "type": "Result67"
        }    ];

    static getAttributeTypeMap() {
        return Response78.attributeTypeMap;
    }
}

export class Response79 {
    'result': Result68;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "result",
            "baseName": "result",
            "type": "Result68"
        }    ];

    static getAttributeTypeMap() {
        return Response79.attributeTypeMap;
    }
}

export class Response84 {
    'result': Result73;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "result",
            "baseName": "result",
            "type": "Result73"
        }    ];

    static getAttributeTypeMap() {
        return Response84.attributeTypeMap;
    }
}

export class Response85 {
    'result': Result74;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "result",
            "baseName": "result",
            "type": "Result74"
        }    ];

    static getAttributeTypeMap() {
        return Response85.attributeTypeMap;
    }
}

export class Response87 {
    'result': Result75;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "result",
            "baseName": "result",
            "type": "Result75"
        }    ];

    static getAttributeTypeMap() {
        return Response87.attributeTypeMap;
    }
}

export class Response89 {
    'result': Result77;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "result",
            "baseName": "result",
            "type": "Result77"
        }    ];

    static getAttributeTypeMap() {
        return Response89.attributeTypeMap;
    }
}

export class Response91 {
    'result': Result78;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "result",
            "baseName": "result",
            "type": "Result78"
        }    ];

    static getAttributeTypeMap() {
        return Response91.attributeTypeMap;
    }
}

export class Result {
    'clients': Array<Client>;
    'page': number;
    'pages': number;
    'perPage': number;
    'total': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "clients",
            "baseName": "clients",
            "type": "Array<Client>"
        },
        {
            "name": "page",
            "baseName": "page",
            "type": "number"
        },
        {
            "name": "pages",
            "baseName": "pages",
            "type": "number"
        },
        {
            "name": "perPage",
            "baseName": "per_page",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Result.attributeTypeMap;
    }
}

export class Result1 {
    'client': Client1;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "client",
            "baseName": "client",
            "type": "Client1"
        }    ];

    static getAttributeTypeMap() {
        return Result1.attributeTypeMap;
    }
}

export class Result10 {
    'invoiceProfile': InvoiceProfile1;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "invoiceProfile",
            "baseName": "invoice_profile",
            "type": "InvoiceProfile1"
        }    ];

    static getAttributeTypeMap() {
        return Result10.attributeTypeMap;
    }
}

export class Result11 {
    'invoiceProfile': InvoiceProfile2;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "invoiceProfile",
            "baseName": "invoice_profile",
            "type": "InvoiceProfile2"
        }    ];

    static getAttributeTypeMap() {
        return Result11.attributeTypeMap;
    }
}

export class Result14 {
    'shareLink': ShareLink1;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "shareLink",
            "baseName": "share_link",
            "type": "ShareLink1"
        }    ];

    static getAttributeTypeMap() {
        return Result14.attributeTypeMap;
    }
}

export class Result16 {
    'otherIncome': Array<OtherIncome>;
    'page': number;
    'pages': number;
    'perPage': number;
    'total': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "otherIncome",
            "baseName": "other_income",
            "type": "Array<OtherIncome>"
        },
        {
            "name": "page",
            "baseName": "page",
            "type": "number"
        },
        {
            "name": "pages",
            "baseName": "pages",
            "type": "number"
        },
        {
            "name": "perPage",
            "baseName": "per_page",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Result16.attributeTypeMap;
    }
}

export class Result17 {
    'otherIncome': OtherIncome2;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "otherIncome",
            "baseName": "other_income",
            "type": "OtherIncome2"
        }    ];

    static getAttributeTypeMap() {
        return Result17.attributeTypeMap;
    }
}

export class Result18 {
    'otherIncome': OtherIncome4;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "otherIncome",
            "baseName": "other_income",
            "type": "OtherIncome4"
        }    ];

    static getAttributeTypeMap() {
        return Result18.attributeTypeMap;
    }
}

export class Result2 {
    'client': Client;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "client",
            "baseName": "client",
            "type": "Client"
        }    ];

    static getAttributeTypeMap() {
        return Result2.attributeTypeMap;
    }
}

export class Result20 {
    'payment': Payment;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "payment",
            "baseName": "payment",
            "type": "Payment"
        }    ];

    static getAttributeTypeMap() {
        return Result20.attributeTypeMap;
    }
}

export class Result21 {
    'page': number;
    'pages': number;
    'payments': Array<Payment>;
    'perPage': number;
    'total': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "page",
            "baseName": "page",
            "type": "number"
        },
        {
            "name": "pages",
            "baseName": "pages",
            "type": "number"
        },
        {
            "name": "payments",
            "baseName": "payments",
            "type": "Array<Payment>"
        },
        {
            "name": "perPage",
            "baseName": "per_page",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Result21.attributeTypeMap;
    }
}

export class Result22 {
    'payment': Payment2;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "payment",
            "baseName": "payment",
            "type": "Payment2"
        }    ];

    static getAttributeTypeMap() {
        return Result22.attributeTypeMap;
    }
}

export class Result25 {
    'invoices': Array<Invoice>;
    'page': number;
    'pages': number;
    'perPage': number;
    'total': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "invoices",
            "baseName": "invoices",
            "type": "Array<Invoice>"
        },
        {
            "name": "page",
            "baseName": "page",
            "type": "number"
        },
        {
            "name": "pages",
            "baseName": "pages",
            "type": "number"
        },
        {
            "name": "perPage",
            "baseName": "per_page",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Result25.attributeTypeMap;
    }
}

export class Result26 {
    'invoice': Invoice1;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "invoice",
            "baseName": "invoice",
            "type": "Invoice1"
        }    ];

    static getAttributeTypeMap() {
        return Result26.attributeTypeMap;
    }
}

export class Result27 {
    'invoice': Invoice2;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "invoice",
            "baseName": "invoice",
            "type": "Invoice2"
        }    ];

    static getAttributeTypeMap() {
        return Result27.attributeTypeMap;
    }
}

export class Result28 {
    'invoice': Invoice3;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "invoice",
            "baseName": "invoice",
            "type": "Invoice3"
        }    ];

    static getAttributeTypeMap() {
        return Result28.attributeTypeMap;
    }
}

export class Result29 {
    'invoice': Invoice4;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "invoice",
            "baseName": "invoice",
            "type": "Invoice4"
        }    ];

    static getAttributeTypeMap() {
        return Result29.attributeTypeMap;
    }
}

export class Result34 {
    'invoice': Invoice12;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "invoice",
            "baseName": "invoice",
            "type": "Invoice12"
        }    ];

    static getAttributeTypeMap() {
        return Result34.attributeTypeMap;
    }
}

export class Result35 {
    'presentation': Presentation1;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "presentation",
            "baseName": "presentation",
            "type": "Presentation1"
        }    ];

    static getAttributeTypeMap() {
        return Result35.attributeTypeMap;
    }
}

export class Result36 {
    'expenses': Array<Expense>;
    'page': number;
    'pages': number;
    'perPage': number;
    'total': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "expenses",
            "baseName": "expenses",
            "type": "Array<Expense>"
        },
        {
            "name": "page",
            "baseName": "page",
            "type": "number"
        },
        {
            "name": "pages",
            "baseName": "pages",
            "type": "number"
        },
        {
            "name": "perPage",
            "baseName": "per_page",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Result36.attributeTypeMap;
    }
}

export class Result37 {
    'expense': Expense2;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "expense",
            "baseName": "expense",
            "type": "Expense2"
        }    ];

    static getAttributeTypeMap() {
        return Result37.attributeTypeMap;
    }
}

export class Result39 {
    'expense': Expense6;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "expense",
            "baseName": "expense",
            "type": "Expense6"
        }    ];

    static getAttributeTypeMap() {
        return Result39.attributeTypeMap;
    }
}

export class Result4 {
    'item': Item;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "item",
            "baseName": "item",
            "type": "Item"
        }    ];

    static getAttributeTypeMap() {
        return Result4.attributeTypeMap;
    }
}

export class Result40 {
    'summaries': Array<Summary>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "summaries",
            "baseName": "summaries",
            "type": "Array<Summary>"
        }    ];

    static getAttributeTypeMap() {
        return Result40.attributeTypeMap;
    }
}

export class Result41 {
    'category': Category;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "category",
            "baseName": "category",
            "type": "Category"
        }    ];

    static getAttributeTypeMap() {
        return Result41.attributeTypeMap;
    }
}

export class Result42 {
    'categories': Array<Category2>;
    'page': number;
    'pages': number;
    'perPage': number;
    'total': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "categories",
            "baseName": "categories",
            "type": "Array<Category2>"
        },
        {
            "name": "page",
            "baseName": "page",
            "type": "number"
        },
        {
            "name": "pages",
            "baseName": "pages",
            "type": "number"
        },
        {
            "name": "perPage",
            "baseName": "per_page",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Result42.attributeTypeMap;
    }
}

export class Result44 {
    'estimates': Array<Estimate>;
    'page': number;
    'pages': number;
    'perPage': number;
    'total': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "estimates",
            "baseName": "estimates",
            "type": "Array<Estimate>"
        },
        {
            "name": "page",
            "baseName": "page",
            "type": "number"
        },
        {
            "name": "pages",
            "baseName": "pages",
            "type": "number"
        },
        {
            "name": "perPage",
            "baseName": "per_page",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Result44.attributeTypeMap;
    }
}

export class Result45 {
    'estimate': Estimate;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "estimate",
            "baseName": "estimate",
            "type": "Estimate"
        }    ];

    static getAttributeTypeMap() {
        return Result45.attributeTypeMap;
    }
}

export class Result46 {
    'estimate': Estimate2;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "estimate",
            "baseName": "estimate",
            "type": "Estimate2"
        }    ];

    static getAttributeTypeMap() {
        return Result46.attributeTypeMap;
    }
}

export class Result50 {
    'page': number;
    'pages': number;
    'perPage': number;
    'tasks': Array<Task>;
    'total': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "page",
            "baseName": "page",
            "type": "number"
        },
        {
            "name": "pages",
            "baseName": "pages",
            "type": "number"
        },
        {
            "name": "perPage",
            "baseName": "per_page",
            "type": "number"
        },
        {
            "name": "tasks",
            "baseName": "tasks",
            "type": "Array<Task>"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Result50.attributeTypeMap;
    }
}

export class Result51 {
    'task': Task;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "task",
            "baseName": "task",
            "type": "Task"
        }    ];

    static getAttributeTypeMap() {
        return Result51.attributeTypeMap;
    }
}

export class Result55 {
    'staff': Staff;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "staff",
            "baseName": "staff",
            "type": "Staff"
        }    ];

    static getAttributeTypeMap() {
        return Result55.attributeTypeMap;
    }
}

export class Result57 {
    'invoiceDetails': InvoiceDetails1;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "invoiceDetails",
            "baseName": "invoice_details",
            "type": "InvoiceDetails1"
        }    ];

    static getAttributeTypeMap() {
        return Result57.attributeTypeMap;
    }
}

export class Result58 {
    'profitloss': Profitloss;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "profitloss",
            "baseName": "profitloss",
            "type": "Profitloss"
        }    ];

    static getAttributeTypeMap() {
        return Result58.attributeTypeMap;
    }
}

export class Result59 {
    'taxsummary': Taxsummary;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "taxsummary",
            "baseName": "taxsummary",
            "type": "Taxsummary"
        }    ];

    static getAttributeTypeMap() {
        return Result59.attributeTypeMap;
    }
}

export class Result60 {
    'accountsAging': AccountsAging1;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountsAging",
            "baseName": "accounts_aging",
            "type": "AccountsAging1"
        }    ];

    static getAttributeTypeMap() {
        return Result60.attributeTypeMap;
    }
}

export class Result61 {
    'paymentsCollected': PaymentsCollected1;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "paymentsCollected",
            "baseName": "payments_collected",
            "type": "PaymentsCollected1"
        }    ];

    static getAttributeTypeMap() {
        return Result61.attributeTypeMap;
    }
}

export class Result62 {
    'itemSales': ItemSales1;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "itemSales",
            "baseName": "item_sales",
            "type": "ItemSales1"
        }    ];

    static getAttributeTypeMap() {
        return Result62.attributeTypeMap;
    }
}

export class Result63 {
    'revenueByClient': RevenueByClient1;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "revenueByClient",
            "baseName": "revenue_by_client",
            "type": "RevenueByClient1"
        }    ];

    static getAttributeTypeMap() {
        return Result63.attributeTypeMap;
    }
}

export class Result64 {
    'balanceSheet': BalanceSheet1;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "balanceSheet",
            "baseName": "balance_sheet",
            "type": "BalanceSheet1"
        }    ];

    static getAttributeTypeMap() {
        return Result64.attributeTypeMap;
    }
}

export class Result65 {
    'trialBalance': TrialBalance1;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "trialBalance",
            "baseName": "trial_balance",
            "type": "TrialBalance1"
        }    ];

    static getAttributeTypeMap() {
        return Result65.attributeTypeMap;
    }
}

export class Result66 {
    'journalEntryAccounts': Array<JournalEntryAccount>;
    'page': number;
    'pages': number;
    'perPage': number;
    'total': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "journalEntryAccounts",
            "baseName": "journal_entry_accounts",
            "type": "Array<JournalEntryAccount>"
        },
        {
            "name": "page",
            "baseName": "page",
            "type": "number"
        },
        {
            "name": "pages",
            "baseName": "pages",
            "type": "number"
        },
        {
            "name": "perPage",
            "baseName": "per_page",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Result66.attributeTypeMap;
    }
}

export class Result67 {
    'journalEntry': JournalEntry1;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "journalEntry",
            "baseName": "journal_entry",
            "type": "JournalEntry1"
        }    ];

    static getAttributeTypeMap() {
        return Result67.attributeTypeMap;
    }
}

export class Result68 {
    'journalEntryDetails': Array<JournalEntryDetails1>;
    'page': number;
    'pages': number;
    'perPage': number;
    'total': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "journalEntryDetails",
            "baseName": "journal_entry_details",
            "type": "Array<JournalEntryDetails1>"
        },
        {
            "name": "page",
            "baseName": "page",
            "type": "number"
        },
        {
            "name": "pages",
            "baseName": "pages",
            "type": "number"
        },
        {
            "name": "perPage",
            "baseName": "per_page",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Result68.attributeTypeMap;
    }
}

export class Result73 {
    'page': number;
    'pages': number;
    'perPage': number;
    'taxes': Array<Taxis7>;
    'total': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "page",
            "baseName": "page",
            "type": "number"
        },
        {
            "name": "pages",
            "baseName": "pages",
            "type": "number"
        },
        {
            "name": "perPage",
            "baseName": "per_page",
            "type": "number"
        },
        {
            "name": "taxes",
            "baseName": "taxes",
            "type": "Array<Taxis7>"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Result73.attributeTypeMap;
    }
}

export class Result74 {
    'tax': Tax;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "tax",
            "baseName": "tax",
            "type": "Tax"
        }    ];

    static getAttributeTypeMap() {
        return Result74.attributeTypeMap;
    }
}

export class Result75 {
    'tax': Tax2;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "tax",
            "baseName": "tax",
            "type": "Tax2"
        }    ];

    static getAttributeTypeMap() {
        return Result75.attributeTypeMap;
    }
}

export class Result77 {
    'callbacks': Array<string>;
    'page': number;
    'pages': number;
    'perPage': number;
    'total': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "callbacks",
            "baseName": "callbacks",
            "type": "Array<string>"
        },
        {
            "name": "page",
            "baseName": "page",
            "type": "number"
        },
        {
            "name": "pages",
            "baseName": "pages",
            "type": "number"
        },
        {
            "name": "perPage",
            "baseName": "per_page",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Result77.attributeTypeMap;
    }
}

export class Result78 {
    'system': System;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "system",
            "baseName": "system",
            "type": "System"
        }    ];

    static getAttributeTypeMap() {
        return Result78.attributeTypeMap;
    }
}

export class Result9 {
    'invoiceProfiles': Array<InvoiceProfile>;
    'page': number;
    'pages': number;
    'perPage': number;
    'total': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "invoiceProfiles",
            "baseName": "invoice_profiles",
            "type": "Array<InvoiceProfile>"
        },
        {
            "name": "page",
            "baseName": "page",
            "type": "number"
        },
        {
            "name": "pages",
            "baseName": "pages",
            "type": "number"
        },
        {
            "name": "perPage",
            "baseName": "per_page",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Result9.attributeTypeMap;
    }
}

export class Retainer {
    'id': number;
    'businessId': number;
    'systemId': number;
    'invoiceProfileId': string;
    'clientUserId': number;
    'startDate': string;
    'nextPeriodStartDate': string;
    'fee': string;
    'excessRate': string;
    'budgetedTime': number;
    'active': boolean;
    'createdAt': string;
    'updatedAt': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "businessId",
            "baseName": "business_id",
            "type": "number"
        },
        {
            "name": "systemId",
            "baseName": "system_id",
            "type": "number"
        },
        {
            "name": "invoiceProfileId",
            "baseName": "invoice_profile_id",
            "type": "string"
        },
        {
            "name": "clientUserId",
            "baseName": "client_user_id",
            "type": "number"
        },
        {
            "name": "startDate",
            "baseName": "start_date",
            "type": "string"
        },
        {
            "name": "nextPeriodStartDate",
            "baseName": "next_period_start_date",
            "type": "string"
        },
        {
            "name": "fee",
            "baseName": "fee",
            "type": "string"
        },
        {
            "name": "excessRate",
            "baseName": "excess_rate",
            "type": "string"
        },
        {
            "name": "budgetedTime",
            "baseName": "budgeted_time",
            "type": "number"
        },
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Retainer.attributeTypeMap;
    }
}

export class Retainer1 {
    'clientUserId': string;
    'startDate': string;
    'nextPeriodStartDate': string;
    'fee': number;
    'excessRate': number;
    'budgetedTime': number;
    'active': boolean;
    'frequency': string;
    'numberRecurring': number;
    'isInfinitelyRecurring': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "clientUserId",
            "baseName": "client_user_id",
            "type": "string"
        },
        {
            "name": "startDate",
            "baseName": "start_date",
            "type": "string"
        },
        {
            "name": "nextPeriodStartDate",
            "baseName": "next_period_start_date",
            "type": "string"
        },
        {
            "name": "fee",
            "baseName": "fee",
            "type": "number"
        },
        {
            "name": "excessRate",
            "baseName": "excess_rate",
            "type": "number"
        },
        {
            "name": "budgetedTime",
            "baseName": "budgeted_time",
            "type": "number"
        },
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "frequency",
            "baseName": "frequency",
            "type": "string"
        },
        {
            "name": "numberRecurring",
            "baseName": "number_recurring",
            "type": "number"
        },
        {
            "name": "isInfinitelyRecurring",
            "baseName": "is_infinitely_recurring",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Retainer1.attributeTypeMap;
    }
}

export class Retainer6 {
    'active': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Retainer6.attributeTypeMap;
    }
}

export class RevenueByClient {
    'response': Response73;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Response73"
        }    ];

    static getAttributeTypeMap() {
        return RevenueByClient.attributeTypeMap;
    }
}

export class RevenueByClient1 {
    'clientids': Array<string>;
    'clients': Array<string>;
    'currencyCode': string;
    'downloadToken': string;
    'endDate': string;
    'labels': Array<string>;
    'salesType': string;
    'startDate': string;
    'totalSales': TotalSales;
    'totalSalesData': Array<TotalSalesDatum>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "clientids",
            "baseName": "clientids",
            "type": "Array<string>"
        },
        {
            "name": "clients",
            "baseName": "clients",
            "type": "Array<string>"
        },
        {
            "name": "currencyCode",
            "baseName": "currency_code",
            "type": "string"
        },
        {
            "name": "downloadToken",
            "baseName": "download_token",
            "type": "string"
        },
        {
            "name": "endDate",
            "baseName": "end_date",
            "type": "string"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "Array<string>"
        },
        {
            "name": "salesType",
            "baseName": "sales_type",
            "type": "string"
        },
        {
            "name": "startDate",
            "baseName": "start_date",
            "type": "string"
        },
        {
            "name": "totalSales",
            "baseName": "total_sales",
            "type": "TotalSales"
        },
        {
            "name": "totalSalesData",
            "baseName": "total_sales_data",
            "type": "Array<TotalSalesDatum>"
        }    ];

    static getAttributeTypeMap() {
        return RevenueByClient1.attributeTypeMap;
    }
}

export class RmpKp {
    'clientLimit': number;
    'staffLimit': number;
    'attachmentsAccess': boolean;
    'advancedAccountingAccess': boolean;
    'businessAccountantLimit': number;
    'proposalsCandidateAccess': boolean;
    'betaHeliosAsyncExpensesAccess': boolean;
    'betaMobileCreateExpenseSubcategoryAccess': boolean;
    'iosBetaZendeskWidgetAccess': boolean;
    'mobileReceiptRebillingAccess': boolean;
    'richProposalsAccess': boolean;
    'heliosPushnotificationsBetaAccess': boolean;
    'iosBetaPaymentSchedulesAccess': boolean;
    'heliosRebillTimeAccess': boolean;
    'esignaturesAccess': boolean;
    'heliosDashboardAccess': boolean;
    'heliosLateFeeReminderBetaAccess': boolean;
    'heliosBulkActionsInvoicesBetaAccess': boolean;
    'autoBankImportAccess': boolean;
    'heliosVirtualTerminalBetaAccess': boolean;
    'heliosExpenseRebillingBetaAccess': boolean;
    'heliosCompanyTaxesBetaAccess': boolean;
    'heliosInvoiceArchiveBetaAccess': boolean;
    'accountantInviteAccess': boolean;
    'heliosSyncThrottleBetaAccess': boolean;
    'bankReconciliationAccess': boolean;
    'heliosPushResourceToUseExecuteBetaAccess': boolean;
    'newTimeTrackingAccess': boolean;
    'bankRecSmartMatchAccess': boolean;
    'balanceSheetAccess': boolean;
    'invoiceV2SearchAccess': boolean;
    'importItemsCsvAccess': boolean;
    'exportClientsCsvAccess': boolean;
    'heliosVirtualTerminalTutorialBetaAccess': boolean;
    'inlineExpenseEditAccess': boolean;
    'heliosVirtualTerminalAdvertisingBetaAccess': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "clientLimit",
            "baseName": "client.limit",
            "type": "number"
        },
        {
            "name": "staffLimit",
            "baseName": "staff.limit",
            "type": "number"
        },
        {
            "name": "attachmentsAccess",
            "baseName": "attachments.access",
            "type": "boolean"
        },
        {
            "name": "advancedAccountingAccess",
            "baseName": "advanced_accounting.access",
            "type": "boolean"
        },
        {
            "name": "businessAccountantLimit",
            "baseName": "business_accountant.limit",
            "type": "number"
        },
        {
            "name": "proposalsCandidateAccess",
            "baseName": "proposals_candidate.access",
            "type": "boolean"
        },
        {
            "name": "betaHeliosAsyncExpensesAccess",
            "baseName": "BetaHeliosAsyncExpenses.access",
            "type": "boolean"
        },
        {
            "name": "betaMobileCreateExpenseSubcategoryAccess",
            "baseName": "beta_mobile_create_expense_subcategory.access",
            "type": "boolean"
        },
        {
            "name": "iosBetaZendeskWidgetAccess",
            "baseName": "ios_beta_zendesk_widget.access",
            "type": "boolean"
        },
        {
            "name": "mobileReceiptRebillingAccess",
            "baseName": "mobile_receipt_rebilling.access",
            "type": "boolean"
        },
        {
            "name": "richProposalsAccess",
            "baseName": "rich_proposals.access",
            "type": "boolean"
        },
        {
            "name": "heliosPushnotificationsBetaAccess",
            "baseName": "helios_pushnotifications.beta.access",
            "type": "boolean"
        },
        {
            "name": "iosBetaPaymentSchedulesAccess",
            "baseName": "ios_beta_payment_schedules.access",
            "type": "boolean"
        },
        {
            "name": "heliosRebillTimeAccess",
            "baseName": "helios_rebill_time.access",
            "type": "boolean"
        },
        {
            "name": "esignaturesAccess",
            "baseName": "esignatures.access",
            "type": "boolean"
        },
        {
            "name": "heliosDashboardAccess",
            "baseName": "helios_dashboard.access",
            "type": "boolean"
        },
        {
            "name": "heliosLateFeeReminderBetaAccess",
            "baseName": "helios_late_fee_reminder.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosBulkActionsInvoicesBetaAccess",
            "baseName": "helios_bulk_actions_invoices.beta.access",
            "type": "boolean"
        },
        {
            "name": "autoBankImportAccess",
            "baseName": "auto_bank_import.access",
            "type": "boolean"
        },
        {
            "name": "heliosVirtualTerminalBetaAccess",
            "baseName": "helios_virtual_terminal.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosExpenseRebillingBetaAccess",
            "baseName": "helios_expense_rebilling.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosCompanyTaxesBetaAccess",
            "baseName": "helios_company_taxes.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosInvoiceArchiveBetaAccess",
            "baseName": "helios_invoice_archive.beta.access",
            "type": "boolean"
        },
        {
            "name": "accountantInviteAccess",
            "baseName": "accountant_invite.access",
            "type": "boolean"
        },
        {
            "name": "heliosSyncThrottleBetaAccess",
            "baseName": "helios_sync_throttle.beta.access",
            "type": "boolean"
        },
        {
            "name": "bankReconciliationAccess",
            "baseName": "BankReconciliation.access",
            "type": "boolean"
        },
        {
            "name": "heliosPushResourceToUseExecuteBetaAccess",
            "baseName": "helios_push_resource_to_use_execute.beta.access",
            "type": "boolean"
        },
        {
            "name": "newTimeTrackingAccess",
            "baseName": "new_time_tracking.access",
            "type": "boolean"
        },
        {
            "name": "bankRecSmartMatchAccess",
            "baseName": "bank_rec_smart_match.access",
            "type": "boolean"
        },
        {
            "name": "balanceSheetAccess",
            "baseName": "balance_sheet.access",
            "type": "boolean"
        },
        {
            "name": "invoiceV2SearchAccess",
            "baseName": "invoice_v2_search.access",
            "type": "boolean"
        },
        {
            "name": "importItemsCsvAccess",
            "baseName": "import_items_csv.access",
            "type": "boolean"
        },
        {
            "name": "exportClientsCsvAccess",
            "baseName": "export_clients_csv.access",
            "type": "boolean"
        },
        {
            "name": "heliosVirtualTerminalTutorialBetaAccess",
            "baseName": "helios_virtual_terminal_tutorial.beta.access",
            "type": "boolean"
        },
        {
            "name": "inlineExpenseEditAccess",
            "baseName": "inline_expense_edit.access",
            "type": "boolean"
        },
        {
            "name": "heliosVirtualTerminalAdvertisingBetaAccess",
            "baseName": "helios_virtual_terminal_advertising.beta.access",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return RmpKp.attributeTypeMap;
    }
}

export class Role {
    'id': number;
    'role': string;
    'systemid': number;
    'userid': number;
    'createdAt': string;
    'links': Links1;
    'accountid': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "role",
            "baseName": "role",
            "type": "string"
        },
        {
            "name": "systemid",
            "baseName": "systemid",
            "type": "number"
        },
        {
            "name": "userid",
            "baseName": "userid",
            "type": "number"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "links",
            "baseName": "links",
            "type": "Links1"
        },
        {
            "name": "accountid",
            "baseName": "accountid",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Role.attributeTypeMap;
    }
}

export class SalesTaxSummary {
    'response': Response69;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Response69"
        }    ];

    static getAttributeTypeMap() {
        return SalesTaxSummary.attributeTypeMap;
    }
}

export class Service {
    'businessId': number;
    'id': number;
    'name': string;
    'billable': boolean;
    'visState': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "businessId",
            "baseName": "business_id",
            "type": "number"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "billable",
            "baseName": "billable",
            "type": "boolean"
        },
        {
            "name": "visState",
            "baseName": "vis_state",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Service.attributeTypeMap;
    }
}

export class Service1 {
    'businessId'?: number;
    'id'?: number;
    'name'?: string;
    'billable'?: boolean;
    'visState'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "businessId",
            "baseName": "business_id",
            "type": "number"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "billable",
            "baseName": "billable",
            "type": "boolean"
        },
        {
            "name": "visState",
            "baseName": "vis_state",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Service1.attributeTypeMap;
    }
}

export class ServiceRates {
    'serviceRates': Array<ServiceRates1>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "serviceRates",
            "baseName": "service_rates",
            "type": "Array<ServiceRates1>"
        }    ];

    static getAttributeTypeMap() {
        return ServiceRates.attributeTypeMap;
    }
}

export class ServiceRates1 {
    'rate': string;
    'serviceId': number;
    'businessId': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "rate",
            "baseName": "rate",
            "type": "string"
        },
        {
            "name": "serviceId",
            "baseName": "service_id",
            "type": "number"
        },
        {
            "name": "businessId",
            "baseName": "business_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ServiceRates1.attributeTypeMap;
    }
}

export class ShareLink {
    'response': Response18;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Response18"
        }    ];

    static getAttributeTypeMap() {
        return ShareLink.attributeTypeMap;
    }
}

export class ShareLink1 {
    'clientid': number;
    'resourceType': string;
    'resourceid': string;
    'shareLink': string;
    'shareMethod': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "clientid",
            "baseName": "clientid",
            "type": "number"
        },
        {
            "name": "resourceType",
            "baseName": "resource_type",
            "type": "string"
        },
        {
            "name": "resourceid",
            "baseName": "resourceid",
            "type": "string"
        },
        {
            "name": "shareLink",
            "baseName": "share_link",
            "type": "string"
        },
        {
            "name": "shareMethod",
            "baseName": "share_method",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ShareLink1.attributeTypeMap;
    }
}

export class SingleClient {
    'response': Response3;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Response3"
        }    ];

    static getAttributeTypeMap() {
        return SingleClient.attributeTypeMap;
    }
}

export class SingleEstimate {
    'response': Response53;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Response53"
        }    ];

    static getAttributeTypeMap() {
        return SingleEstimate.attributeTypeMap;
    }
}

export class SingleEstimateWithEstimateLines {
    'response': Response54;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Response54"
        }    ];

    static getAttributeTypeMap() {
        return SingleEstimateWithEstimateLines.attributeTypeMap;
    }
}

export class SingleExpenseCategory {
    'response': Response49;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Response49"
        }    ];

    static getAttributeTypeMap() {
        return SingleExpenseCategory.attributeTypeMap;
    }
}

export class SingleInvoice {
    'response': Response31;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Response31"
        }    ];

    static getAttributeTypeMap() {
        return SingleInvoice.attributeTypeMap;
    }
}

export class SingleInvoicewLineItems {
    'response': Response33;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Response33"
        }    ];

    static getAttributeTypeMap() {
        return SingleInvoicewLineItems.attributeTypeMap;
    }
}

export class SingleInvoicewLogo {
    'response': Response32;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Response32"
        }    ];

    static getAttributeTypeMap() {
        return SingleInvoicewLogo.attributeTypeMap;
    }
}

export class SingleInvoicewLogoandstyles {
    'response': Response33;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Response33"
        }    ];

    static getAttributeTypeMap() {
        return SingleInvoicewLogoandstyles.attributeTypeMap;
    }
}

export class SingleInvoicewPaymentGateway {
    'response': Response34;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Response34"
        }    ];

    static getAttributeTypeMap() {
        return SingleInvoicewPaymentGateway.attributeTypeMap;
    }
}

export class SingleItem {
    'response': Response7;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Response7"
        }    ];

    static getAttributeTypeMap() {
        return SingleItem.attributeTypeMap;
    }
}

export class SinglePayment {
    'response': Response25;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Response25"
        }    ];

    static getAttributeTypeMap() {
        return SinglePayment.attributeTypeMap;
    }
}

export class SingleProject {
    'project': Project;
    'abilities': Array<Ability>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "project",
            "baseName": "project",
            "type": "Project"
        },
        {
            "name": "abilities",
            "baseName": "abilities",
            "type": "Array<Ability>"
        }    ];

    static getAttributeTypeMap() {
        return SingleProject.attributeTypeMap;
    }
}

export class SingleStaff {
    'response': Response63;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Response63"
        }    ];

    static getAttributeTypeMap() {
        return SingleStaff.attributeTypeMap;
    }
}

export class SingleTask {
    'response': Response59;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Response59"
        }    ];

    static getAttributeTypeMap() {
        return SingleTask.attributeTypeMap;
    }
}

export class Staff {
    'accountingSystemid': string;
    'apiToken': string;
    'busPhone': string;
    'currencyCode': string;
    'displayName': string;
    'email': string;
    'fax': string;
    'fname': string;
    'homePhone': string;
    'id': number;
    'language': string;
    'lastLogin': string;
    'level': number;
    'lname': string;
    'mobPhone': string;
    'note': string;
    'numLogins': number;
    'organization': string;
    'pCity': string;
    'pCode': string;
    'pCountry': string;
    'pProvince': string;
    'pStreet': string;
    'pStreet2': string;
    'rate': string;
    'role': string;
    'signupDate': string;
    'updated': string;
    'userid': number;
    'username': string;
    'visState': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountingSystemid",
            "baseName": "accounting_systemid",
            "type": "string"
        },
        {
            "name": "apiToken",
            "baseName": "api_token",
            "type": "string"
        },
        {
            "name": "busPhone",
            "baseName": "bus_phone",
            "type": "string"
        },
        {
            "name": "currencyCode",
            "baseName": "currency_code",
            "type": "string"
        },
        {
            "name": "displayName",
            "baseName": "display_name",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "fax",
            "baseName": "fax",
            "type": "string"
        },
        {
            "name": "fname",
            "baseName": "fname",
            "type": "string"
        },
        {
            "name": "homePhone",
            "baseName": "home_phone",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "language",
            "baseName": "language",
            "type": "string"
        },
        {
            "name": "lastLogin",
            "baseName": "last_login",
            "type": "string"
        },
        {
            "name": "level",
            "baseName": "level",
            "type": "number"
        },
        {
            "name": "lname",
            "baseName": "lname",
            "type": "string"
        },
        {
            "name": "mobPhone",
            "baseName": "mob_phone",
            "type": "string"
        },
        {
            "name": "note",
            "baseName": "note",
            "type": "string"
        },
        {
            "name": "numLogins",
            "baseName": "num_logins",
            "type": "number"
        },
        {
            "name": "organization",
            "baseName": "organization",
            "type": "string"
        },
        {
            "name": "pCity",
            "baseName": "p_city",
            "type": "string"
        },
        {
            "name": "pCode",
            "baseName": "p_code",
            "type": "string"
        },
        {
            "name": "pCountry",
            "baseName": "p_country",
            "type": "string"
        },
        {
            "name": "pProvince",
            "baseName": "p_province",
            "type": "string"
        },
        {
            "name": "pStreet",
            "baseName": "p_street",
            "type": "string"
        },
        {
            "name": "pStreet2",
            "baseName": "p_street2",
            "type": "string"
        },
        {
            "name": "rate",
            "baseName": "rate",
            "type": "string"
        },
        {
            "name": "role",
            "baseName": "role",
            "type": "string"
        },
        {
            "name": "signupDate",
            "baseName": "signup_date",
            "type": "string"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "string"
        },
        {
            "name": "userid",
            "baseName": "userid",
            "type": "number"
        },
        {
            "name": "username",
            "baseName": "username",
            "type": "string"
        },
        {
            "name": "visState",
            "baseName": "vis_state",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Staff.attributeTypeMap;
    }
}

export class Staff1 {
    'fname': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "fname",
            "baseName": "fname",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Staff1.attributeTypeMap;
    }
}

export class Staff3 {
    'visState': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "visState",
            "baseName": "vis_state",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Staff3.attributeTypeMap;
    }
}

export class Stripe {
    'currencies': Array<string>;
    'country': string;
    'gatewayUserId': string;
    'id': string;
    'userState': string;
    'email': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "currencies",
            "baseName": "currencies",
            "type": "Array<string>"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "gatewayUserId",
            "baseName": "gateway_user_id",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "userState",
            "baseName": "user_state",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Stripe.attributeTypeMap;
    }
}

export class SubAccount {
    'balances'?: Array<Balance1>;
    'subAccountName'?: string;
    'subAccountNumber'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "balances",
            "baseName": "balances",
            "type": "Array<Balance1>"
        },
        {
            "name": "subAccountName",
            "baseName": "sub_account_name",
            "type": "string"
        },
        {
            "name": "subAccountNumber",
            "baseName": "sub_account_number",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SubAccount.attributeTypeMap;
    }
}

export class SubAccount1 {
    'accountSubName'?: string;
    'accountSubNumber'?: string;
    'accountType'?: string;
    'balance'?: string;
    'currencyCode'?: string;
    'custom'?: boolean;
    'id'?: number;
    'parentid'?: number;
    'subAccountid'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountSubName",
            "baseName": "account_sub_name",
            "type": "string"
        },
        {
            "name": "accountSubNumber",
            "baseName": "account_sub_number",
            "type": "string"
        },
        {
            "name": "accountType",
            "baseName": "account_type",
            "type": "string"
        },
        {
            "name": "balance",
            "baseName": "balance",
            "type": "string"
        },
        {
            "name": "currencyCode",
            "baseName": "currency_code",
            "type": "string"
        },
        {
            "name": "custom",
            "baseName": "custom",
            "type": "boolean"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "parentid",
            "baseName": "parentid",
            "type": "number"
        },
        {
            "name": "subAccountid",
            "baseName": "sub_accountid",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return SubAccount1.attributeTypeMap;
    }
}

export class SubAccount2 {
    'accountSubName': string;
    'accountSubNumber': string;
    'accountingSystemid': string;
    'id': number;
    'parentid': number;
    'subAccountid': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountSubName",
            "baseName": "account_sub_name",
            "type": "string"
        },
        {
            "name": "accountSubNumber",
            "baseName": "account_sub_number",
            "type": "string"
        },
        {
            "name": "accountingSystemid",
            "baseName": "accounting_systemid",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "parentid",
            "baseName": "parentid",
            "type": "number"
        },
        {
            "name": "subAccountid",
            "baseName": "sub_accountid",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return SubAccount2.attributeTypeMap;
    }
}

export class SubscriptionStatuses {
    'rALYo': string;
    'e86Qp': string;
    'rnPKp': string;
    'j7nAK': string;
    'gjndR': string;
    'apw1A': string;
    '_0XaOw': string;
    '_7lwxr': string;
    '_4VMVg': string;
    'x33xX': string;
    'e1yRq': string;
    '_3eRwB': string;
    '_8nPPA': string;
    'j1322': string;
    'b3AVo': string;
    'm1OaR': string;
    'e3MAY': string;
    'm1GeK': string;
    '_7PO26': string;
    'zAZdo': string;
    '_0PJMZ': string;
    'ee0nZ': string;
    'pe6MW': string;
    'oM6yL': string;
    'dowQ0g': string;
    'yA0R2P': string;
    'lJZ1p4': string;
    'wkMd2g': string;
    '_3x62x2': string;
    'lwy0vG': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "rALYo",
            "baseName": "rALYo",
            "type": "string"
        },
        {
            "name": "e86Qp",
            "baseName": "E86Qp",
            "type": "string"
        },
        {
            "name": "rnPKp",
            "baseName": "RnPKp",
            "type": "string"
        },
        {
            "name": "j7nAK",
            "baseName": "J7nAK",
            "type": "string"
        },
        {
            "name": "gjndR",
            "baseName": "gjndR",
            "type": "string"
        },
        {
            "name": "apw1A",
            "baseName": "apw1A",
            "type": "string"
        },
        {
            "name": "_0XaOw",
            "baseName": "0XaOw",
            "type": "string"
        },
        {
            "name": "_7lwxr",
            "baseName": "7lwxr",
            "type": "string"
        },
        {
            "name": "_4VMVg",
            "baseName": "4VMVg",
            "type": "string"
        },
        {
            "name": "x33xX",
            "baseName": "x33xX",
            "type": "string"
        },
        {
            "name": "e1yRq",
            "baseName": "e1yRq",
            "type": "string"
        },
        {
            "name": "_3eRwB",
            "baseName": "3eRwB",
            "type": "string"
        },
        {
            "name": "_8nPPA",
            "baseName": "8nPPA",
            "type": "string"
        },
        {
            "name": "j1322",
            "baseName": "j1322",
            "type": "string"
        },
        {
            "name": "b3AVo",
            "baseName": "B3AVo",
            "type": "string"
        },
        {
            "name": "m1OaR",
            "baseName": "M1OaR",
            "type": "string"
        },
        {
            "name": "e3MAY",
            "baseName": "E3MAY",
            "type": "string"
        },
        {
            "name": "m1GeK",
            "baseName": "M1GeK",
            "type": "string"
        },
        {
            "name": "_7PO26",
            "baseName": "7PO26",
            "type": "string"
        },
        {
            "name": "zAZdo",
            "baseName": "ZAZdo",
            "type": "string"
        },
        {
            "name": "_0PJMZ",
            "baseName": "0PJMZ",
            "type": "string"
        },
        {
            "name": "ee0nZ",
            "baseName": "Ee0nZ",
            "type": "string"
        },
        {
            "name": "pe6MW",
            "baseName": "pe6MW",
            "type": "string"
        },
        {
            "name": "oM6yL",
            "baseName": "oM6yL",
            "type": "string"
        },
        {
            "name": "dowQ0g",
            "baseName": "dowQ0g",
            "type": "string"
        },
        {
            "name": "yA0R2P",
            "baseName": "yA0R2P",
            "type": "string"
        },
        {
            "name": "lJZ1p4",
            "baseName": "LJZ1p4",
            "type": "string"
        },
        {
            "name": "wkMd2g",
            "baseName": "wkMd2g",
            "type": "string"
        },
        {
            "name": "_3x62x2",
            "baseName": "3x62x2",
            "type": "string"
        },
        {
            "name": "lwy0vG",
            "baseName": "lwy0vG",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SubscriptionStatuses.attributeTypeMap;
    }
}

export class SubscriptionStatuses1 {
    'g2MB3M': string;
    'wk6N3K': string;
    '_85lLQg': string;
    'wkMd2g': string;
    '_5o0MVd': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "g2MB3M",
            "baseName": "G2MB3M",
            "type": "string"
        },
        {
            "name": "wk6N3K",
            "baseName": "wk6N3K",
            "type": "string"
        },
        {
            "name": "_85lLQg",
            "baseName": "85lLQg",
            "type": "string"
        },
        {
            "name": "wkMd2g",
            "baseName": "wkMd2g",
            "type": "string"
        },
        {
            "name": "_5o0MVd",
            "baseName": "5o0MVd",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SubscriptionStatuses1.attributeTypeMap;
    }
}

export class Summary {
    'amounts': Array<Amount35>;
    'counts': number;
    'id': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amounts",
            "baseName": "amounts",
            "type": "Array<Amount35>"
        },
        {
            "name": "counts",
            "baseName": "counts",
            "type": "number"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Summary.attributeTypeMap;
    }
}

export class Summary1 {
    'outstanding': Outstanding;
    'paid': Paid;
    'total': Total;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "outstanding",
            "baseName": "outstanding",
            "type": "Outstanding"
        },
        {
            "name": "paid",
            "baseName": "paid",
            "type": "Paid"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "Total"
        }    ];

    static getAttributeTypeMap() {
        return Summary1.attributeTypeMap;
    }
}

export class System {
    'accountid': string;
    'active': boolean;
    'autoBill': number;
    'billingStatus': string;
    'busPhone': string;
    'businessType': string;
    'businessUuid': string;
    'city': string;
    'code': string;
    'country': string;
    'currencyCode': string;
    'date': string;
    'discountid': string;
    'dst': boolean;
    'duration': number;
    'email': string;
    'fax': string;
    'gstAmount': GstAmount;
    'heardAboutUsVia': string;
    'id': number;
    'infoEmail': string;
    'ip': string;
    'landingUrl': string;
    'masterlockBilling': boolean;
    'migratedToSmuxAt': string;
    'mobPhone': string;
    'modernSystem': boolean;
    'name': string;
    'numClients': string;
    'numStaff': string;
    'paymentAmount': PaymentAmount;
    'paymentFrequency': number;
    'province': string;
    'referralid': string;
    'referringUrl': string;
    'salutation': string;
    'sizeLimit': string;
    'splitToken': string;
    'street': string;
    'street2': string;
    'systemid': number;
    'testSystem': boolean;
    'timezone': string;
    'timezoneid': number;
    'vatName': string;
    'vatNumber': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountid",
            "baseName": "accountid",
            "type": "string"
        },
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "autoBill",
            "baseName": "auto_bill",
            "type": "number"
        },
        {
            "name": "billingStatus",
            "baseName": "billing_status",
            "type": "string"
        },
        {
            "name": "busPhone",
            "baseName": "bus_phone",
            "type": "string"
        },
        {
            "name": "businessType",
            "baseName": "business_type",
            "type": "string"
        },
        {
            "name": "businessUuid",
            "baseName": "business_uuid",
            "type": "string"
        },
        {
            "name": "city",
            "baseName": "city",
            "type": "string"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "currencyCode",
            "baseName": "currency_code",
            "type": "string"
        },
        {
            "name": "date",
            "baseName": "date",
            "type": "string"
        },
        {
            "name": "discountid",
            "baseName": "discountid",
            "type": "string"
        },
        {
            "name": "dst",
            "baseName": "dst",
            "type": "boolean"
        },
        {
            "name": "duration",
            "baseName": "duration",
            "type": "number"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "fax",
            "baseName": "fax",
            "type": "string"
        },
        {
            "name": "gstAmount",
            "baseName": "gst_amount",
            "type": "GstAmount"
        },
        {
            "name": "heardAboutUsVia",
            "baseName": "heard_about_us_via",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "infoEmail",
            "baseName": "info_email",
            "type": "string"
        },
        {
            "name": "ip",
            "baseName": "ip",
            "type": "string"
        },
        {
            "name": "landingUrl",
            "baseName": "landing_url",
            "type": "string"
        },
        {
            "name": "masterlockBilling",
            "baseName": "masterlock_billing",
            "type": "boolean"
        },
        {
            "name": "migratedToSmuxAt",
            "baseName": "migrated_to_smux_at",
            "type": "string"
        },
        {
            "name": "mobPhone",
            "baseName": "mob_phone",
            "type": "string"
        },
        {
            "name": "modernSystem",
            "baseName": "modern_system",
            "type": "boolean"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "numClients",
            "baseName": "num_clients",
            "type": "string"
        },
        {
            "name": "numStaff",
            "baseName": "num_staff",
            "type": "string"
        },
        {
            "name": "paymentAmount",
            "baseName": "payment_amount",
            "type": "PaymentAmount"
        },
        {
            "name": "paymentFrequency",
            "baseName": "payment_frequency",
            "type": "number"
        },
        {
            "name": "province",
            "baseName": "province",
            "type": "string"
        },
        {
            "name": "referralid",
            "baseName": "referralid",
            "type": "string"
        },
        {
            "name": "referringUrl",
            "baseName": "referring_url",
            "type": "string"
        },
        {
            "name": "salutation",
            "baseName": "salutation",
            "type": "string"
        },
        {
            "name": "sizeLimit",
            "baseName": "size_limit",
            "type": "string"
        },
        {
            "name": "splitToken",
            "baseName": "split_token",
            "type": "string"
        },
        {
            "name": "street",
            "baseName": "street",
            "type": "string"
        },
        {
            "name": "street2",
            "baseName": "street2",
            "type": "string"
        },
        {
            "name": "systemid",
            "baseName": "systemid",
            "type": "number"
        },
        {
            "name": "testSystem",
            "baseName": "test_system",
            "type": "boolean"
        },
        {
            "name": "timezone",
            "baseName": "timezone",
            "type": "string"
        },
        {
            "name": "timezoneid",
            "baseName": "timezoneid",
            "type": "number"
        },
        {
            "name": "vatName",
            "baseName": "vat_name",
            "type": "string"
        },
        {
            "name": "vatNumber",
            "baseName": "vat_number",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return System.attributeTypeMap;
    }
}

export class Task {
    'billable': boolean;
    'description': string;
    'id': number;
    'name': string;
    'rate': Rate;
    'taskid': number;
    'tax1': number;
    'tax2': number;
    'tdesc': string;
    'tname': string;
    'updated': string;
    'visState': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "billable",
            "baseName": "billable",
            "type": "boolean"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "rate",
            "baseName": "rate",
            "type": "Rate"
        },
        {
            "name": "taskid",
            "baseName": "taskid",
            "type": "number"
        },
        {
            "name": "tax1",
            "baseName": "tax1",
            "type": "number"
        },
        {
            "name": "tax2",
            "baseName": "tax2",
            "type": "number"
        },
        {
            "name": "tdesc",
            "baseName": "tdesc",
            "type": "string"
        },
        {
            "name": "tname",
            "baseName": "tname",
            "type": "string"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "string"
        },
        {
            "name": "visState",
            "baseName": "vis_state",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Task.attributeTypeMap;
    }
}

export class Task2 {
    'name': string;
    'description': string;
    'rate': Rate;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "rate",
            "baseName": "rate",
            "type": "Rate"
        }    ];

    static getAttributeTypeMap() {
        return Task2.attributeTypeMap;
    }
}

export class Task4 {
    'name': string;
    'rate': Rate;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "rate",
            "baseName": "rate",
            "type": "Rate"
        }    ];

    static getAttributeTypeMap() {
        return Task4.attributeTypeMap;
    }
}

export class Task6 {
    'visState': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "visState",
            "baseName": "vis_state",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Task6.attributeTypeMap;
    }
}

export class Tax {
    'accountingSystemid': string;
    'amount': string;
    'compound': boolean;
    'id': number;
    'name': string;
    'number': string;
    'taxid': number;
    'updated': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountingSystemid",
            "baseName": "accounting_systemid",
            "type": "string"
        },
        {
            "name": "amount",
            "baseName": "amount",
            "type": "string"
        },
        {
            "name": "compound",
            "baseName": "compound",
            "type": "boolean"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "string"
        },
        {
            "name": "taxid",
            "baseName": "taxid",
            "type": "number"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Tax.attributeTypeMap;
    }
}

export class Tax1 {
    'name': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Tax1.attributeTypeMap;
    }
}

export class Tax2 {
    'accountingSystemid': string;
    'amount': string;
    'compound': boolean;
    'id': number;
    'name': string;
    'number': string;
    'taxid': number;
    'updated': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountingSystemid",
            "baseName": "accounting_systemid",
            "type": "string"
        },
        {
            "name": "amount",
            "baseName": "amount",
            "type": "string"
        },
        {
            "name": "compound",
            "baseName": "compound",
            "type": "boolean"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "string"
        },
        {
            "name": "taxid",
            "baseName": "taxid",
            "type": "number"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Tax2.attributeTypeMap;
    }
}

export class TaxAmount1 {
    'amount'?: string;
    'code'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "string"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TaxAmount1.attributeTypeMap;
    }
}

export class TaxAmount11 {
    'amount': string;
    'code': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "string"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TaxAmount11.attributeTypeMap;
    }
}

export class TaxCollected {
    'amount': string;
    'code': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "string"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TaxCollected.attributeTypeMap;
    }
}

export class TaxPaid {
    'amount': string;
    'code': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "string"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TaxPaid.attributeTypeMap;
    }
}

export class TaxableAmountCollected {
    'amount': string;
    'code': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "string"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TaxableAmountCollected.attributeTypeMap;
    }
}

export class TaxableAmountPaid {
    'amount': string;
    'code': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "string"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TaxableAmountPaid.attributeTypeMap;
    }
}

export class Taxis {
    'amount'?: string;
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Taxis.attributeTypeMap;
    }
}

export class Taxis1 {
    'amount': string;
    'name': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Taxis1.attributeTypeMap;
    }
}

export class Taxis3 {
    'netTax': NetTax;
    'netTaxableAmount': NetTaxableAmount;
    'taxCollected': TaxCollected;
    'taxName': string;
    'taxPaid': TaxPaid;
    'taxableAmountCollected': TaxableAmountCollected;
    'taxableAmountPaid': TaxableAmountPaid;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "netTax",
            "baseName": "net_tax",
            "type": "NetTax"
        },
        {
            "name": "netTaxableAmount",
            "baseName": "net_taxable_amount",
            "type": "NetTaxableAmount"
        },
        {
            "name": "taxCollected",
            "baseName": "tax_collected",
            "type": "TaxCollected"
        },
        {
            "name": "taxName",
            "baseName": "tax_name",
            "type": "string"
        },
        {
            "name": "taxPaid",
            "baseName": "tax_paid",
            "type": "TaxPaid"
        },
        {
            "name": "taxableAmountCollected",
            "baseName": "taxable_amount_collected",
            "type": "TaxableAmountCollected"
        },
        {
            "name": "taxableAmountPaid",
            "baseName": "taxable_amount_paid",
            "type": "TaxableAmountPaid"
        }    ];

    static getAttributeTypeMap() {
        return Taxis3.attributeTypeMap;
    }
}

export class Taxis7 {
    'accountingSystemid': string;
    'amount': string;
    'compound': boolean;
    'id': number;
    'name': string;
    'number': string;
    'taxid': number;
    'updated': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountingSystemid",
            "baseName": "accounting_systemid",
            "type": "string"
        },
        {
            "name": "amount",
            "baseName": "amount",
            "type": "string"
        },
        {
            "name": "compound",
            "baseName": "compound",
            "type": "boolean"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "string"
        },
        {
            "name": "taxid",
            "baseName": "taxid",
            "type": "number"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Taxis7.attributeTypeMap;
    }
}

export class Taxsummary {
    'cashBased': boolean;
    'currencyCode': string;
    'downloadToken': string;
    'endDate': string;
    'startDate': string;
    'taxes': Array<Taxis3>;
    'totalInvoiced': TotalInvoiced;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cashBased",
            "baseName": "cash_based",
            "type": "boolean"
        },
        {
            "name": "currencyCode",
            "baseName": "currency_code",
            "type": "string"
        },
        {
            "name": "downloadToken",
            "baseName": "download_token",
            "type": "string"
        },
        {
            "name": "endDate",
            "baseName": "end_date",
            "type": "string"
        },
        {
            "name": "startDate",
            "baseName": "start_date",
            "type": "string"
        },
        {
            "name": "taxes",
            "baseName": "taxes",
            "type": "Array<Taxis3>"
        },
        {
            "name": "totalInvoiced",
            "baseName": "total_invoiced",
            "type": "TotalInvoiced"
        }    ];

    static getAttributeTypeMap() {
        return Taxsummary.attributeTypeMap;
    }
}

export class TeamMemberRate {
    'rate': string;
    'identityId': number;
    'businessId': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "rate",
            "baseName": "rate",
            "type": "string"
        },
        {
            "name": "identityId",
            "baseName": "identity_id",
            "type": "number"
        },
        {
            "name": "businessId",
            "baseName": "business_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return TeamMemberRate.attributeTypeMap;
    }
}

export class TeamMemberRates {
    'teamMemberRates': Array<TeamMemberRates1>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "teamMemberRates",
            "baseName": "team_member_rates",
            "type": "Array<TeamMemberRates1>"
        }    ];

    static getAttributeTypeMap() {
        return TeamMemberRates.attributeTypeMap;
    }
}

export class TeamMemberRates1 {
    'rate': string;
    'identityId': number;
    'businessId': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "rate",
            "baseName": "rate",
            "type": "string"
        },
        {
            "name": "identityId",
            "baseName": "identity_id",
            "type": "number"
        },
        {
            "name": "businessId",
            "baseName": "business_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return TeamMemberRates1.attributeTypeMap;
    }
}

export class Thread {
    'message': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Thread.attributeTypeMap;
    }
}

export class TimeEntry {
    'id': number;
    'identityId': number;
    'timer': string;
    'isLogged': boolean;
    'startedAt': string;
    'createdAt': string;
    'duration': number;
    'clientId': number;
    'projectId': number;
    'pendingClient': string;
    'pendingProject': string;
    'pendingTask': string;
    'taskId': string;
    'serviceId': string;
    'note': string;
    'active': boolean;
    'billable': boolean;
    'billed': boolean;
    'internal': boolean;
    'retainerId': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "identityId",
            "baseName": "identity_id",
            "type": "number"
        },
        {
            "name": "timer",
            "baseName": "timer",
            "type": "string"
        },
        {
            "name": "isLogged",
            "baseName": "is_logged",
            "type": "boolean"
        },
        {
            "name": "startedAt",
            "baseName": "started_at",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "duration",
            "baseName": "duration",
            "type": "number"
        },
        {
            "name": "clientId",
            "baseName": "client_id",
            "type": "number"
        },
        {
            "name": "projectId",
            "baseName": "project_id",
            "type": "number"
        },
        {
            "name": "pendingClient",
            "baseName": "pending_client",
            "type": "string"
        },
        {
            "name": "pendingProject",
            "baseName": "pending_project",
            "type": "string"
        },
        {
            "name": "pendingTask",
            "baseName": "pending_task",
            "type": "string"
        },
        {
            "name": "taskId",
            "baseName": "task_id",
            "type": "string"
        },
        {
            "name": "serviceId",
            "baseName": "service_id",
            "type": "string"
        },
        {
            "name": "note",
            "baseName": "note",
            "type": "string"
        },
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "billable",
            "baseName": "billable",
            "type": "boolean"
        },
        {
            "name": "billed",
            "baseName": "billed",
            "type": "boolean"
        },
        {
            "name": "internal",
            "baseName": "internal",
            "type": "boolean"
        },
        {
            "name": "retainerId",
            "baseName": "retainer_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TimeEntry.attributeTypeMap;
    }
}

export class TimeEntry1 {
    'id': number;
    'identityId': number;
    'timer': string;
    'isLogged': boolean;
    'startedAt': string;
    'createdAt': string;
    'duration': number;
    'clientId': number;
    'projectId': number;
    'pendingClient': string;
    'pendingProject': string;
    'pendingTask': string;
    'taskId': string;
    'serviceId': string;
    'note': string;
    'active': boolean;
    'billable': boolean;
    'billed': boolean;
    'internal': boolean;
    'retainerId': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "identityId",
            "baseName": "identity_id",
            "type": "number"
        },
        {
            "name": "timer",
            "baseName": "timer",
            "type": "string"
        },
        {
            "name": "isLogged",
            "baseName": "is_logged",
            "type": "boolean"
        },
        {
            "name": "startedAt",
            "baseName": "started_at",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "duration",
            "baseName": "duration",
            "type": "number"
        },
        {
            "name": "clientId",
            "baseName": "client_id",
            "type": "number"
        },
        {
            "name": "projectId",
            "baseName": "project_id",
            "type": "number"
        },
        {
            "name": "pendingClient",
            "baseName": "pending_client",
            "type": "string"
        },
        {
            "name": "pendingProject",
            "baseName": "pending_project",
            "type": "string"
        },
        {
            "name": "pendingTask",
            "baseName": "pending_task",
            "type": "string"
        },
        {
            "name": "taskId",
            "baseName": "task_id",
            "type": "string"
        },
        {
            "name": "serviceId",
            "baseName": "service_id",
            "type": "string"
        },
        {
            "name": "note",
            "baseName": "note",
            "type": "string"
        },
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "billable",
            "baseName": "billable",
            "type": "boolean"
        },
        {
            "name": "billed",
            "baseName": "billed",
            "type": "boolean"
        },
        {
            "name": "internal",
            "baseName": "internal",
            "type": "boolean"
        },
        {
            "name": "retainerId",
            "baseName": "retainer_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TimeEntry1.attributeTypeMap;
    }
}

export class TimeEntry3 {
    'id': number;
    'identityId': number;
    'timer': string;
    'isLogged': boolean;
    'startedAt': string;
    'createdAt': string;
    'duration': number;
    'clientId': number;
    'projectId': number;
    'pendingClient': string;
    'pendingProject': string;
    'pendingTask': string;
    'taskId': string;
    'serviceId': string;
    'note': string;
    'active': boolean;
    'billable': boolean;
    'billed': boolean;
    'internal': boolean;
    'retainerId': string;
    'highlight': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "identityId",
            "baseName": "identity_id",
            "type": "number"
        },
        {
            "name": "timer",
            "baseName": "timer",
            "type": "string"
        },
        {
            "name": "isLogged",
            "baseName": "is_logged",
            "type": "boolean"
        },
        {
            "name": "startedAt",
            "baseName": "started_at",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "duration",
            "baseName": "duration",
            "type": "number"
        },
        {
            "name": "clientId",
            "baseName": "client_id",
            "type": "number"
        },
        {
            "name": "projectId",
            "baseName": "project_id",
            "type": "number"
        },
        {
            "name": "pendingClient",
            "baseName": "pending_client",
            "type": "string"
        },
        {
            "name": "pendingProject",
            "baseName": "pending_project",
            "type": "string"
        },
        {
            "name": "pendingTask",
            "baseName": "pending_task",
            "type": "string"
        },
        {
            "name": "taskId",
            "baseName": "task_id",
            "type": "string"
        },
        {
            "name": "serviceId",
            "baseName": "service_id",
            "type": "string"
        },
        {
            "name": "note",
            "baseName": "note",
            "type": "string"
        },
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "billable",
            "baseName": "billable",
            "type": "boolean"
        },
        {
            "name": "billed",
            "baseName": "billed",
            "type": "boolean"
        },
        {
            "name": "internal",
            "baseName": "internal",
            "type": "boolean"
        },
        {
            "name": "retainerId",
            "baseName": "retainer_id",
            "type": "string"
        },
        {
            "name": "highlight",
            "baseName": "highlight",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TimeEntry3.attributeTypeMap;
    }
}

export class TimeEntryDetails {
    'timeEntries': Array<TimeEntry3>;
    'meta': Meta;
    'aggregations': string;
    'downloadToken': string;
    'abilities': Array<Ability2>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "timeEntries",
            "baseName": "time_entries",
            "type": "Array<TimeEntry3>"
        },
        {
            "name": "meta",
            "baseName": "meta",
            "type": "Meta"
        },
        {
            "name": "aggregations",
            "baseName": "aggregations",
            "type": "string"
        },
        {
            "name": "downloadToken",
            "baseName": "download_token",
            "type": "string"
        },
        {
            "name": "abilities",
            "baseName": "abilities",
            "type": "Array<Ability2>"
        }    ];

    static getAttributeTypeMap() {
        return TimeEntryDetails.attributeTypeMap;
    }
}

export class ToggleOnlinePaymentsonInvoiceFreshBooksPayments {
    'response': Response42;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Response42"
        }    ];

    static getAttributeTypeMap() {
        return ToggleOnlinePaymentsonInvoiceFreshBooksPayments.attributeTypeMap;
    }
}

export class ToggleOnlinePaymentsonInvoiceRequest {
    'invoice': Invoice11;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "invoice",
            "baseName": "invoice",
            "type": "Invoice11"
        }    ];

    static getAttributeTypeMap() {
        return ToggleOnlinePaymentsonInvoiceRequest.attributeTypeMap;
    }
}

export class Total {
    'amount': string;
    'code': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "string"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Total.attributeTypeMap;
    }
}

export class TotalDiscount {
    'amount': string;
    'code': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "string"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TotalDiscount.attributeTypeMap;
    }
}

export class TotalExpenses {
    'children': Array<string>;
    'data': Array<string>;
    'description': string;
    'entryType': string;
    'total': Total;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "children",
            "baseName": "children",
            "type": "Array<string>"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<string>"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "entryType",
            "baseName": "entry_type",
            "type": "string"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "Total"
        }    ];

    static getAttributeTypeMap() {
        return TotalExpenses.attributeTypeMap;
    }
}

export class TotalIncome {
    'children': Array<string>;
    'data': Array<string>;
    'description': string;
    'entryType': string;
    'total': Total;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "children",
            "baseName": "children",
            "type": "Array<string>"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<string>"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "entryType",
            "baseName": "entry_type",
            "type": "string"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "Total"
        }    ];

    static getAttributeTypeMap() {
        return TotalIncome.attributeTypeMap;
    }
}

export class TotalInvoiced {
    'amount': string;
    'code': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "string"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TotalInvoiced.attributeTypeMap;
    }
}

export class TotalSales {
    'amount': string;
    'code': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "string"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TotalSales.attributeTypeMap;
    }
}

export class TotalSalesDatum {
    'amount': string;
    'code': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "string"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TotalSalesDatum.attributeTypeMap;
    }
}

export class Totals {
    '_030': Model030;
    '_3160': Model030;
    '_6190': Model030;
    '_91': Model030;
    'total': Total;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_030",
            "baseName": "0-30",
            "type": "Model030"
        },
        {
            "name": "_3160",
            "baseName": "31-60",
            "type": "Model030"
        },
        {
            "name": "_6190",
            "baseName": "61-90",
            "type": "Model030"
        },
        {
            "name": "_91",
            "baseName": "91+",
            "type": "Model030"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "Total"
        }    ];

    static getAttributeTypeMap() {
        return Totals.attributeTypeMap;
    }
}

export class TrialBalance {
    'response': Response76;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Response76"
        }    ];

    static getAttributeTypeMap() {
        return TrialBalance.attributeTypeMap;
    }
}

export class TrialBalance1 {
    'companyName': string;
    'currencyCode': string;
    'data': Array<Datum1>;
    'downloadToken': string;
    'endDate': string;
    'startDate': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "companyName",
            "baseName": "company_name",
            "type": "string"
        },
        {
            "name": "currencyCode",
            "baseName": "currency_code",
            "type": "string"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<Datum1>"
        },
        {
            "name": "downloadToken",
            "baseName": "download_token",
            "type": "string"
        },
        {
            "name": "endDate",
            "baseName": "end_date",
            "type": "string"
        },
        {
            "name": "startDate",
            "baseName": "start_date",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TrialBalance1.attributeTypeMap;
    }
}

export class UndeleteRetainerRequest {
    'retainer': Retainer6;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "retainer",
            "baseName": "retainer",
            "type": "Retainer6"
        }    ];

    static getAttributeTypeMap() {
        return UndeleteRetainerRequest.attributeTypeMap;
    }
}

export class UndeleteRetainerSuccess {
    'retainer': Retainer;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "retainer",
            "baseName": "retainer",
            "type": "Retainer"
        }    ];

    static getAttributeTypeMap() {
        return UndeleteRetainerSuccess.attributeTypeMap;
    }
}

export class UnitCost {
    'amount': string;
    'code': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "string"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UnitCost.attributeTypeMap;
    }
}

export class UpdateClient {
    'response': Response3;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Response3"
        }    ];

    static getAttributeTypeMap() {
        return UpdateClient.attributeTypeMap;
    }
}

export class UpdateClientRequest {
    'client': Client4;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "client",
            "baseName": "client",
            "type": "Client4"
        }    ];

    static getAttributeTypeMap() {
        return UpdateClientRequest.attributeTypeMap;
    }
}

export class UpdateEstimate {
    'response': Response53;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Response53"
        }    ];

    static getAttributeTypeMap() {
        return UpdateEstimate.attributeTypeMap;
    }
}

export class UpdateExpense {
    'response': Response47;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Response47"
        }    ];

    static getAttributeTypeMap() {
        return UpdateExpense.attributeTypeMap;
    }
}

export class UpdateExpenseRequest {
    'expense': Expense5;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "expense",
            "baseName": "expense",
            "type": "Expense5"
        }    ];

    static getAttributeTypeMap() {
        return UpdateExpenseRequest.attributeTypeMap;
    }
}

export class UpdateExpensewithReceiptRequest {
    'expense': Expense3;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "expense",
            "baseName": "expense",
            "type": "Expense3"
        }    ];

    static getAttributeTypeMap() {
        return UpdateExpensewithReceiptRequest.attributeTypeMap;
    }
}

export class UpdateInvoiceProfile {
    'response': Response13;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Response13"
        }    ];

    static getAttributeTypeMap() {
        return UpdateInvoiceProfile.attributeTypeMap;
    }
}

export class UpdateInvoiceProfileRequest {
    'invoiceProfile': InvoiceProfile5;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "invoiceProfile",
            "baseName": "invoice_profile",
            "type": "InvoiceProfile5"
        }    ];

    static getAttributeTypeMap() {
        return UpdateInvoiceProfileRequest.attributeTypeMap;
    }
}

export class UpdateInvoiceRequest {
    'invoice': Invoice8;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "invoice",
            "baseName": "invoice",
            "type": "Invoice8"
        }    ];

    static getAttributeTypeMap() {
        return UpdateInvoiceRequest.attributeTypeMap;
    }
}

export class UpdateInvoiceStatus {
    'response': Response31;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Response31"
        }    ];

    static getAttributeTypeMap() {
        return UpdateInvoiceStatus.attributeTypeMap;
    }
}

export class UpdateInvoicewExpense {
    'response': Response33;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Response33"
        }    ];

    static getAttributeTypeMap() {
        return UpdateInvoicewExpense.attributeTypeMap;
    }
}

export class UpdateItemRequest {
    'item': Item4;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "item",
            "baseName": "item",
            "type": "Item4"
        }    ];

    static getAttributeTypeMap() {
        return UpdateItemRequest.attributeTypeMap;
    }
}

export class UpdatePayment {
    'response': Response25;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Response25"
        }    ];

    static getAttributeTypeMap() {
        return UpdatePayment.attributeTypeMap;
    }
}

export class UpdatePaymentRequest {
    'payment': Payment5;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "payment",
            "baseName": "payment",
            "type": "Payment5"
        }    ];

    static getAttributeTypeMap() {
        return UpdatePaymentRequest.attributeTypeMap;
    }
}

export class UpdateProject {
    'project': Project3;
    'abilities': Array<Ability>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "project",
            "baseName": "project",
            "type": "Project3"
        },
        {
            "name": "abilities",
            "baseName": "abilities",
            "type": "Array<Ability>"
        }    ];

    static getAttributeTypeMap() {
        return UpdateProject.attributeTypeMap;
    }
}

export class UpdateProjectServiceRates {
    'projectServiceRate': ProjectServiceRate1;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "projectServiceRate",
            "baseName": "project_service_rate",
            "type": "ProjectServiceRate1"
        }    ];

    static getAttributeTypeMap() {
        return UpdateProjectServiceRates.attributeTypeMap;
    }
}

export class UpdateRetainerRequest {
    'retainer': Retainer1;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "retainer",
            "baseName": "retainer",
            "type": "Retainer1"
        }    ];

    static getAttributeTypeMap() {
        return UpdateRetainerRequest.attributeTypeMap;
    }
}

export class UpdateRetainerSuccess {
    'retainer': Retainer;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "retainer",
            "baseName": "retainer",
            "type": "Retainer"
        }    ];

    static getAttributeTypeMap() {
        return UpdateRetainerSuccess.attributeTypeMap;
    }
}

export class UpdateServiceRatesRequest {
    'projectServiceRate': ProjectServiceRate;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "projectServiceRate",
            "baseName": "project_service_rate",
            "type": "ProjectServiceRate"
        }    ];

    static getAttributeTypeMap() {
        return UpdateServiceRatesRequest.attributeTypeMap;
    }
}

export class UpdateSingleOtherIncome {
    'response': Response23;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Response23"
        }    ];

    static getAttributeTypeMap() {
        return UpdateSingleOtherIncome.attributeTypeMap;
    }
}

export class UpdateSingleOtherIncomeRequest {
    'otherIncome': OtherIncome3;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "otherIncome",
            "baseName": "other_income",
            "type": "OtherIncome3"
        }    ];

    static getAttributeTypeMap() {
        return UpdateSingleOtherIncomeRequest.attributeTypeMap;
    }
}

export class UpdateSingleTax {
    'response': Response87;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Response87"
        }    ];

    static getAttributeTypeMap() {
        return UpdateSingleTax.attributeTypeMap;
    }
}

export class UpdateSingleTaxRequest {
    'tax': Tax1;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "tax",
            "baseName": "tax",
            "type": "Tax1"
        }    ];

    static getAttributeTypeMap() {
        return UpdateSingleTaxRequest.attributeTypeMap;
    }
}

export class UpdateStaff {
    'response': Response63;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Response63"
        }    ];

    static getAttributeTypeMap() {
        return UpdateStaff.attributeTypeMap;
    }
}

export class UpdateStaffRates {
    'teamMemberRate': TeamMemberRate;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "teamMemberRate",
            "baseName": "team_member_rate",
            "type": "TeamMemberRate"
        }    ];

    static getAttributeTypeMap() {
        return UpdateStaffRates.attributeTypeMap;
    }
}

export class UpdateStaffRequest {
    'staff': Staff1;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "staff",
            "baseName": "staff",
            "type": "Staff1"
        }    ];

    static getAttributeTypeMap() {
        return UpdateStaffRequest.attributeTypeMap;
    }
}

export class UpdateTask {
    'response': Response59;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Response59"
        }    ];

    static getAttributeTypeMap() {
        return UpdateTask.attributeTypeMap;
    }
}

export class UpdateTaskRequest {
    'task': Task4;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "task",
            "baseName": "task",
            "type": "Task4"
        }    ];

    static getAttributeTypeMap() {
        return UpdateTaskRequest.attributeTypeMap;
    }
}

export class UpdateTeamMemberRate {
    'teamMemberRate': TeamMemberRate;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "teamMemberRate",
            "baseName": "team_member_rate",
            "type": "TeamMemberRate"
        }    ];

    static getAttributeTypeMap() {
        return UpdateTeamMemberRate.attributeTypeMap;
    }
}

export class UpdateaTimeEntry {
    'timeEntry': TimeEntry1;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "timeEntry",
            "baseName": "time_entry",
            "type": "TimeEntry1"
        }    ];

    static getAttributeTypeMap() {
        return UpdateaTimeEntry.attributeTypeMap;
    }
}

export class UploadLogo {
    'image': Image;
    'link': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "image",
            "baseName": "image",
            "type": "Image"
        },
        {
            "name": "link",
            "baseName": "link",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UploadLogo.attributeTypeMap;
    }
}

export class UploadLogoError {
    'error': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UploadLogoError.attributeTypeMap;
    }
}

export class Wk6N3K {
    'advancedAccountingAccess': boolean;
    'attachmentsAccess': boolean;
    'businessAccountantLimit': number;
    'clientLimit': number;
    'proposalsCandidateAccess': boolean;
    'richProposalsAccess': boolean;
    'staffLimit': number;
    'betaHeliosAsyncExpensesAccess': boolean;
    'betaMobileCreateExpenseSubcategoryAccess': boolean;
    'iosBetaZendeskWidgetAccess': boolean;
    'mobileReceiptRebillingAccess': boolean;
    'heliosPushnotificationsBetaAccess': boolean;
    'iosBetaPaymentSchedulesAccess': boolean;
    'heliosRebillTimeAccess': boolean;
    'esignaturesAccess': boolean;
    'heliosDashboardAccess': boolean;
    'heliosLateFeeReminderBetaAccess': boolean;
    'heliosBulkActionsInvoicesBetaAccess': boolean;
    'autoBankImportAccess': boolean;
    'heliosVirtualTerminalBetaAccess': boolean;
    'heliosExpenseRebillingBetaAccess': boolean;
    'heliosCompanyTaxesBetaAccess': boolean;
    'heliosInvoiceArchiveBetaAccess': boolean;
    'accountantInviteAccess': boolean;
    'heliosSyncThrottleBetaAccess': boolean;
    'bankReconciliationAccess': boolean;
    'heliosPushResourceToUseExecuteBetaAccess': boolean;
    'newTimeTrackingAccess': boolean;
    'bankRecSmartMatchAccess': boolean;
    'balanceSheetAccess': boolean;
    'invoiceV2SearchAccess': boolean;
    'importItemsCsvAccess': boolean;
    'exportClientsCsvAccess': boolean;
    'heliosVirtualTerminalTutorialBetaAccess': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "advancedAccountingAccess",
            "baseName": "advanced_accounting.access",
            "type": "boolean"
        },
        {
            "name": "attachmentsAccess",
            "baseName": "attachments.access",
            "type": "boolean"
        },
        {
            "name": "businessAccountantLimit",
            "baseName": "business_accountant.limit",
            "type": "number"
        },
        {
            "name": "clientLimit",
            "baseName": "client.limit",
            "type": "number"
        },
        {
            "name": "proposalsCandidateAccess",
            "baseName": "proposals_candidate.access",
            "type": "boolean"
        },
        {
            "name": "richProposalsAccess",
            "baseName": "rich_proposals.access",
            "type": "boolean"
        },
        {
            "name": "staffLimit",
            "baseName": "staff.limit",
            "type": "number"
        },
        {
            "name": "betaHeliosAsyncExpensesAccess",
            "baseName": "BetaHeliosAsyncExpenses.access",
            "type": "boolean"
        },
        {
            "name": "betaMobileCreateExpenseSubcategoryAccess",
            "baseName": "beta_mobile_create_expense_subcategory.access",
            "type": "boolean"
        },
        {
            "name": "iosBetaZendeskWidgetAccess",
            "baseName": "ios_beta_zendesk_widget.access",
            "type": "boolean"
        },
        {
            "name": "mobileReceiptRebillingAccess",
            "baseName": "mobile_receipt_rebilling.access",
            "type": "boolean"
        },
        {
            "name": "heliosPushnotificationsBetaAccess",
            "baseName": "helios_pushnotifications.beta.access",
            "type": "boolean"
        },
        {
            "name": "iosBetaPaymentSchedulesAccess",
            "baseName": "ios_beta_payment_schedules.access",
            "type": "boolean"
        },
        {
            "name": "heliosRebillTimeAccess",
            "baseName": "helios_rebill_time.access",
            "type": "boolean"
        },
        {
            "name": "esignaturesAccess",
            "baseName": "esignatures.access",
            "type": "boolean"
        },
        {
            "name": "heliosDashboardAccess",
            "baseName": "helios_dashboard.access",
            "type": "boolean"
        },
        {
            "name": "heliosLateFeeReminderBetaAccess",
            "baseName": "helios_late_fee_reminder.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosBulkActionsInvoicesBetaAccess",
            "baseName": "helios_bulk_actions_invoices.beta.access",
            "type": "boolean"
        },
        {
            "name": "autoBankImportAccess",
            "baseName": "auto_bank_import.access",
            "type": "boolean"
        },
        {
            "name": "heliosVirtualTerminalBetaAccess",
            "baseName": "helios_virtual_terminal.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosExpenseRebillingBetaAccess",
            "baseName": "helios_expense_rebilling.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosCompanyTaxesBetaAccess",
            "baseName": "helios_company_taxes.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosInvoiceArchiveBetaAccess",
            "baseName": "helios_invoice_archive.beta.access",
            "type": "boolean"
        },
        {
            "name": "accountantInviteAccess",
            "baseName": "accountant_invite.access",
            "type": "boolean"
        },
        {
            "name": "heliosSyncThrottleBetaAccess",
            "baseName": "helios_sync_throttle.beta.access",
            "type": "boolean"
        },
        {
            "name": "bankReconciliationAccess",
            "baseName": "BankReconciliation.access",
            "type": "boolean"
        },
        {
            "name": "heliosPushResourceToUseExecuteBetaAccess",
            "baseName": "helios_push_resource_to_use_execute.beta.access",
            "type": "boolean"
        },
        {
            "name": "newTimeTrackingAccess",
            "baseName": "new_time_tracking.access",
            "type": "boolean"
        },
        {
            "name": "bankRecSmartMatchAccess",
            "baseName": "bank_rec_smart_match.access",
            "type": "boolean"
        },
        {
            "name": "balanceSheetAccess",
            "baseName": "balance_sheet.access",
            "type": "boolean"
        },
        {
            "name": "invoiceV2SearchAccess",
            "baseName": "invoice_v2_search.access",
            "type": "boolean"
        },
        {
            "name": "importItemsCsvAccess",
            "baseName": "import_items_csv.access",
            "type": "boolean"
        },
        {
            "name": "exportClientsCsvAccess",
            "baseName": "export_clients_csv.access",
            "type": "boolean"
        },
        {
            "name": "heliosVirtualTerminalTutorialBetaAccess",
            "baseName": "helios_virtual_terminal_tutorial.beta.access",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Wk6N3K.attributeTypeMap;
    }
}

export class WkMd2g {
    'advancedAccountingAccess': boolean;
    'attachmentsAccess': boolean;
    'businessAccountantLimit': number;
    'clientLimit': number;
    'proposalsCandidateAccess': boolean;
    'richProposalsAccess': boolean;
    'staffLimit': number;
    'betaHeliosAsyncExpensesAccess': boolean;
    'betaMobileCreateExpenseSubcategoryAccess': boolean;
    'iosBetaZendeskWidgetAccess': boolean;
    'mobileReceiptRebillingAccess': boolean;
    'heliosPushnotificationsBetaAccess': boolean;
    'iosBetaPaymentSchedulesAccess': boolean;
    'heliosRebillTimeAccess': boolean;
    'esignaturesAccess': boolean;
    'heliosDashboardAccess': boolean;
    'heliosLateFeeReminderBetaAccess': boolean;
    'heliosBulkActionsInvoicesBetaAccess': boolean;
    'autoBankImportAccess': boolean;
    'heliosVirtualTerminalBetaAccess': boolean;
    'heliosExpenseRebillingBetaAccess': boolean;
    'heliosCompanyTaxesBetaAccess': boolean;
    'heliosInvoiceArchiveBetaAccess': boolean;
    'accountantInviteAccess': boolean;
    'heliosSyncThrottleBetaAccess': boolean;
    'bankReconciliationAccess': boolean;
    'heliosPushResourceToUseExecuteBetaAccess': boolean;
    'newTimeTrackingAccess': boolean;
    'bankRecSmartMatchAccess': boolean;
    'balanceSheetAccess': boolean;
    'invoiceV2SearchAccess': boolean;
    'importItemsCsvAccess': boolean;
    'exportClientsCsvAccess': boolean;
    'heliosVirtualTerminalTutorialBetaAccess': boolean;
    'inlineExpenseEditAccess': boolean;
    'heliosVirtualTerminalAdvertisingBetaAccess': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "advancedAccountingAccess",
            "baseName": "advanced_accounting.access",
            "type": "boolean"
        },
        {
            "name": "attachmentsAccess",
            "baseName": "attachments.access",
            "type": "boolean"
        },
        {
            "name": "businessAccountantLimit",
            "baseName": "business_accountant.limit",
            "type": "number"
        },
        {
            "name": "clientLimit",
            "baseName": "client.limit",
            "type": "number"
        },
        {
            "name": "proposalsCandidateAccess",
            "baseName": "proposals_candidate.access",
            "type": "boolean"
        },
        {
            "name": "richProposalsAccess",
            "baseName": "rich_proposals.access",
            "type": "boolean"
        },
        {
            "name": "staffLimit",
            "baseName": "staff.limit",
            "type": "number"
        },
        {
            "name": "betaHeliosAsyncExpensesAccess",
            "baseName": "BetaHeliosAsyncExpenses.access",
            "type": "boolean"
        },
        {
            "name": "betaMobileCreateExpenseSubcategoryAccess",
            "baseName": "beta_mobile_create_expense_subcategory.access",
            "type": "boolean"
        },
        {
            "name": "iosBetaZendeskWidgetAccess",
            "baseName": "ios_beta_zendesk_widget.access",
            "type": "boolean"
        },
        {
            "name": "mobileReceiptRebillingAccess",
            "baseName": "mobile_receipt_rebilling.access",
            "type": "boolean"
        },
        {
            "name": "heliosPushnotificationsBetaAccess",
            "baseName": "helios_pushnotifications.beta.access",
            "type": "boolean"
        },
        {
            "name": "iosBetaPaymentSchedulesAccess",
            "baseName": "ios_beta_payment_schedules.access",
            "type": "boolean"
        },
        {
            "name": "heliosRebillTimeAccess",
            "baseName": "helios_rebill_time.access",
            "type": "boolean"
        },
        {
            "name": "esignaturesAccess",
            "baseName": "esignatures.access",
            "type": "boolean"
        },
        {
            "name": "heliosDashboardAccess",
            "baseName": "helios_dashboard.access",
            "type": "boolean"
        },
        {
            "name": "heliosLateFeeReminderBetaAccess",
            "baseName": "helios_late_fee_reminder.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosBulkActionsInvoicesBetaAccess",
            "baseName": "helios_bulk_actions_invoices.beta.access",
            "type": "boolean"
        },
        {
            "name": "autoBankImportAccess",
            "baseName": "auto_bank_import.access",
            "type": "boolean"
        },
        {
            "name": "heliosVirtualTerminalBetaAccess",
            "baseName": "helios_virtual_terminal.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosExpenseRebillingBetaAccess",
            "baseName": "helios_expense_rebilling.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosCompanyTaxesBetaAccess",
            "baseName": "helios_company_taxes.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosInvoiceArchiveBetaAccess",
            "baseName": "helios_invoice_archive.beta.access",
            "type": "boolean"
        },
        {
            "name": "accountantInviteAccess",
            "baseName": "accountant_invite.access",
            "type": "boolean"
        },
        {
            "name": "heliosSyncThrottleBetaAccess",
            "baseName": "helios_sync_throttle.beta.access",
            "type": "boolean"
        },
        {
            "name": "bankReconciliationAccess",
            "baseName": "BankReconciliation.access",
            "type": "boolean"
        },
        {
            "name": "heliosPushResourceToUseExecuteBetaAccess",
            "baseName": "helios_push_resource_to_use_execute.beta.access",
            "type": "boolean"
        },
        {
            "name": "newTimeTrackingAccess",
            "baseName": "new_time_tracking.access",
            "type": "boolean"
        },
        {
            "name": "bankRecSmartMatchAccess",
            "baseName": "bank_rec_smart_match.access",
            "type": "boolean"
        },
        {
            "name": "balanceSheetAccess",
            "baseName": "balance_sheet.access",
            "type": "boolean"
        },
        {
            "name": "invoiceV2SearchAccess",
            "baseName": "invoice_v2_search.access",
            "type": "boolean"
        },
        {
            "name": "importItemsCsvAccess",
            "baseName": "import_items_csv.access",
            "type": "boolean"
        },
        {
            "name": "exportClientsCsvAccess",
            "baseName": "export_clients_csv.access",
            "type": "boolean"
        },
        {
            "name": "heliosVirtualTerminalTutorialBetaAccess",
            "baseName": "helios_virtual_terminal_tutorial.beta.access",
            "type": "boolean"
        },
        {
            "name": "inlineExpenseEditAccess",
            "baseName": "inline_expense_edit.access",
            "type": "boolean"
        },
        {
            "name": "heliosVirtualTerminalAdvertisingBetaAccess",
            "baseName": "helios_virtual_terminal_advertising.beta.access",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return WkMd2g.attributeTypeMap;
    }
}

export class WkMd2g1 {
    'advancedAccountingAccess': boolean;
    'attachmentsAccess': boolean;
    'businessAccountantLimit': number;
    'clientLimit': number;
    'proposalsCandidateAccess': boolean;
    'richProposalsAccess': boolean;
    'staffLimit': number;
    'betaHeliosAsyncExpensesAccess': boolean;
    'betaMobileCreateExpenseSubcategoryAccess': boolean;
    'iosBetaZendeskWidgetAccess': boolean;
    'mobileReceiptRebillingAccess': boolean;
    'heliosPushnotificationsBetaAccess': boolean;
    'iosBetaPaymentSchedulesAccess': boolean;
    'heliosRebillTimeAccess': boolean;
    'esignaturesAccess': boolean;
    'heliosDashboardAccess': boolean;
    'heliosLateFeeReminderBetaAccess': boolean;
    'heliosBulkActionsInvoicesBetaAccess': boolean;
    'autoBankImportAccess': boolean;
    'heliosVirtualTerminalBetaAccess': boolean;
    'heliosExpenseRebillingBetaAccess': boolean;
    'heliosCompanyTaxesBetaAccess': boolean;
    'heliosInvoiceArchiveBetaAccess': boolean;
    'accountantInviteAccess': boolean;
    'heliosSyncThrottleBetaAccess': boolean;
    'bankReconciliationAccess': boolean;
    'heliosPushResourceToUseExecuteBetaAccess': boolean;
    'newTimeTrackingAccess': boolean;
    'bankRecSmartMatchAccess': boolean;
    'balanceSheetAccess': boolean;
    'invoiceV2SearchAccess': boolean;
    'importItemsCsvAccess': boolean;
    'exportClientsCsvAccess': boolean;
    'heliosVirtualTerminalTutorialBetaAccess': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "advancedAccountingAccess",
            "baseName": "advanced_accounting.access",
            "type": "boolean"
        },
        {
            "name": "attachmentsAccess",
            "baseName": "attachments.access",
            "type": "boolean"
        },
        {
            "name": "businessAccountantLimit",
            "baseName": "business_accountant.limit",
            "type": "number"
        },
        {
            "name": "clientLimit",
            "baseName": "client.limit",
            "type": "number"
        },
        {
            "name": "proposalsCandidateAccess",
            "baseName": "proposals_candidate.access",
            "type": "boolean"
        },
        {
            "name": "richProposalsAccess",
            "baseName": "rich_proposals.access",
            "type": "boolean"
        },
        {
            "name": "staffLimit",
            "baseName": "staff.limit",
            "type": "number"
        },
        {
            "name": "betaHeliosAsyncExpensesAccess",
            "baseName": "BetaHeliosAsyncExpenses.access",
            "type": "boolean"
        },
        {
            "name": "betaMobileCreateExpenseSubcategoryAccess",
            "baseName": "beta_mobile_create_expense_subcategory.access",
            "type": "boolean"
        },
        {
            "name": "iosBetaZendeskWidgetAccess",
            "baseName": "ios_beta_zendesk_widget.access",
            "type": "boolean"
        },
        {
            "name": "mobileReceiptRebillingAccess",
            "baseName": "mobile_receipt_rebilling.access",
            "type": "boolean"
        },
        {
            "name": "heliosPushnotificationsBetaAccess",
            "baseName": "helios_pushnotifications.beta.access",
            "type": "boolean"
        },
        {
            "name": "iosBetaPaymentSchedulesAccess",
            "baseName": "ios_beta_payment_schedules.access",
            "type": "boolean"
        },
        {
            "name": "heliosRebillTimeAccess",
            "baseName": "helios_rebill_time.access",
            "type": "boolean"
        },
        {
            "name": "esignaturesAccess",
            "baseName": "esignatures.access",
            "type": "boolean"
        },
        {
            "name": "heliosDashboardAccess",
            "baseName": "helios_dashboard.access",
            "type": "boolean"
        },
        {
            "name": "heliosLateFeeReminderBetaAccess",
            "baseName": "helios_late_fee_reminder.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosBulkActionsInvoicesBetaAccess",
            "baseName": "helios_bulk_actions_invoices.beta.access",
            "type": "boolean"
        },
        {
            "name": "autoBankImportAccess",
            "baseName": "auto_bank_import.access",
            "type": "boolean"
        },
        {
            "name": "heliosVirtualTerminalBetaAccess",
            "baseName": "helios_virtual_terminal.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosExpenseRebillingBetaAccess",
            "baseName": "helios_expense_rebilling.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosCompanyTaxesBetaAccess",
            "baseName": "helios_company_taxes.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosInvoiceArchiveBetaAccess",
            "baseName": "helios_invoice_archive.beta.access",
            "type": "boolean"
        },
        {
            "name": "accountantInviteAccess",
            "baseName": "accountant_invite.access",
            "type": "boolean"
        },
        {
            "name": "heliosSyncThrottleBetaAccess",
            "baseName": "helios_sync_throttle.beta.access",
            "type": "boolean"
        },
        {
            "name": "bankReconciliationAccess",
            "baseName": "BankReconciliation.access",
            "type": "boolean"
        },
        {
            "name": "heliosPushResourceToUseExecuteBetaAccess",
            "baseName": "helios_push_resource_to_use_execute.beta.access",
            "type": "boolean"
        },
        {
            "name": "newTimeTrackingAccess",
            "baseName": "new_time_tracking.access",
            "type": "boolean"
        },
        {
            "name": "bankRecSmartMatchAccess",
            "baseName": "bank_rec_smart_match.access",
            "type": "boolean"
        },
        {
            "name": "balanceSheetAccess",
            "baseName": "balance_sheet.access",
            "type": "boolean"
        },
        {
            "name": "invoiceV2SearchAccess",
            "baseName": "invoice_v2_search.access",
            "type": "boolean"
        },
        {
            "name": "importItemsCsvAccess",
            "baseName": "import_items_csv.access",
            "type": "boolean"
        },
        {
            "name": "exportClientsCsvAccess",
            "baseName": "export_clients_csv.access",
            "type": "boolean"
        },
        {
            "name": "heliosVirtualTerminalTutorialBetaAccess",
            "baseName": "helios_virtual_terminal_tutorial.beta.access",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return WkMd2g1.attributeTypeMap;
    }
}

export class X34yX {
    'attachmentsAccess': boolean;
    'clientLimit': number;
    'richProposalsAccess': boolean;
    'staffLimit': number;
    'betaMobileCreateExpenseSubcategoryAccess': boolean;
    'iosBetaZendeskWidgetAccess': boolean;
    'mobileReceiptRebillingAccess': boolean;
    'proposalsCandidateAccess': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "attachmentsAccess",
            "baseName": "attachments.access",
            "type": "boolean"
        },
        {
            "name": "clientLimit",
            "baseName": "client.limit",
            "type": "number"
        },
        {
            "name": "richProposalsAccess",
            "baseName": "rich_proposals.access",
            "type": "boolean"
        },
        {
            "name": "staffLimit",
            "baseName": "staff.limit",
            "type": "number"
        },
        {
            "name": "betaMobileCreateExpenseSubcategoryAccess",
            "baseName": "beta_mobile_create_expense_subcategory.access",
            "type": "boolean"
        },
        {
            "name": "iosBetaZendeskWidgetAccess",
            "baseName": "ios_beta_zendesk_widget.access",
            "type": "boolean"
        },
        {
            "name": "mobileReceiptRebillingAccess",
            "baseName": "mobile_receipt_rebilling.access",
            "type": "boolean"
        },
        {
            "name": "proposalsCandidateAccess",
            "baseName": "proposals_candidate.access",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return X34yX.attributeTypeMap;
    }
}

export class XgGiT {
    'clientLimit': number;
    'staffLimit': number;
    'betaMobileCreateExpenseSubcategoryAccess': boolean;
    'iosBetaZendeskWidgetAccess': boolean;
    'mobileReceiptRebillingAccess': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "clientLimit",
            "baseName": "client.limit",
            "type": "number"
        },
        {
            "name": "staffLimit",
            "baseName": "staff.limit",
            "type": "number"
        },
        {
            "name": "betaMobileCreateExpenseSubcategoryAccess",
            "baseName": "beta_mobile_create_expense_subcategory.access",
            "type": "boolean"
        },
        {
            "name": "iosBetaZendeskWidgetAccess",
            "baseName": "ios_beta_zendesk_widget.access",
            "type": "boolean"
        },
        {
            "name": "mobileReceiptRebillingAccess",
            "baseName": "mobile_receipt_rebilling.access",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return XgGiT.attributeTypeMap;
    }
}

export class YA0R2P {
    'advancedAccountingAccess': boolean;
    'attachmentsAccess': boolean;
    'businessAccountantLimit': number;
    'clientLimit': number;
    'proposalsCandidateAccess': boolean;
    'richProposalsAccess': boolean;
    'staffLimit': number;
    'betaHeliosAsyncExpensesAccess': boolean;
    'betaMobileCreateExpenseSubcategoryAccess': boolean;
    'iosBetaZendeskWidgetAccess': boolean;
    'mobileReceiptRebillingAccess': boolean;
    'heliosPushnotificationsBetaAccess': boolean;
    'iosBetaPaymentSchedulesAccess': boolean;
    'heliosRebillTimeAccess': boolean;
    'esignaturesAccess': boolean;
    'heliosDashboardAccess': boolean;
    'heliosLateFeeReminderBetaAccess': boolean;
    'heliosBulkActionsInvoicesBetaAccess': boolean;
    'autoBankImportAccess': boolean;
    'heliosVirtualTerminalBetaAccess': boolean;
    'heliosExpenseRebillingBetaAccess': boolean;
    'heliosCompanyTaxesBetaAccess': boolean;
    'heliosInvoiceArchiveBetaAccess': boolean;
    'accountantInviteAccess': boolean;
    'heliosSyncThrottleBetaAccess': boolean;
    'bankReconciliationAccess': boolean;
    'heliosPushResourceToUseExecuteBetaAccess': boolean;
    'newTimeTrackingAccess': boolean;
    'bankRecSmartMatchAccess': boolean;
    'balanceSheetAccess': boolean;
    'invoiceV2SearchAccess': boolean;
    'importItemsCsvAccess': boolean;
    'exportClientsCsvAccess': boolean;
    'heliosVirtualTerminalTutorialBetaAccess': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "advancedAccountingAccess",
            "baseName": "advanced_accounting.access",
            "type": "boolean"
        },
        {
            "name": "attachmentsAccess",
            "baseName": "attachments.access",
            "type": "boolean"
        },
        {
            "name": "businessAccountantLimit",
            "baseName": "business_accountant.limit",
            "type": "number"
        },
        {
            "name": "clientLimit",
            "baseName": "client.limit",
            "type": "number"
        },
        {
            "name": "proposalsCandidateAccess",
            "baseName": "proposals_candidate.access",
            "type": "boolean"
        },
        {
            "name": "richProposalsAccess",
            "baseName": "rich_proposals.access",
            "type": "boolean"
        },
        {
            "name": "staffLimit",
            "baseName": "staff.limit",
            "type": "number"
        },
        {
            "name": "betaHeliosAsyncExpensesAccess",
            "baseName": "BetaHeliosAsyncExpenses.access",
            "type": "boolean"
        },
        {
            "name": "betaMobileCreateExpenseSubcategoryAccess",
            "baseName": "beta_mobile_create_expense_subcategory.access",
            "type": "boolean"
        },
        {
            "name": "iosBetaZendeskWidgetAccess",
            "baseName": "ios_beta_zendesk_widget.access",
            "type": "boolean"
        },
        {
            "name": "mobileReceiptRebillingAccess",
            "baseName": "mobile_receipt_rebilling.access",
            "type": "boolean"
        },
        {
            "name": "heliosPushnotificationsBetaAccess",
            "baseName": "helios_pushnotifications.beta.access",
            "type": "boolean"
        },
        {
            "name": "iosBetaPaymentSchedulesAccess",
            "baseName": "ios_beta_payment_schedules.access",
            "type": "boolean"
        },
        {
            "name": "heliosRebillTimeAccess",
            "baseName": "helios_rebill_time.access",
            "type": "boolean"
        },
        {
            "name": "esignaturesAccess",
            "baseName": "esignatures.access",
            "type": "boolean"
        },
        {
            "name": "heliosDashboardAccess",
            "baseName": "helios_dashboard.access",
            "type": "boolean"
        },
        {
            "name": "heliosLateFeeReminderBetaAccess",
            "baseName": "helios_late_fee_reminder.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosBulkActionsInvoicesBetaAccess",
            "baseName": "helios_bulk_actions_invoices.beta.access",
            "type": "boolean"
        },
        {
            "name": "autoBankImportAccess",
            "baseName": "auto_bank_import.access",
            "type": "boolean"
        },
        {
            "name": "heliosVirtualTerminalBetaAccess",
            "baseName": "helios_virtual_terminal.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosExpenseRebillingBetaAccess",
            "baseName": "helios_expense_rebilling.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosCompanyTaxesBetaAccess",
            "baseName": "helios_company_taxes.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosInvoiceArchiveBetaAccess",
            "baseName": "helios_invoice_archive.beta.access",
            "type": "boolean"
        },
        {
            "name": "accountantInviteAccess",
            "baseName": "accountant_invite.access",
            "type": "boolean"
        },
        {
            "name": "heliosSyncThrottleBetaAccess",
            "baseName": "helios_sync_throttle.beta.access",
            "type": "boolean"
        },
        {
            "name": "bankReconciliationAccess",
            "baseName": "BankReconciliation.access",
            "type": "boolean"
        },
        {
            "name": "heliosPushResourceToUseExecuteBetaAccess",
            "baseName": "helios_push_resource_to_use_execute.beta.access",
            "type": "boolean"
        },
        {
            "name": "newTimeTrackingAccess",
            "baseName": "new_time_tracking.access",
            "type": "boolean"
        },
        {
            "name": "bankRecSmartMatchAccess",
            "baseName": "bank_rec_smart_match.access",
            "type": "boolean"
        },
        {
            "name": "balanceSheetAccess",
            "baseName": "balance_sheet.access",
            "type": "boolean"
        },
        {
            "name": "invoiceV2SearchAccess",
            "baseName": "invoice_v2_search.access",
            "type": "boolean"
        },
        {
            "name": "importItemsCsvAccess",
            "baseName": "import_items_csv.access",
            "type": "boolean"
        },
        {
            "name": "exportClientsCsvAccess",
            "baseName": "export_clients_csv.access",
            "type": "boolean"
        },
        {
            "name": "heliosVirtualTerminalTutorialBetaAccess",
            "baseName": "helios_virtual_terminal_tutorial.beta.access",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return YA0R2P.attributeTypeMap;
    }
}

export class ZaZdo {
    'attachmentsAccess': boolean;
    'clientLimit': number;
    'richProposalsAccess': boolean;
    'staffLimit': number;
    'advancedAccountingAccess': boolean;
    'betaMobileCreateExpenseSubcategoryAccess': boolean;
    'iosBetaZendeskWidgetAccess': boolean;
    'mobileReceiptRebillingAccess': boolean;
    'proposalsCandidateAccess': boolean;
    'heliosPushnotificationsBetaAccess': boolean;
    'esignaturesAccess': boolean;
    'autoBankImportAccess': boolean;
    'heliosCompanyTaxesBetaAccess': boolean;
    'heliosInvoiceArchiveBetaAccess': boolean;
    'heliosSyncThrottleBetaAccess': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "attachmentsAccess",
            "baseName": "attachments.access",
            "type": "boolean"
        },
        {
            "name": "clientLimit",
            "baseName": "client.limit",
            "type": "number"
        },
        {
            "name": "richProposalsAccess",
            "baseName": "rich_proposals.access",
            "type": "boolean"
        },
        {
            "name": "staffLimit",
            "baseName": "staff.limit",
            "type": "number"
        },
        {
            "name": "advancedAccountingAccess",
            "baseName": "advanced_accounting.access",
            "type": "boolean"
        },
        {
            "name": "betaMobileCreateExpenseSubcategoryAccess",
            "baseName": "beta_mobile_create_expense_subcategory.access",
            "type": "boolean"
        },
        {
            "name": "iosBetaZendeskWidgetAccess",
            "baseName": "ios_beta_zendesk_widget.access",
            "type": "boolean"
        },
        {
            "name": "mobileReceiptRebillingAccess",
            "baseName": "mobile_receipt_rebilling.access",
            "type": "boolean"
        },
        {
            "name": "proposalsCandidateAccess",
            "baseName": "proposals_candidate.access",
            "type": "boolean"
        },
        {
            "name": "heliosPushnotificationsBetaAccess",
            "baseName": "helios_pushnotifications.beta.access",
            "type": "boolean"
        },
        {
            "name": "esignaturesAccess",
            "baseName": "esignatures.access",
            "type": "boolean"
        },
        {
            "name": "autoBankImportAccess",
            "baseName": "auto_bank_import.access",
            "type": "boolean"
        },
        {
            "name": "heliosCompanyTaxesBetaAccess",
            "baseName": "helios_company_taxes.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosInvoiceArchiveBetaAccess",
            "baseName": "helios_invoice_archive.beta.access",
            "type": "boolean"
        },
        {
            "name": "heliosSyncThrottleBetaAccess",
            "baseName": "helios_sync_throttle.beta.access",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return ZaZdo.attributeTypeMap;
    }
}


let enumsMap: {[index: string]: any} = {
}

let typeMap: {[index: string]: any} = {
    "Abilities": Abilities,
    "Abilities1": Abilities1,
    "Ability": Ability,
    "Ability2": Ability2,
    "AcceptEstimateRequest": AcceptEstimateRequest,
    "Account": Account,
    "Account1": Account1,
    "Account2": Account2,
    "AccountBusiness": AccountBusiness,
    "AccountsAging": AccountsAging,
    "AccountsAging1": AccountsAging1,
    "AddBusiness": AddBusiness,
    "AddBusinessRequest": AddBusinessRequest,
    "AddCommenttoProjectDiscussionMessageRequest": AddCommenttoProjectDiscussionMessageRequest,
    "AddJournalEntry": AddJournalEntry,
    "AddJournalEntryRequest": AddJournalEntryRequest,
    "Address": Address,
    "AddressAttributes": AddressAttributes,
    "AllowedGateway": AllowedGateway,
    "Amount": Amount,
    "Amount35": Amount35,
    "ApwodA": ApwodA,
    "AssetsTotal": AssetsTotal,
    "Attachment": Attachment,
    "Attachment1": Attachment1,
    "Attachment2": Attachment2,
    "BRAVo": BRAVo,
    "Balance": Balance,
    "Balance1": Balance1,
    "BalanceSheet": BalanceSheet,
    "BalanceSheet1": BalanceSheet1,
    "BankInfo": BankInfo,
    "Business": Business,
    "BusinessClient": BusinessClient,
    "BusinessGroup": BusinessGroup,
    "BusinessMembership": BusinessMembership,
    "BusinessMembership1": BusinessMembership1,
    "Callback": Callback,
    "Callback1": Callback1,
    "Category": Category,
    "Category2": Category2,
    "Child": Child,
    "Client": Client,
    "Client1": Client1,
    "Client2": Client2,
    "Client4": Client4,
    "Client6": Client6,
    "ClientBusiness": ClientBusiness,
    "Comment": Comment,
    "Contact": Contact,
    "Contact1": Contact1,
    "CreateCustomExpenseCategory": CreateCustomExpenseCategory,
    "CreateExpense": CreateExpense,
    "CreateExpenseRequest": CreateExpenseRequest,
    "CreateExpensewithReceiptRequest": CreateExpensewithReceiptRequest,
    "CreateItem": CreateItem,
    "CreateItemRequest": CreateItemRequest,
    "CreateNewMessageinProjectDiscussionRequest": CreateNewMessageinProjectDiscussionRequest,
    "CreateRecurringExpenseRequest": CreateRecurringExpenseRequest,
    "CreateRetainerRequest": CreateRetainerRequest,
    "CreateRetainerRetainerforclientalreadyexists": CreateRetainerRetainerforclientalreadyexists,
    "CreateRetainerSuccess": CreateRetainerSuccess,
    "CreateSingleInvoiceProfile": CreateSingleInvoiceProfile,
    "CreateSingleOtherIncome": CreateSingleOtherIncome,
    "CreateSingleOtherIncomeRequest": CreateSingleOtherIncomeRequest,
    "CreateSingleProject": CreateSingleProject,
    "CreateSingleTax": CreateSingleTax,
    "CreateSingleTax1": CreateSingleTax1,
    "CreateSingleTaxRequest": CreateSingleTaxRequest,
    "CreateTask": CreateTask,
    "CreateTaskRequest": CreateTaskRequest,
    "CreateaTimeEntry": CreateaTimeEntry,
    "Credit": Credit,
    "Credit1": Credit1,
    "Datum": Datum,
    "Datum1": Datum1,
    "Debit": Debit,
    "Debit1": Debit1,
    "DeleteBusiness": DeleteBusiness,
    "DeleteBusinessMustDeleteSubscriptionfirst": DeleteBusinessMustDeleteSubscriptionfirst,
    "DeleteEstimate": DeleteEstimate,
    "DeleteEstimateRequest": DeleteEstimateRequest,
    "DeleteExpenseRequest": DeleteExpenseRequest,
    "DeleteInvoice": DeleteInvoice,
    "DeleteInvoiceProfile": DeleteInvoiceProfile,
    "DeleteInvoiceProfileRequest": DeleteInvoiceProfileRequest,
    "DeleteInvoiceRequest": DeleteInvoiceRequest,
    "DeleteItemRequest": DeleteItemRequest,
    "DeletePayment": DeletePayment,
    "DeletePaymentRequest": DeletePaymentRequest,
    "DeleteProject": DeleteProject,
    "DeleteProjectRequest": DeleteProjectRequest,
    "DeleteRetainerRequest": DeleteRetainerRequest,
    "DeleteRetainerSuccess": DeleteRetainerSuccess,
    "DeleteSingleOtherIncome": DeleteSingleOtherIncome,
    "DeleteSingleOtherIncomeRequest": DeleteSingleOtherIncomeRequest,
    "DeleteSingleTax": DeleteSingleTax,
    "DeleteStaff": DeleteStaff,
    "DeleteStaffRequest": DeleteStaffRequest,
    "DeleteTask": DeleteTask,
    "DeleteTaskRequest": DeleteTaskRequest,
    "Detail": Detail,
    "Detail1": Detail1,
    "Discount": Discount,
    "DiscountTotal": DiscountTotal,
    "DowO0g": DowO0g,
    "E1rYq": E1rYq,
    "E4MaY": E4MaY,
    "E86QZ": E86QZ,
    "EditSecondaryContactIDRequest": EditSecondaryContactIDRequest,
    "EeCnZ": EeCnZ,
    "Entry": Entry,
    "Error5": Error5,
    "Estimate": Estimate,
    "Estimate2": Estimate2,
    "Estimate4": Estimate4,
    "Estimate6": Estimate6,
    "Expense": Expense,
    "Expense1": Expense1,
    "Expense2": Expense2,
    "Expense3": Expense3,
    "Expense5": Expense5,
    "Expense6": Expense6,
    "Expense8": Expense8,
    "Expense9": Expense9,
    "ExpenseProfile": ExpenseProfile,
    "ExpenseSummariesResponse": ExpenseSummariesResponse,
    "Fbpay": Fbpay,
    "G2MB3M": G2MB3M,
    "GatewayConnection": GatewayConnection,
    "GatewayDetails": GatewayDetails,
    "GeneralLedger": GeneralLedger,
    "GetSingleInvoiceProfile": GetSingleInvoiceProfile,
    "GetSingleTax": GetSingleTax,
    "GetSystem": GetSystem,
    "GetallretainersSuccess": GetallretainersSuccess,
    "Getdefaultinvoicepresentationstyles": Getdefaultinvoicepresentationstyles,
    "GetindividualRetainersuccess": GetindividualRetainersuccess,
    "Gr1ndR": Gr1ndR,
    "Group": Group,
    "Group2": Group2,
    "Group3": Group3,
    "GstAmount": GstAmount,
    "IdentityInfoCall": IdentityInfoCall,
    "Image": Image,
    "Income": Income,
    "InvitationRates": InvitationRates,
    "Invoice": Invoice,
    "Invoice1": Invoice1,
    "Invoice11": Invoice11,
    "Invoice12": Invoice12,
    "Invoice13": Invoice13,
    "Invoice2": Invoice2,
    "Invoice3": Invoice3,
    "Invoice4": Invoice4,
    "Invoice6": Invoice6,
    "Invoice8": Invoice8,
    "InvoiceDetails": InvoiceDetails,
    "InvoiceDetails1": InvoiceDetails1,
    "InvoiceProfile": InvoiceProfile,
    "InvoiceProfile1": InvoiceProfile1,
    "InvoiceProfile2": InvoiceProfile2,
    "InvoiceProfile3": InvoiceProfile3,
    "InvoiceProfile5": InvoiceProfile5,
    "Item": Item,
    "Item1": Item1,
    "Item4": Item4,
    "Item6": Item6,
    "Item8": Item8,
    "ItemSales": ItemSales,
    "ItemSales1": ItemSales1,
    "J1412": J1412,
    "J9hAK": J9hAK,
    "JournalEntry": JournalEntry,
    "JournalEntry1": JournalEntry1,
    "JournalEntryAccount": JournalEntryAccount,
    "JournalEntryDetails": JournalEntryDetails,
    "JournalEntryDetails1": JournalEntryDetails1,
    "LJZ1p3": LJZ1p3,
    "LWn0vG": LWn0vG,
    "LiabilitiesAndEquityTotal": LiabilitiesAndEquityTotal,
    "Links": Links,
    "Links1": Links1,
    "ListClients": ListClients,
    "ListEntries": ListEntries,
    "ListEstimates": ListEstimates,
    "ListExpenseCategories": ListExpenseCategories,
    "ListExpenses": ListExpenses,
    "ListGateways": ListGateways,
    "ListInvoiceProfiles": ListInvoiceProfiles,
    "ListInvoices": ListInvoices,
    "ListOtherIncome": ListOtherIncome,
    "ListPayments": ListPayments,
    "ListProjects": ListProjects,
    "ListStaff": ListStaff,
    "ListTasks": ListTasks,
    "ListTaxes": ListTaxes,
    "ListUser": ListUser,
    "ListWebhookCallbacks": ListWebhookCallbacks,
    "M1GeK": M1GeK,
    "M1oaR": M1oaR,
    "MakePayment": MakePayment,
    "Member": Member,
    "Member3": Member3,
    "Meta": Meta,
    "Meta1": Meta1,
    "Model030": Model030,
    "Model3ErwB": Model3ErwB,
    "Model3x42x2": Model3x42x2,
    "Model4WMVg": Model4WMVg,
    "Model5o0MVd": Model5o0MVd,
    "Model7Po26": Model7Po26,
    "Model7lwxR": Model7lwxR,
    "Model85lLQg": Model85lLQg,
    "Model8NppA": Model8NppA,
    "ModelError": ModelError,
    "NetProfit": NetProfit,
    "NetTax": NetTax,
    "NetTaxableAmount": NetTaxableAmount,
    "NewClient": NewClient,
    "NewClientRequest": NewClientRequest,
    "ON6yL": ON6yL,
    "OtherIncome": OtherIncome,
    "OtherIncome1": OtherIncome1,
    "OtherIncome2": OtherIncome2,
    "OtherIncome3": OtherIncome3,
    "OtherIncome4": OtherIncome4,
    "OtherIncome5": OtherIncome5,
    "Outstanding": Outstanding,
    "PPLMZ": PPLMZ,
    "Paid": Paid,
    "Payment": Payment,
    "Payment2": Payment2,
    "Payment3": Payment3,
    "Payment5": Payment5,
    "PaymentAmount": PaymentAmount,
    "PaymentsCollected": PaymentsCollected,
    "PaymentsCollected1": PaymentsCollected1,
    "Pe4MW": Pe4MW,
    "Permissions": Permissions,
    "Permissions1": Permissions1,
    "PhoneNumber": PhoneNumber,
    "PhoneNumber1": PhoneNumber1,
    "Presentation": Presentation,
    "Presentation1": Presentation1,
    "Pricing": Pricing,
    "Profession": Profession,
    "Profession2": Profession2,
    "Profile": Profile,
    "Profile1": Profile1,
    "ProfitLossReport": ProfitLossReport,
    "Profitloss": Profitloss,
    "Project": Project,
    "Project1": Project1,
    "Project2": Project2,
    "Project3": Project3,
    "Project4": Project4,
    "ProjectServiceRate": ProjectServiceRate,
    "ProjectServiceRate1": ProjectServiceRate1,
    "ProvisionFreshBooksPaymentsRequest": ProvisionFreshBooksPaymentsRequest,
    "RAlTo": RAlTo,
    "Rate": Rate,
    "RegisterasanewuserRequest": RegisterasanewuserRequest,
    "RegisterforCallbackRequest": RegisterforCallbackRequest,
    "RemoveAllSecondaryContactsRequest": RemoveAllSecondaryContactsRequest,
    "ResendVerificationCodeRequest": ResendVerificationCodeRequest,
    "Response": Response,
    "Response1": Response1,
    "Response12": Response12,
    "Response13": Response13,
    "Response15": Response15,
    "Response18": Response18,
    "Response2": Response2,
    "Response21": Response21,
    "Response22": Response22,
    "Response23": Response23,
    "Response25": Response25,
    "Response26": Response26,
    "Response27": Response27,
    "Response3": Response3,
    "Response30": Response30,
    "Response31": Response31,
    "Response32": Response32,
    "Response33": Response33,
    "Response34": Response34,
    "Response39": Response39,
    "Response4": Response4,
    "Response42": Response42,
    "Response43": Response43,
    "Response44": Response44,
    "Response45": Response45,
    "Response47": Response47,
    "Response48": Response48,
    "Response49": Response49,
    "Response5": Response5,
    "Response50": Response50,
    "Response52": Response52,
    "Response53": Response53,
    "Response54": Response54,
    "Response58": Response58,
    "Response59": Response59,
    "Response63": Response63,
    "Response64": Response64,
    "Response67": Response67,
    "Response68": Response68,
    "Response69": Response69,
    "Response7": Response7,
    "Response70": Response70,
    "Response71": Response71,
    "Response72": Response72,
    "Response73": Response73,
    "Response75": Response75,
    "Response76": Response76,
    "Response77": Response77,
    "Response78": Response78,
    "Response79": Response79,
    "Response84": Response84,
    "Response85": Response85,
    "Response87": Response87,
    "Response89": Response89,
    "Response91": Response91,
    "Result": Result,
    "Result1": Result1,
    "Result10": Result10,
    "Result11": Result11,
    "Result14": Result14,
    "Result16": Result16,
    "Result17": Result17,
    "Result18": Result18,
    "Result2": Result2,
    "Result20": Result20,
    "Result21": Result21,
    "Result22": Result22,
    "Result25": Result25,
    "Result26": Result26,
    "Result27": Result27,
    "Result28": Result28,
    "Result29": Result29,
    "Result34": Result34,
    "Result35": Result35,
    "Result36": Result36,
    "Result37": Result37,
    "Result39": Result39,
    "Result4": Result4,
    "Result40": Result40,
    "Result41": Result41,
    "Result42": Result42,
    "Result44": Result44,
    "Result45": Result45,
    "Result46": Result46,
    "Result50": Result50,
    "Result51": Result51,
    "Result55": Result55,
    "Result57": Result57,
    "Result58": Result58,
    "Result59": Result59,
    "Result60": Result60,
    "Result61": Result61,
    "Result62": Result62,
    "Result63": Result63,
    "Result64": Result64,
    "Result65": Result65,
    "Result66": Result66,
    "Result67": Result67,
    "Result68": Result68,
    "Result73": Result73,
    "Result74": Result74,
    "Result75": Result75,
    "Result77": Result77,
    "Result78": Result78,
    "Result9": Result9,
    "Retainer": Retainer,
    "Retainer1": Retainer1,
    "Retainer6": Retainer6,
    "RevenueByClient": RevenueByClient,
    "RevenueByClient1": RevenueByClient1,
    "RmpKp": RmpKp,
    "Role": Role,
    "SalesTaxSummary": SalesTaxSummary,
    "Service": Service,
    "Service1": Service1,
    "ServiceRates": ServiceRates,
    "ServiceRates1": ServiceRates1,
    "ShareLink": ShareLink,
    "ShareLink1": ShareLink1,
    "SingleClient": SingleClient,
    "SingleEstimate": SingleEstimate,
    "SingleEstimateWithEstimateLines": SingleEstimateWithEstimateLines,
    "SingleExpenseCategory": SingleExpenseCategory,
    "SingleInvoice": SingleInvoice,
    "SingleInvoicewLineItems": SingleInvoicewLineItems,
    "SingleInvoicewLogo": SingleInvoicewLogo,
    "SingleInvoicewLogoandstyles": SingleInvoicewLogoandstyles,
    "SingleInvoicewPaymentGateway": SingleInvoicewPaymentGateway,
    "SingleItem": SingleItem,
    "SinglePayment": SinglePayment,
    "SingleProject": SingleProject,
    "SingleStaff": SingleStaff,
    "SingleTask": SingleTask,
    "Staff": Staff,
    "Staff1": Staff1,
    "Staff3": Staff3,
    "Stripe": Stripe,
    "SubAccount": SubAccount,
    "SubAccount1": SubAccount1,
    "SubAccount2": SubAccount2,
    "SubscriptionStatuses": SubscriptionStatuses,
    "SubscriptionStatuses1": SubscriptionStatuses1,
    "Summary": Summary,
    "Summary1": Summary1,
    "System": System,
    "Task": Task,
    "Task2": Task2,
    "Task4": Task4,
    "Task6": Task6,
    "Tax": Tax,
    "Tax1": Tax1,
    "Tax2": Tax2,
    "TaxAmount1": TaxAmount1,
    "TaxAmount11": TaxAmount11,
    "TaxCollected": TaxCollected,
    "TaxPaid": TaxPaid,
    "TaxableAmountCollected": TaxableAmountCollected,
    "TaxableAmountPaid": TaxableAmountPaid,
    "Taxis": Taxis,
    "Taxis1": Taxis1,
    "Taxis3": Taxis3,
    "Taxis7": Taxis7,
    "Taxsummary": Taxsummary,
    "TeamMemberRate": TeamMemberRate,
    "TeamMemberRates": TeamMemberRates,
    "TeamMemberRates1": TeamMemberRates1,
    "Thread": Thread,
    "TimeEntry": TimeEntry,
    "TimeEntry1": TimeEntry1,
    "TimeEntry3": TimeEntry3,
    "TimeEntryDetails": TimeEntryDetails,
    "ToggleOnlinePaymentsonInvoiceFreshBooksPayments": ToggleOnlinePaymentsonInvoiceFreshBooksPayments,
    "ToggleOnlinePaymentsonInvoiceRequest": ToggleOnlinePaymentsonInvoiceRequest,
    "Total": Total,
    "TotalDiscount": TotalDiscount,
    "TotalExpenses": TotalExpenses,
    "TotalIncome": TotalIncome,
    "TotalInvoiced": TotalInvoiced,
    "TotalSales": TotalSales,
    "TotalSalesDatum": TotalSalesDatum,
    "Totals": Totals,
    "TrialBalance": TrialBalance,
    "TrialBalance1": TrialBalance1,
    "UndeleteRetainerRequest": UndeleteRetainerRequest,
    "UndeleteRetainerSuccess": UndeleteRetainerSuccess,
    "UnitCost": UnitCost,
    "UpdateClient": UpdateClient,
    "UpdateClientRequest": UpdateClientRequest,
    "UpdateEstimate": UpdateEstimate,
    "UpdateExpense": UpdateExpense,
    "UpdateExpenseRequest": UpdateExpenseRequest,
    "UpdateExpensewithReceiptRequest": UpdateExpensewithReceiptRequest,
    "UpdateInvoiceProfile": UpdateInvoiceProfile,
    "UpdateInvoiceProfileRequest": UpdateInvoiceProfileRequest,
    "UpdateInvoiceRequest": UpdateInvoiceRequest,
    "UpdateInvoiceStatus": UpdateInvoiceStatus,
    "UpdateInvoicewExpense": UpdateInvoicewExpense,
    "UpdateItemRequest": UpdateItemRequest,
    "UpdatePayment": UpdatePayment,
    "UpdatePaymentRequest": UpdatePaymentRequest,
    "UpdateProject": UpdateProject,
    "UpdateProjectServiceRates": UpdateProjectServiceRates,
    "UpdateRetainerRequest": UpdateRetainerRequest,
    "UpdateRetainerSuccess": UpdateRetainerSuccess,
    "UpdateServiceRatesRequest": UpdateServiceRatesRequest,
    "UpdateSingleOtherIncome": UpdateSingleOtherIncome,
    "UpdateSingleOtherIncomeRequest": UpdateSingleOtherIncomeRequest,
    "UpdateSingleTax": UpdateSingleTax,
    "UpdateSingleTaxRequest": UpdateSingleTaxRequest,
    "UpdateStaff": UpdateStaff,
    "UpdateStaffRates": UpdateStaffRates,
    "UpdateStaffRequest": UpdateStaffRequest,
    "UpdateTask": UpdateTask,
    "UpdateTaskRequest": UpdateTaskRequest,
    "UpdateTeamMemberRate": UpdateTeamMemberRate,
    "UpdateaTimeEntry": UpdateaTimeEntry,
    "UploadLogo": UploadLogo,
    "UploadLogoError": UploadLogoError,
    "Wk6N3K": Wk6N3K,
    "WkMd2g": WkMd2g,
    "WkMd2g1": WkMd2g1,
    "X34yX": X34yX,
    "XgGiT": XgGiT,
    "YA0R2P": YA0R2P,
    "ZaZdo": ZaZdo,
}

export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: localVarRequest.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string = '';

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}

export class VoidAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(_: localVarRequest.Options): void {
        // Do nothing
    }
}

export enum AbilitiesApiApiKeys {
}

export class AbilitiesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'auth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AbilitiesApiApiKeys, value: string) {
        (this.authentications as any)[AbilitiesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.auth.accessToken = token;
    }
    /**
     * TODO: Add Description
     * @summary Abilities
     * @param businessId 
     * @param {*} [options] Override http request options.
     */
    public projectsBusinessAbilitiesByBusinessIdGet (businessId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Abilities;  }> {
        const localVarPath = this.basePath + '/projects/business/{businessId}/abilities'
            .replace('{' + 'businessId' + '}', encodeURIComponent(String(businessId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'businessId' is not null or undefined
        if (businessId === null || businessId === undefined) {
            throw new Error('Required parameter businessId was null or undefined when calling projectsBusinessAbilitiesByBusinessIdGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Abilities;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Abilities");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AuthorizationApiApiKeys {
}

export class AuthorizationApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'auth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AuthorizationApiApiKeys, value: string) {
        (this.authentications as any)[AuthorizationApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.auth.accessToken = token;
    }
    /**
     * TODO: Add Description
     * @summary Register as a new user
     * @param contentType 
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public authApiV1SmuxRegistrationsPost (contentType: string, body: RegisterasanewuserRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/auth/api/v1/smux/registrations';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling authApiV1SmuxRegistrationsPost.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling authApiV1SmuxRegistrationsPost.');
        }

        localVarHeaderParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "RegisterasanewuserRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * TODO: Add Description
     * @summary Identity Info Call
     * @param {*} [options] Override http request options.
     */
    public authApiV1UsersMeGet (options: any = {}) : Promise<{ response: http.ClientResponse; body: IdentityInfoCall;  }> {
        const localVarPath = this.basePath + '/auth/api/v1/users/me';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: IdentityInfoCall;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "IdentityInfoCall");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum BusinessesApiApiKeys {
}

export class BusinessesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'auth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: BusinessesApiApiKeys, value: string) {
        (this.authentications as any)[BusinessesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.auth.accessToken = token;
    }
    /**
     * TODO: Add Description
     * @summary Delete Business - Subscription
     * @param contentType 
     * @param {*} [options] Override http request options.
     */
    public authApiV1BillingAccount0XaOwSubscriptionDelete (contentType: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: DeleteBusiness;  }> {
        const localVarPath = this.basePath + '/auth/api/v1/billing/account/0XaOw/subscription';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling authApiV1BillingAccount0XaOwSubscriptionDelete.');
        }

        localVarHeaderParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DeleteBusiness;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DeleteBusiness");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * TODO: Add Description
     * @summary Delete Business
     * @param contentType 
     * @param {*} [options] Override http request options.
     */
    public authApiV1UsersBusiness685582Delete (contentType: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/auth/api/v1/users/business/685582';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling authApiV1UsersBusiness685582Delete.');
        }

        localVarHeaderParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * TODO: Add Description
     * @summary Add Business
     * @param contentType 
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public authApiV1UsersBusinessPost (contentType: string, body: AddBusinessRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: AddBusiness;  }> {
        const localVarPath = this.basePath + '/auth/api/v1/users/business';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling authApiV1UsersBusinessPost.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling authApiV1UsersBusinessPost.');
        }

        localVarHeaderParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "AddBusinessRequest")
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AddBusiness;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AddBusiness");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * TODO: Add Description
     * @summary Gateway Details
     * @param accountId 
     * @param {*} [options] Override http request options.
     */
    public paymentsAccountGatewayByAccountIdGet (accountId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: GatewayDetails;  }> {
        const localVarPath = this.basePath + '/payments/account/{accountId}/gateway'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling paymentsAccountGatewayByAccountIdGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GatewayDetails;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GatewayDetails");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * TODO: Add Description
     * @summary Provision FreshBooks Payments
     * @param contentType 
     * @param body 
     * @param accountId 
     * @param {*} [options] Override http request options.
     */
    public paymentsAccountGatewayFbpayByAccountIdPost (contentType: string, body: ProvisionFreshBooksPaymentsRequest, accountId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/payments/account/{accountId}/gateway/fbpay'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling paymentsAccountGatewayFbpayByAccountIdPost.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling paymentsAccountGatewayFbpayByAccountIdPost.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling paymentsAccountGatewayFbpayByAccountIdPost.');
        }

        localVarHeaderParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ProvisionFreshBooksPaymentsRequest")
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ClientsApiApiKeys {
}

export class ClientsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'auth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ClientsApiApiKeys, value: string) {
        (this.authentications as any)[ClientsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.auth.accessToken = token;
    }
    /**
     * Get a single client with the parameter associated with clientId
     * @summary Single Client
     * @param contentType 
     * @param accountId 
     * @param customerId 
     * @param {*} [options] Override http request options.
     */
    public accountingAccountUsersClientsByAccountIdAndCustomerIdGet (contentType: string, accountId: string, customerId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: SingleClient;  }> {
        const localVarPath = this.basePath + '/accounting/account/{accountId}/users/clients/{customerId}'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'customerId' + '}', encodeURIComponent(String(customerId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling accountingAccountUsersClientsByAccountIdAndCustomerIdGet.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling accountingAccountUsersClientsByAccountIdAndCustomerIdGet.');
        }

        // verify required parameter 'customerId' is not null or undefined
        if (customerId === null || customerId === undefined) {
            throw new Error('Required parameter customerId was null or undefined when calling accountingAccountUsersClientsByAccountIdAndCustomerIdGet.');
        }

        localVarHeaderParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SingleClient;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SingleClient");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * TODO: Add Description
     * @summary Update Client
     * @param contentType 
     * @param body 
     * @param accountId 
     * @param customerId 
     * @param {*} [options] Override http request options.
     */
    public accountingAccountUsersClientsByAccountIdAndCustomerIdPut (contentType: string, body: UpdateClientRequest, accountId: string, customerId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: UpdateClient;  }> {
        const localVarPath = this.basePath + '/accounting/account/{accountId}/users/clients/{customerId}'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'customerId' + '}', encodeURIComponent(String(customerId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling accountingAccountUsersClientsByAccountIdAndCustomerIdPut.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling accountingAccountUsersClientsByAccountIdAndCustomerIdPut.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling accountingAccountUsersClientsByAccountIdAndCustomerIdPut.');
        }

        // verify required parameter 'customerId' is not null or undefined
        if (customerId === null || customerId === undefined) {
            throw new Error('Required parameter customerId was null or undefined when calling accountingAccountUsersClientsByAccountIdAndCustomerIdPut.');
        }

        localVarHeaderParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "UpdateClientRequest")
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UpdateClient;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UpdateClient");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * list all clients
     * @summary List Clients
     * @param contentType 
     * @param accountId 
     * @param {*} [options] Override http request options.
     */
    public accountingAccountUsersClientsByAccountIdGet (contentType: string, accountId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: ListClients;  }> {
        const localVarPath = this.basePath + '/accounting/account/{accountId}/users/clients'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling accountingAccountUsersClientsByAccountIdGet.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling accountingAccountUsersClientsByAccountIdGet.');
        }

        localVarHeaderParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ListClients;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ListClients");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Note: If you do not add an `organization` to your Client object, `organization` will automatically be added as the client's first and last name. 
     * @summary New Client
     * @param contentType 
     * @param body 
     * @param accountId 
     * @param {*} [options] Override http request options.
     */
    public accountingAccountUsersClientsByAccountIdPost (contentType: string, body: NewClientRequest, accountId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: NewClient;  }> {
        const localVarPath = this.basePath + '/accounting/account/{accountId}/users/clients'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling accountingAccountUsersClientsByAccountIdPost.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling accountingAccountUsersClientsByAccountIdPost.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling accountingAccountUsersClientsByAccountIdPost.');
        }

        localVarHeaderParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "NewClientRequest")
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: NewClient;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "NewClient");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Will remove all secondary contacts for a single Client Profile
     * @summary Remove All Secondary Contacts
     * @param contentType 
     * @param body 
     * @param accountid 
     * @param customerid 
     * @param {*} [options] Override http request options.
     */
    public accountingAccountUsersClientsByAccountidAndCustomeridPut (contentType: string, body: RemoveAllSecondaryContactsRequest, accountid: string, customerid: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/accounting/account/{accountid}/users/clients/{customerid}'
            .replace('{' + 'accountid' + '}', encodeURIComponent(String(accountid)))
            .replace('{' + 'customerid' + '}', encodeURIComponent(String(customerid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling accountingAccountUsersClientsByAccountidAndCustomeridPut.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling accountingAccountUsersClientsByAccountidAndCustomeridPut.');
        }

        // verify required parameter 'accountid' is not null or undefined
        if (accountid === null || accountid === undefined) {
            throw new Error('Required parameter accountid was null or undefined when calling accountingAccountUsersClientsByAccountidAndCustomeridPut.');
        }

        // verify required parameter 'customerid' is not null or undefined
        if (customerid === null || customerid === undefined) {
            throw new Error('Required parameter customerid was null or undefined when calling accountingAccountUsersClientsByAccountidAndCustomeridPut.');
        }

        localVarHeaderParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "RemoveAllSecondaryContactsRequest")
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Deletes the specified secondary contactid
     * @summary Delete Secondary  Contact ID
     * @param accountid 
     * @param contactid 
     * @param {*} [options] Override http request options.
     */
    public accountingAccountUsersContactsByAccountidAndContactidDelete (accountid: string, contactid: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/accounting/account/{accountid}/users/contacts/{contactid}'
            .replace('{' + 'accountid' + '}', encodeURIComponent(String(accountid)))
            .replace('{' + 'contactid' + '}', encodeURIComponent(String(contactid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountid' is not null or undefined
        if (accountid === null || accountid === undefined) {
            throw new Error('Required parameter accountid was null or undefined when calling accountingAccountUsersContactsByAccountidAndContactidDelete.');
        }

        // verify required parameter 'contactid' is not null or undefined
        if (contactid === null || contactid === undefined) {
            throw new Error('Required parameter contactid was null or undefined when calling accountingAccountUsersContactsByAccountidAndContactidDelete.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Allows you to edit a specific secondary contact
     * @summary Edit Secondary Contact ID
     * @param contentType 
     * @param body 
     * @param accountid 
     * @param contactid 
     * @param {*} [options] Override http request options.
     */
    public accountingAccountUsersContactsByAccountidAndContactidPut (contentType: string, body: EditSecondaryContactIDRequest, accountid: string, contactid: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/accounting/account/{accountid}/users/contacts/{contactid}'
            .replace('{' + 'accountid' + '}', encodeURIComponent(String(accountid)))
            .replace('{' + 'contactid' + '}', encodeURIComponent(String(contactid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling accountingAccountUsersContactsByAccountidAndContactidPut.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling accountingAccountUsersContactsByAccountidAndContactidPut.');
        }

        // verify required parameter 'accountid' is not null or undefined
        if (accountid === null || accountid === undefined) {
            throw new Error('Required parameter accountid was null or undefined when calling accountingAccountUsersContactsByAccountidAndContactidPut.');
        }

        // verify required parameter 'contactid' is not null or undefined
        if (contactid === null || contactid === undefined) {
            throw new Error('Required parameter contactid was null or undefined when calling accountingAccountUsersContactsByAccountidAndContactidPut.');
        }

        localVarHeaderParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "EditSecondaryContactIDRequest")
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum EstimatesApiApiKeys {
}

export class EstimatesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'auth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: EstimatesApiApiKeys, value: string) {
        (this.authentications as any)[EstimatesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.auth.accessToken = token;
    }
    /**
     * TODO: Add Description
     * @summary Single Estimate
     * @param accountId 
     * @param estimateId 
     * @param {*} [options] Override http request options.
     */
    public accountingAccountEstimatesEstimatesByAccountIdAndEstimateIdGet (accountId: string, estimateId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: SingleEstimate;  }> {
        const localVarPath = this.basePath + '/accounting/account/{accountId}/estimates/estimates/{estimateId}'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'estimateId' + '}', encodeURIComponent(String(estimateId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling accountingAccountEstimatesEstimatesByAccountIdAndEstimateIdGet.');
        }

        // verify required parameter 'estimateId' is not null or undefined
        if (estimateId === null || estimateId === undefined) {
            throw new Error('Required parameter estimateId was null or undefined when calling accountingAccountEstimatesEstimatesByAccountIdAndEstimateIdGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SingleEstimate;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SingleEstimate");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * TODO: Add Description
     * @summary Delete Estimate
     * @param contentType 
     * @param body 
     * @param accountId 
     * @param estimateId 
     * @param {*} [options] Override http request options.
     */
    public accountingAccountEstimatesEstimatesByAccountIdAndEstimateIdPut (contentType: string, body: DeleteEstimateRequest, accountId: string, estimateId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: DeleteEstimate;  }> {
        const localVarPath = this.basePath + '/accounting/account/{accountId}/estimates/estimates/{estimateId}'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'estimateId' + '}', encodeURIComponent(String(estimateId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling accountingAccountEstimatesEstimatesByAccountIdAndEstimateIdPut.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling accountingAccountEstimatesEstimatesByAccountIdAndEstimateIdPut.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling accountingAccountEstimatesEstimatesByAccountIdAndEstimateIdPut.');
        }

        // verify required parameter 'estimateId' is not null or undefined
        if (estimateId === null || estimateId === undefined) {
            throw new Error('Required parameter estimateId was null or undefined when calling accountingAccountEstimatesEstimatesByAccountIdAndEstimateIdPut.');
        }

        localVarHeaderParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "DeleteEstimateRequest")
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DeleteEstimate;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DeleteEstimate");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get an entire list of estimates that exist within your account.
     * @summary List Estimates
     * @param contentType 
     * @param accountId 
     * @param {*} [options] Override http request options.
     */
    public accountingAccountEstimatesEstimatesByAccountIdGet (contentType: string, accountId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: ListEstimates;  }> {
        const localVarPath = this.basePath + '/accounting/account/{accountId}/estimates/estimates'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling accountingAccountEstimatesEstimatesByAccountIdGet.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling accountingAccountEstimatesEstimatesByAccountIdGet.');
        }

        localVarHeaderParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ListEstimates;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ListEstimates");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Creates a single estimate with multiple estimate lines and a logo and colourway.
     * @summary Single Estimate With Estimate Lines
     * @param contentType 
     * @param body 
     * @param accountId 
     * @param {*} [options] Override http request options.
     */
    public accountingAccountEstimatesEstimatesByAccountIdPost (contentType: string, body: string, accountId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: SingleEstimateWithEstimateLines;  }> {
        const localVarPath = this.basePath + '/accounting/account/{accountId}/estimates/estimates'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling accountingAccountEstimatesEstimatesByAccountIdPost.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling accountingAccountEstimatesEstimatesByAccountIdPost.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling accountingAccountEstimatesEstimatesByAccountIdPost.');
        }

        localVarHeaderParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "string")
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SingleEstimateWithEstimateLines;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SingleEstimateWithEstimateLines");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a single proposal that has sections, logos, and requires an e-signature from the customer
     * @summary Create Single Proposal w/ Sections, Logos, and E-signature
     * @param contentType 
     * @param body 
     * @param accountid 
     * @param {*} [options] Override http request options.
     */
    public accountingAccountEstimatesEstimatesByAccountidPost (contentType: string, body: string, accountid: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/accounting/account/{accountid}/estimates/estimates'
            .replace('{' + 'accountid' + '}', encodeURIComponent(String(accountid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling accountingAccountEstimatesEstimatesByAccountidPost.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling accountingAccountEstimatesEstimatesByAccountidPost.');
        }

        // verify required parameter 'accountid' is not null or undefined
        if (accountid === null || accountid === undefined) {
            throw new Error('Required parameter accountid was null or undefined when calling accountingAccountEstimatesEstimatesByAccountidPost.');
        }

        localVarHeaderParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "string")
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Updating an estimate with a 30% discount. 
     * @summary Update Estimate
     * @param contentType 
     * @param body 
     * @param estimateId 
     * @param {*} [options] Override http request options.
     */
    public byEstimateIdPut (contentType: string, body: string, estimateId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: UpdateEstimate;  }> {
        const localVarPath = this.basePath + '/{estimateId}'
            .replace('{' + 'estimateId' + '}', encodeURIComponent(String(estimateId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling byEstimateIdPut.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling byEstimateIdPut.');
        }

        // verify required parameter 'estimateId' is not null or undefined
        if (estimateId === null || estimateId === undefined) {
            throw new Error('Required parameter estimateId was null or undefined when calling byEstimateIdPut.');
        }

        localVarHeaderParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "string")
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UpdateEstimate;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UpdateEstimate");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ExpensesApiApiKeys {
}

export class ExpensesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'auth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ExpensesApiApiKeys, value: string) {
        (this.authentications as any)[ExpensesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.auth.accessToken = token;
    }
    /**
     * TODO: Add Description
     * @summary Create Recurring Expense
     * @param contentType 
     * @param body 
     * @param accountid 
     * @param {*} [options] Override http request options.
     */
    public accountingAccountExpenseProfilesExpenseProfilesByAccountidPost (contentType: string, body: CreateRecurringExpenseRequest, accountid: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/accounting/account/{accountid}/expense_profiles/expense_profiles'
            .replace('{' + 'accountid' + '}', encodeURIComponent(String(accountid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling accountingAccountExpenseProfilesExpenseProfilesByAccountidPost.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling accountingAccountExpenseProfilesExpenseProfilesByAccountidPost.');
        }

        // verify required parameter 'accountid' is not null or undefined
        if (accountid === null || accountid === undefined) {
            throw new Error('Required parameter accountid was null or undefined when calling accountingAccountExpenseProfilesExpenseProfilesByAccountidPost.');
        }

        localVarHeaderParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CreateRecurringExpenseRequest")
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * TODO: Add Description
     * @summary Single Expense Category
     * @param contentType 
     * @param accountId 
     * @param categoryId 
     * @param {*} [options] Override http request options.
     */
    public accountingAccountExpensesCategoriesByAccountIdAndCategoryIdGet (contentType: string, accountId: string, categoryId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: SingleExpenseCategory;  }> {
        const localVarPath = this.basePath + '/accounting/account/{accountId}/expenses/categories/{categoryId}'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'categoryId' + '}', encodeURIComponent(String(categoryId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling accountingAccountExpensesCategoriesByAccountIdAndCategoryIdGet.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling accountingAccountExpensesCategoriesByAccountIdAndCategoryIdGet.');
        }

        // verify required parameter 'categoryId' is not null or undefined
        if (categoryId === null || categoryId === undefined) {
            throw new Error('Required parameter categoryId was null or undefined when calling accountingAccountExpensesCategoriesByAccountIdAndCategoryIdGet.');
        }

        localVarHeaderParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SingleExpenseCategory;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SingleExpenseCategory");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * TODO: Add Description
     * @summary List Expense Categories
     * @param contentType 
     * @param accountId 
     * @param {*} [options] Override http request options.
     */
    public accountingAccountExpensesCategoriesByAccountIdGet (contentType: string, accountId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: ListExpenseCategories;  }> {
        const localVarPath = this.basePath + '/accounting/account/{accountId}/expenses/categories'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling accountingAccountExpensesCategoriesByAccountIdGet.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling accountingAccountExpensesCategoriesByAccountIdGet.');
        }

        localVarHeaderParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ListExpenseCategories;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ListExpenseCategories");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Custome expense categories require a parent category ID. Please make a call to list expense categories to find the parent ID you'd like.
     * @summary Create Custom Expense Category
     * @param contentType 
     * @param body 
     * @param accountId 
     * @param {*} [options] Override http request options.
     */
    public accountingAccountExpensesCategoriesByAccountIdPost (contentType: string, body: string, accountId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: CreateCustomExpenseCategory;  }> {
        const localVarPath = this.basePath + '/accounting/account/{accountId}/expenses/categories'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling accountingAccountExpensesCategoriesByAccountIdPost.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling accountingAccountExpensesCategoriesByAccountIdPost.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling accountingAccountExpensesCategoriesByAccountIdPost.');
        }

        localVarHeaderParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "string")
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CreateCustomExpenseCategory;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CreateCustomExpenseCategory");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * TODO: Add Description
     * @summary Single Expense
     * @param include Include attachments (Receipt images)
     * @param contentType 
     * @param accountId 
     * @param expenseId 
     * @param {*} [options] Override http request options.
     */
    public accountingAccountExpensesExpensesByAccountIdAndExpenseIdGet (include: string, contentType: string, accountId: string, expenseId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/accounting/account/{accountId}/expenses/expenses/{expenseId}'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'expenseId' + '}', encodeURIComponent(String(expenseId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'include' is not null or undefined
        if (include === null || include === undefined) {
            throw new Error('Required parameter include was null or undefined when calling accountingAccountExpensesExpensesByAccountIdAndExpenseIdGet.');
        }

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling accountingAccountExpensesExpensesByAccountIdAndExpenseIdGet.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling accountingAccountExpensesExpensesByAccountIdAndExpenseIdGet.');
        }

        // verify required parameter 'expenseId' is not null or undefined
        if (expenseId === null || expenseId === undefined) {
            throw new Error('Required parameter expenseId was null or undefined when calling accountingAccountExpensesExpensesByAccountIdAndExpenseIdGet.');
        }

        if (include !== undefined) {
            localVarQueryParameters['include[]'] = ObjectSerializer.serialize(include, "string");
        }

        localVarHeaderParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * TODO: Add Description
     * @summary Update Expense
     * @param contentType 
     * @param body 
     * @param accountId 
     * @param expenseId 
     * @param {*} [options] Override http request options.
     */
    public accountingAccountExpensesExpensesByAccountIdAndExpenseIdPut (contentType: string, body: UpdateExpenseRequest, accountId: string, expenseId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: UpdateExpense;  }> {
        const localVarPath = this.basePath + '/accounting/account/{accountId}/expenses/expenses/{expenseId}'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'expenseId' + '}', encodeURIComponent(String(expenseId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling accountingAccountExpensesExpensesByAccountIdAndExpenseIdPut.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling accountingAccountExpensesExpensesByAccountIdAndExpenseIdPut.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling accountingAccountExpensesExpensesByAccountIdAndExpenseIdPut.');
        }

        // verify required parameter 'expenseId' is not null or undefined
        if (expenseId === null || expenseId === undefined) {
            throw new Error('Required parameter expenseId was null or undefined when calling accountingAccountExpensesExpensesByAccountIdAndExpenseIdPut.');
        }

        localVarHeaderParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "UpdateExpenseRequest")
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UpdateExpense;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UpdateExpense");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get all expenses 
     * @summary List Expenses
     * @param include includes attachment details assocatied with expense receipts
     * @param contentType 
     * @param accountId 
     * @param {*} [options] Override http request options.
     */
    public accountingAccountExpensesExpensesByAccountIdGet (include: string, contentType: string, accountId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: ListExpenses;  }> {
        const localVarPath = this.basePath + '/accounting/account/{accountId}/expenses/expenses'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'include' is not null or undefined
        if (include === null || include === undefined) {
            throw new Error('Required parameter include was null or undefined when calling accountingAccountExpensesExpensesByAccountIdGet.');
        }

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling accountingAccountExpensesExpensesByAccountIdGet.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling accountingAccountExpensesExpensesByAccountIdGet.');
        }

        if (include !== undefined) {
            localVarQueryParameters['include[]'] = ObjectSerializer.serialize(include, "string");
        }

        localVarHeaderParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ListExpenses;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ListExpenses");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Category can be passed as categoryid or category_name, both as string values.
     * @summary Create Expense
     * @param include5B5D 
     * @param contentType 
     * @param body 
     * @param accountId 
     * @param {*} [options] Override http request options.
     */
    public accountingAccountExpensesExpensesByAccountIdPost (include5B5D: string, contentType: string, body: CreateExpenseRequest, accountId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: CreateExpense;  }> {
        const localVarPath = this.basePath + '/accounting/account/{accountId}/expenses/expenses'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'include5B5D' is not null or undefined
        if (include5B5D === null || include5B5D === undefined) {
            throw new Error('Required parameter include5B5D was null or undefined when calling accountingAccountExpensesExpensesByAccountIdPost.');
        }

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling accountingAccountExpensesExpensesByAccountIdPost.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling accountingAccountExpensesExpensesByAccountIdPost.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling accountingAccountExpensesExpensesByAccountIdPost.');
        }

        if (include5B5D !== undefined) {
            localVarQueryParameters['include%5B%5D'] = ObjectSerializer.serialize(include5B5D, "string");
        }

        localVarHeaderParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CreateExpenseRequest")
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CreateExpense;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CreateExpense");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * This endpoint will return summaries of the total amounts of expenses by active, archived, and grand total.   Active means not archived or deleted.  Archived is simply reorganizing the experience on FreshBooks so they're tucked away nicely. They will still show up on your reports and count towards active clients.   Deleted clients will be removed from your active clients list, however, any activity related to those accounts will not show up on your reports.  
     * @summary Expense Summaries
     * @param accountId 
     * @param {*} [options] Override http request options.
     */
    public accountingAccountExpensesSummariesByAccountIdGet (accountId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: ExpenseSummariesResponse;  }> {
        const localVarPath = this.basePath + '/accounting/account/{accountId}/expenses/summaries'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling accountingAccountExpensesSummariesByAccountIdGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ExpenseSummariesResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ExpenseSummariesResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of expense vendors
     * @summary Expense Vendors
     * @param accountId 
     * @param {*} [options] Override http request options.
     */
    public accountingAccountExpensesVendorsByAccountIdGet (accountId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/accounting/account/{accountId}/expenses/vendors'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling accountingAccountExpensesVendorsByAccountIdGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum InvoiceLinksDownloadsApiApiKeys {
}

export class InvoiceLinksDownloadsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'auth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: InvoiceLinksDownloadsApiApiKeys, value: string) {
        (this.authentications as any)[InvoiceLinksDownloadsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.auth.accessToken = token;
    }
    /**
     * TODO: Add Description
     * @summary Download Invoice PDF
     * @param accept 
     * @param accountId 
     * @param invoiceId 
     * @param {*} [options] Override http request options.
     */
    public accountingAccountInvoicesInvoicesPdfByAccountIdAndInvoiceIdGet (accept: string, accountId: string, invoiceId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/accounting/account/{accountId}/invoices/invoices/{invoiceId}/pdf'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'invoiceId' + '}', encodeURIComponent(String(invoiceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accept' is not null or undefined
        if (accept === null || accept === undefined) {
            throw new Error('Required parameter accept was null or undefined when calling accountingAccountInvoicesInvoicesPdfByAccountIdAndInvoiceIdGet.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling accountingAccountInvoicesInvoicesPdfByAccountIdAndInvoiceIdGet.');
        }

        // verify required parameter 'invoiceId' is not null or undefined
        if (invoiceId === null || invoiceId === undefined) {
            throw new Error('Required parameter invoiceId was null or undefined when calling accountingAccountInvoicesInvoicesPdfByAccountIdAndInvoiceIdGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * TODO: Add Description
     * @summary Share Link
     * @param shareMethod &#x60;share_link&#x60;, &#x60;email&#x60;, &#x60;sms&#x60;, &#x60;pdf&#x60;
     * @param accountId 
     * @param invoiceId 
     * @param {*} [options] Override http request options.
     */
    public accountingAccountInvoicesInvoicesShareLinkByAccountIdAndInvoiceIdGet (shareMethod: string, accountId: string, invoiceId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: ShareLink;  }> {
        const localVarPath = this.basePath + '/accounting/account/{accountId}/invoices/invoices/{invoiceId}/share_link'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'invoiceId' + '}', encodeURIComponent(String(invoiceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'shareMethod' is not null or undefined
        if (shareMethod === null || shareMethod === undefined) {
            throw new Error('Required parameter shareMethod was null or undefined when calling accountingAccountInvoicesInvoicesShareLinkByAccountIdAndInvoiceIdGet.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling accountingAccountInvoicesInvoicesShareLinkByAccountIdAndInvoiceIdGet.');
        }

        // verify required parameter 'invoiceId' is not null or undefined
        if (invoiceId === null || invoiceId === undefined) {
            throw new Error('Required parameter invoiceId was null or undefined when calling accountingAccountInvoicesInvoicesShareLinkByAccountIdAndInvoiceIdGet.');
        }

        if (shareMethod !== undefined) {
            localVarQueryParameters['share_method'] = ObjectSerializer.serialize(shareMethod, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ShareLink;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ShareLink");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum InvoiceRecurringTemplateApiApiKeys {
}

export class InvoiceRecurringTemplateApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'auth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: InvoiceRecurringTemplateApiApiKeys, value: string) {
        (this.authentications as any)[InvoiceRecurringTemplateApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.auth.accessToken = token;
    }
    /**
     *  
     * @summary Get Single Invoice Profile
     * @param content 
     * @param accountId 
     * @param invoiceProfileId 
     * @param {*} [options] Override http request options.
     */
    public accountingAccountInvoiceProfilesInvoiceProfilesByAccountIdAndInvoiceProfileIdGet (content: string, accountId: string, invoiceProfileId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: GetSingleInvoiceProfile;  }> {
        const localVarPath = this.basePath + '/accounting/account/{accountId}/invoice_profiles/invoice_profiles/{invoiceProfileId}'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'invoiceProfileId' + '}', encodeURIComponent(String(invoiceProfileId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'content' is not null or undefined
        if (content === null || content === undefined) {
            throw new Error('Required parameter content was null or undefined when calling accountingAccountInvoiceProfilesInvoiceProfilesByAccountIdAndInvoiceProfileIdGet.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling accountingAccountInvoiceProfilesInvoiceProfilesByAccountIdAndInvoiceProfileIdGet.');
        }

        // verify required parameter 'invoiceProfileId' is not null or undefined
        if (invoiceProfileId === null || invoiceProfileId === undefined) {
            throw new Error('Required parameter invoiceProfileId was null or undefined when calling accountingAccountInvoiceProfilesInvoiceProfilesByAccountIdAndInvoiceProfileIdGet.');
        }

        localVarHeaderParams['content'] = ObjectSerializer.serialize(content, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetSingleInvoiceProfile;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetSingleInvoiceProfile");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * TODO: Add Description
     * @summary Delete  Invoice Profile
     * @param contentType 
     * @param body 
     * @param accountId 
     * @param invoiceProfileId 
     * @param {*} [options] Override http request options.
     */
    public accountingAccountInvoiceProfilesInvoiceProfilesByAccountIdAndInvoiceProfileIdPut (contentType: string, body: DeleteInvoiceProfileRequest, accountId: string, invoiceProfileId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: DeleteInvoiceProfile;  }> {
        const localVarPath = this.basePath + '/accounting/account/{accountId}/invoice_profiles/invoice_profiles/{invoiceProfileId}'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'invoiceProfileId' + '}', encodeURIComponent(String(invoiceProfileId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling accountingAccountInvoiceProfilesInvoiceProfilesByAccountIdAndInvoiceProfileIdPut.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling accountingAccountInvoiceProfilesInvoiceProfilesByAccountIdAndInvoiceProfileIdPut.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling accountingAccountInvoiceProfilesInvoiceProfilesByAccountIdAndInvoiceProfileIdPut.');
        }

        // verify required parameter 'invoiceProfileId' is not null or undefined
        if (invoiceProfileId === null || invoiceProfileId === undefined) {
            throw new Error('Required parameter invoiceProfileId was null or undefined when calling accountingAccountInvoiceProfilesInvoiceProfilesByAccountIdAndInvoiceProfileIdPut.');
        }

        localVarHeaderParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "DeleteInvoiceProfileRequest")
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DeleteInvoiceProfile;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DeleteInvoiceProfile");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * TODO: Add Description
     * @summary List Invoice Profiles
     * @param contentType 
     * @param accountId 
     * @param {*} [options] Override http request options.
     */
    public accountingAccountInvoiceProfilesInvoiceProfilesByAccountIdGet (contentType: string, accountId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: ListInvoiceProfiles;  }> {
        const localVarPath = this.basePath + '/accounting/account/{accountId}/invoice_profiles/invoice_profiles'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling accountingAccountInvoiceProfilesInvoiceProfilesByAccountIdGet.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling accountingAccountInvoiceProfilesInvoiceProfilesByAccountIdGet.');
        }

        localVarHeaderParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ListInvoiceProfiles;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ListInvoiceProfiles");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Creates a monthly recurring invoice that sends 3 invoices in total.
     * @summary Create Single Invoice Profile
     * @param contentType 
     * @param body 
     * @param accountId 
     * @param {*} [options] Override http request options.
     */
    public accountingAccountInvoiceProfilesInvoiceProfilesByAccountIdPost (contentType: string, body: string, accountId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: CreateSingleInvoiceProfile;  }> {
        const localVarPath = this.basePath + '/accounting/account/{accountId}/invoice_profiles/invoice_profiles'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling accountingAccountInvoiceProfilesInvoiceProfilesByAccountIdPost.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling accountingAccountInvoiceProfilesInvoiceProfilesByAccountIdPost.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling accountingAccountInvoiceProfilesInvoiceProfilesByAccountIdPost.');
        }

        localVarHeaderParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "string")
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CreateSingleInvoiceProfile;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CreateSingleInvoiceProfile");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * This will create an invoice profile that will pull unbilled time entries for your client on to the invoice that is generated
     * @summary Create Single Invoice Profile w/ Time Entry Holder
     * @param include 
     * @param include5B5D 
     * @param contentType 
     * @param body 
     * @param accountid 
     * @param {*} [options] Override http request options.
     */
    public accountingAccountInvoiceProfilesInvoiceProfilesByAccountidPost (include: string, include5B5D: string, contentType: string, body: string, accountid: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/accounting/account/{accountid}/invoice_profiles/invoice_profiles'
            .replace('{' + 'accountid' + '}', encodeURIComponent(String(accountid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'include' is not null or undefined
        if (include === null || include === undefined) {
            throw new Error('Required parameter include was null or undefined when calling accountingAccountInvoiceProfilesInvoiceProfilesByAccountidPost.');
        }

        // verify required parameter 'include5B5D' is not null or undefined
        if (include5B5D === null || include5B5D === undefined) {
            throw new Error('Required parameter include5B5D was null or undefined when calling accountingAccountInvoiceProfilesInvoiceProfilesByAccountidPost.');
        }

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling accountingAccountInvoiceProfilesInvoiceProfilesByAccountidPost.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling accountingAccountInvoiceProfilesInvoiceProfilesByAccountidPost.');
        }

        // verify required parameter 'accountid' is not null or undefined
        if (accountid === null || accountid === undefined) {
            throw new Error('Required parameter accountid was null or undefined when calling accountingAccountInvoiceProfilesInvoiceProfilesByAccountidPost.');
        }

        if (include !== undefined) {
            localVarQueryParameters['include[]'] = ObjectSerializer.serialize(include, "string");
        }

        if (include5B5D !== undefined) {
            localVarQueryParameters['include%5B%5D'] = ObjectSerializer.serialize(include5B5D, "string");
        }

        localVarHeaderParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "string")
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum InvoicesApiApiKeys {
}

export class InvoicesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'auth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: InvoicesApiApiKeys, value: string) {
        (this.authentications as any)[InvoicesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.auth.accessToken = token;
    }
    /**
     * TODO: Add Description
     * @summary Single Invoice
     * @param contentType 
     * @param accountId 
     * @param invoiceId 
     * @param {*} [options] Override http request options.
     */
    public accountingAccountInvoicesInvoicesByAccountIdAndInvoiceIdGet (contentType: string, accountId: string, invoiceId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: SingleInvoice;  }> {
        const localVarPath = this.basePath + '/accounting/account/{accountId}/invoices/invoices/{invoiceId}'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'invoiceId' + '}', encodeURIComponent(String(invoiceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling accountingAccountInvoicesInvoicesByAccountIdAndInvoiceIdGet.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling accountingAccountInvoicesInvoicesByAccountIdAndInvoiceIdGet.');
        }

        // verify required parameter 'invoiceId' is not null or undefined
        if (invoiceId === null || invoiceId === undefined) {
            throw new Error('Required parameter invoiceId was null or undefined when calling accountingAccountInvoicesInvoicesByAccountIdAndInvoiceIdGet.');
        }

        localVarHeaderParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SingleInvoice;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SingleInvoice");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Note:  - In order to delete an invoice, you will first need to delete all payments associated with that invoice or turn them to credits.  - If the invoice line items have inventory tracking enabled (See Items and Services > Create Item), the relevant inventory amount will be adjusted accordingly when the invoice is deleted:       item new inventory = item current inventory + item quantity from deleted invoice - Similarly, if the deleted invoice gets undeleted, the corresponding inventory wil be updated:   item new inventory = item current inventory - item quantity from undeleted invoice
     * @summary Delete  Invoice
     * @param contentType 
     * @param body 
     * @param accountId 
     * @param invoiceId 
     * @param {*} [options] Override http request options.
     */
    public accountingAccountInvoicesInvoicesByAccountIdAndInvoiceIdPut (contentType: string, body: DeleteInvoiceRequest, accountId: string, invoiceId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: DeleteInvoice;  }> {
        const localVarPath = this.basePath + '/accounting/account/{accountId}/invoices/invoices/{invoiceId}'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'invoiceId' + '}', encodeURIComponent(String(invoiceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling accountingAccountInvoicesInvoicesByAccountIdAndInvoiceIdPut.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling accountingAccountInvoicesInvoicesByAccountIdAndInvoiceIdPut.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling accountingAccountInvoicesInvoicesByAccountIdAndInvoiceIdPut.');
        }

        // verify required parameter 'invoiceId' is not null or undefined
        if (invoiceId === null || invoiceId === undefined) {
            throw new Error('Required parameter invoiceId was null or undefined when calling accountingAccountInvoicesInvoicesByAccountIdAndInvoiceIdPut.');
        }

        localVarHeaderParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "DeleteInvoiceRequest")
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DeleteInvoice;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DeleteInvoice");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * TODO: Add Description
     * @summary List Invoices
     * @param include show invoice view/send/payment history
     * @param contentType 
     * @param accountId 
     * @param {*} [options] Override http request options.
     */
    public accountingAccountInvoicesInvoicesByAccountIdGet (include: string, contentType: string, accountId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: ListInvoices;  }> {
        const localVarPath = this.basePath + '/accounting/account/{accountId}/invoices/invoices'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'include' is not null or undefined
        if (include === null || include === undefined) {
            throw new Error('Required parameter include was null or undefined when calling accountingAccountInvoicesInvoicesByAccountIdGet.');
        }

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling accountingAccountInvoicesInvoicesByAccountIdGet.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling accountingAccountInvoicesInvoicesByAccountIdGet.');
        }

        if (include !== undefined) {
            localVarQueryParameters['include[]'] = ObjectSerializer.serialize(include, "string");
        }

        localVarHeaderParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ListInvoices;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ListInvoices");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Define invoice logo and styles by passing in `presentation` object with the fields below:  | Field name | Acceptable values | |------------|-------------------| | `image_logo_src`| Relative URL of a logo uploaded to FreshBooks - See Upload Logo | | `theme_primary_color`| Valid color code | | `theme_layout` | \"simple\" or \"modern\" | | `theme_font_name` | \"modern\" or \"classic\" |  By default, if no `presentation` specified in new invoice request payload, it will be assigned a default presentation. To override this default behaviour, specify `\"use_default_presentation\": false`
     * @summary Single Invoice w/ Logo and styles
     * @param contentType 
     * @param body 
     * @param accountId 
     * @param {*} [options] Override http request options.
     */
    public accountingAccountInvoicesInvoicesByAccountIdPost (contentType: string, body: string, accountId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: SingleInvoicew1Logoandstyles;  }> {
        const localVarPath = this.basePath + '/accounting/account/{accountId}/invoices/invoices'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling accountingAccountInvoicesInvoicesByAccountIdPost.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling accountingAccountInvoicesInvoicesByAccountIdPost.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling accountingAccountInvoicesInvoicesByAccountIdPost.');
        }

        localVarHeaderParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "string")
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SingleInvoicew1Logoandstyles;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SingleInvoicew1Logoandstyles");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * TODO: Add Description
     * @summary Get default invoice presentation styles
     * @param accountId 
     * @param {*} [options] Override http request options.
     */
    public accountingAccountInvoicesPresentationsByAccountIdGet (accountId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Getdefaultinvoicepresentationstyles;  }> {
        const localVarPath = this.basePath + '/accounting/account/{accountId}/invoices/presentations'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling accountingAccountInvoicesPresentationsByAccountIdGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Getdefaultinvoicepresentationstyles;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Getdefaultinvoicepresentationstyles");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ItemsAndServicesApiApiKeys {
}

export class ItemsAndServicesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'auth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ItemsAndServicesApiApiKeys, value: string) {
        (this.authentications as any)[ItemsAndServicesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.auth.accessToken = token;
    }
    /**
     * TODO: Add Description
     * @summary Single Item
     * @param accountId 
     * @param itemId 
     * @param {*} [options] Override http request options.
     */
    public accountingAccountItemsItemsByAccountIdAndItemIdGet (accountId: string, itemId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: SingleItem;  }> {
        const localVarPath = this.basePath + '/accounting/account/{accountId}/items/items/{itemId}'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'itemId' + '}', encodeURIComponent(String(itemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling accountingAccountItemsItemsByAccountIdAndItemIdGet.');
        }

        // verify required parameter 'itemId' is not null or undefined
        if (itemId === null || itemId === undefined) {
            throw new Error('Required parameter itemId was null or undefined when calling accountingAccountItemsItemsByAccountIdAndItemIdGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SingleItem;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SingleItem");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Changing the name, description and the inventory level of the current item.
     * @summary Update Item
     * @param contentType 
     * @param body 
     * @param accountId 
     * @param itemId 
     * @param {*} [options] Override http request options.
     */
    public accountingAccountItemsItemsByAccountIdAndItemIdPut (contentType: string, body: UpdateItemRequest, accountId: string, itemId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: CreateItem;  }> {
        const localVarPath = this.basePath + '/accounting/account/{accountId}/items/items/{itemId}'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'itemId' + '}', encodeURIComponent(String(itemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling accountingAccountItemsItemsByAccountIdAndItemIdPut.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling accountingAccountItemsItemsByAccountIdAndItemIdPut.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling accountingAccountItemsItemsByAccountIdAndItemIdPut.');
        }

        // verify required parameter 'itemId' is not null or undefined
        if (itemId === null || itemId === undefined) {
            throw new Error('Required parameter itemId was null or undefined when calling accountingAccountItemsItemsByAccountIdAndItemIdPut.');
        }

        localVarHeaderParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "UpdateItemRequest")
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CreateItem;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CreateItem");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * TODO: Add Description
     * @summary List Items
     * @param contentType 
     * @param accountId 
     * @param {*} [options] Override http request options.
     */
    public accountingAccountItemsItemsByAccountIdGet (contentType: string, accountId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: CreateItem;  }> {
        const localVarPath = this.basePath + '/accounting/account/{accountId}/items/items'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling accountingAccountItemsItemsByAccountIdGet.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling accountingAccountItemsItemsByAccountIdGet.');
        }

        localVarHeaderParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CreateItem;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CreateItem");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * If you add an `inventory` to an item, FreshBooks will decrement that `inventory` value each time you add that item to an invoice and save (or send) it.   However, `qty` is seen as the amount of items associated with that sale. Therefore, it will remain unchanged with anytime it is added to an invoice.   For example: You may have 5 boxes of nails. Each box of nails will have 99 nails in it. Therefore, your `inventory` will equal `5` and your `qty` will equal `99`.  
     * @summary Create Item
     * @param contentType 
     * @param body 
     * @param accountId 
     * @param {*} [options] Override http request options.
     */
    public accountingAccountItemsItemsByAccountIdPost (contentType: string, body: CreateItemRequest, accountId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: CreateItem;  }> {
        const localVarPath = this.basePath + '/accounting/account/{accountId}/items/items'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling accountingAccountItemsItemsByAccountIdPost.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling accountingAccountItemsItemsByAccountIdPost.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling accountingAccountItemsItemsByAccountIdPost.');
        }

        localVarHeaderParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CreateItemRequest")
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CreateItem;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CreateItem");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves information for a single service ID
     * @summary Get a Single Service
     * @param businessid 
     * @param serviceid 
     * @param {*} [options] Override http request options.
     */
    public commentsBusinessServiceByBusinessidAndServiceidGet (businessid: string, serviceid: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/comments/business/{businessid}/service/{serviceid}'
            .replace('{' + 'businessid' + '}', encodeURIComponent(String(businessid)))
            .replace('{' + 'serviceid' + '}', encodeURIComponent(String(serviceid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'businessid' is not null or undefined
        if (businessid === null || businessid === undefined) {
            throw new Error('Required parameter businessid was null or undefined when calling commentsBusinessServiceByBusinessidAndServiceidGet.');
        }

        // verify required parameter 'serviceid' is not null or undefined
        if (serviceid === null || serviceid === undefined) {
            throw new Error('Required parameter serviceid was null or undefined when calling commentsBusinessServiceByBusinessidAndServiceidGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Lists all services in an account
     * @summary List Services
     * @param businessid 
     * @param {*} [options] Override http request options.
     */
    public commentsBusinessServicesByBusinessidGet (businessid: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/comments/business/{businessid}/services'
            .replace('{' + 'businessid' + '}', encodeURIComponent(String(businessid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'businessid' is not null or undefined
        if (businessid === null || businessid === undefined) {
            throw new Error('Required parameter businessid was null or undefined when calling commentsBusinessServicesByBusinessidGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum JournalEntriesApiApiKeys {
}

export class JournalEntriesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'auth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: JournalEntriesApiApiKeys, value: string) {
        (this.authentications as any)[JournalEntriesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.auth.accessToken = token;
    }
    /**
     * TODO: Add Description
     * @summary Add Journal Entry
     * @param contentType 
     * @param body 
     * @param accountId 
     * @param {*} [options] Override http request options.
     */
    public accountingAccountJournalEntriesJournalEntriesByAccountIdPost (contentType: string, body: AddJournalEntryRequest, accountId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: AddJournalEntry;  }> {
        const localVarPath = this.basePath + '/accounting/account/{accountId}/journal_entries/journal_entries'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling accountingAccountJournalEntriesJournalEntriesByAccountIdPost.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling accountingAccountJournalEntriesJournalEntriesByAccountIdPost.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling accountingAccountJournalEntriesJournalEntriesByAccountIdPost.');
        }

        localVarHeaderParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "AddJournalEntryRequest")
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AddJournalEntry;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AddJournalEntry");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * TODO: Add Description
     * @summary Journal Entry Details
     * @param accountId 
     * @param {*} [options] Override http request options.
     */
    public accountingAccountJournalEntriesJournalEntryDetailsByAccountIdGet (accountId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: JournalEntryDetails;  }> {
        const localVarPath = this.basePath + '/accounting/account/{accountId}/journal_entries/journal_entry_details'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling accountingAccountJournalEntriesJournalEntryDetailsByAccountIdGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: JournalEntryDetails;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "JournalEntryDetails");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MyTeam_ApiApiKeys {
}

export class MyTeam_Api {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'auth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MyTeam_ApiApiKeys, value: string) {
        (this.authentications as any)[MyTeam_ApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.auth.accessToken = token;
    }
    /**
     * TODO: Add Description
     * @summary Single Staff
     * @param contentType 
     * @param accountId 
     * @param staffId 
     * @param {*} [options] Override http request options.
     */
    public accountingAccountUsersStaffsByAccountIdAndStaffIdGet (contentType: string, accountId: string, staffId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: SingleStaff;  }> {
        const localVarPath = this.basePath + '/accounting/account/{accountId}/users/staffs/{staffId}'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'staffId' + '}', encodeURIComponent(String(staffId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling accountingAccountUsersStaffsByAccountIdAndStaffIdGet.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling accountingAccountUsersStaffsByAccountIdAndStaffIdGet.');
        }

        // verify required parameter 'staffId' is not null or undefined
        if (staffId === null || staffId === undefined) {
            throw new Error('Required parameter staffId was null or undefined when calling accountingAccountUsersStaffsByAccountIdAndStaffIdGet.');
        }

        localVarHeaderParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SingleStaff;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SingleStaff");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * TODO: Add Description
     * @summary Update Staff
     * @param contentType 
     * @param body 
     * @param accountId 
     * @param staffId 
     * @param {*} [options] Override http request options.
     */
    public accountingAccountUsersStaffsByAccountIdAndStaffIdPut (contentType: string, body: UpdateStaffRequest, accountId: string, staffId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: UpdateStaff;  }> {
        const localVarPath = this.basePath + '/accounting/account/{accountId}/users/staffs/{staffId}'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'staffId' + '}', encodeURIComponent(String(staffId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling accountingAccountUsersStaffsByAccountIdAndStaffIdPut.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling accountingAccountUsersStaffsByAccountIdAndStaffIdPut.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling accountingAccountUsersStaffsByAccountIdAndStaffIdPut.');
        }

        // verify required parameter 'staffId' is not null or undefined
        if (staffId === null || staffId === undefined) {
            throw new Error('Required parameter staffId was null or undefined when calling accountingAccountUsersStaffsByAccountIdAndStaffIdPut.');
        }

        localVarHeaderParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "UpdateStaffRequest")
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UpdateStaff;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UpdateStaff");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * TODO: Add Description
     * @summary List Staff
     * @param contentType 
     * @param businessId 
     * @param {*} [options] Override http request options.
     */
    public authApiV1UsersBusinessByBusinessIdGet (contentType: string, businessId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: ListStaff;  }> {
        const localVarPath = this.basePath + '/auth/api/v1/users/business/{businessId}'
            .replace('{' + 'businessId' + '}', encodeURIComponent(String(businessId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling authApiV1UsersBusinessByBusinessIdGet.');
        }

        // verify required parameter 'businessId' is not null or undefined
        if (businessId === null || businessId === undefined) {
            throw new Error('Required parameter businessId was null or undefined when calling authApiV1UsersBusinessByBusinessIdGet.');
        }

        localVarHeaderParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ListStaff;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ListStaff");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum OtherIncomeApiApiKeys {
}

export class OtherIncomeApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'auth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: OtherIncomeApiApiKeys, value: string) {
        (this.authentications as any)[OtherIncomeApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.auth.accessToken = token;
    }
    /**
     * Edit the source of this other income, the amount and the date.  
     * @summary Update Single Other Income
     * @param contentType 
     * @param body 
     * @param accountId 
     * @param incomeId 
     * @param {*} [options] Override http request options.
     */
    public accountingAccountOtherIncomesOtherIncomesByAccountIdAndIncomeIdPut (contentType: string, body: UpdateSingleOtherIncomeRequest, accountId: string, incomeId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: UpdateSingleOtherIncome;  }> {
        const localVarPath = this.basePath + '/accounting/account/{accountId}/other_incomes/other_incomes/{incomeId}'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'incomeId' + '}', encodeURIComponent(String(incomeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling accountingAccountOtherIncomesOtherIncomesByAccountIdAndIncomeIdPut.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling accountingAccountOtherIncomesOtherIncomesByAccountIdAndIncomeIdPut.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling accountingAccountOtherIncomesOtherIncomesByAccountIdAndIncomeIdPut.');
        }

        // verify required parameter 'incomeId' is not null or undefined
        if (incomeId === null || incomeId === undefined) {
            throw new Error('Required parameter incomeId was null or undefined when calling accountingAccountOtherIncomesOtherIncomesByAccountIdAndIncomeIdPut.');
        }

        localVarHeaderParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "UpdateSingleOtherIncomeRequest")
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UpdateSingleOtherIncome;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UpdateSingleOtherIncome");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List all available other income instances.
     * @summary List Other Income
     * @param contentType 
     * @param accountId 
     * @param {*} [options] Override http request options.
     */
    public accountingAccountOtherIncomesOtherIncomesByAccountIdGet (contentType: string, accountId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: ListOtherIncome;  }> {
        const localVarPath = this.basePath + '/accounting/account/{accountId}/other_incomes/other_incomes'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling accountingAccountOtherIncomesOtherIncomesByAccountIdGet.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling accountingAccountOtherIncomesOtherIncomesByAccountIdGet.');
        }

        localVarHeaderParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ListOtherIncome;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ListOtherIncome");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * This allows you to create a single entry for other income you collected (or will collect) through other means outside of FreshBooks.
     * @summary Create Single Other Income
     * @param contentType 
     * @param body 
     * @param accountId 
     * @param {*} [options] Override http request options.
     */
    public accountingAccountOtherIncomesOtherIncomesByAccountIdPost (contentType: string, body: CreateSingleOtherIncomeRequest, accountId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: CreateSingleOtherIncome;  }> {
        const localVarPath = this.basePath + '/accounting/account/{accountId}/other_incomes/other_incomes'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling accountingAccountOtherIncomesOtherIncomesByAccountIdPost.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling accountingAccountOtherIncomesOtherIncomesByAccountIdPost.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling accountingAccountOtherIncomesOtherIncomesByAccountIdPost.');
        }

        localVarHeaderParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CreateSingleOtherIncomeRequest")
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CreateSingleOtherIncome;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CreateSingleOtherIncome");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PaymentsApiApiKeys {
}

export class PaymentsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'auth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PaymentsApiApiKeys, value: string) {
        (this.authentications as any)[PaymentsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.auth.accessToken = token;
    }
    /**
     * TODO: Add Description
     * @summary Single Payment
     * @param contentType 
     * @param accountId 
     * @param paymentId 
     * @param {*} [options] Override http request options.
     */
    public accountingAccountPaymentsPaymentsByAccountIdAndPaymentIdGet (contentType: string, accountId: string, paymentId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: SinglePayment;  }> {
        const localVarPath = this.basePath + '/accounting/account/{accountId}/payments/payments/{paymentId}'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'paymentId' + '}', encodeURIComponent(String(paymentId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling accountingAccountPaymentsPaymentsByAccountIdAndPaymentIdGet.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling accountingAccountPaymentsPaymentsByAccountIdAndPaymentIdGet.');
        }

        // verify required parameter 'paymentId' is not null or undefined
        if (paymentId === null || paymentId === undefined) {
            throw new Error('Required parameter paymentId was null or undefined when calling accountingAccountPaymentsPaymentsByAccountIdAndPaymentIdGet.');
        }

        localVarHeaderParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SinglePayment;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SinglePayment");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * TODO: Add Description
     * @summary Delete Payment
     * @param contentType 
     * @param body 
     * @param accountId 
     * @param paymentId 
     * @param {*} [options] Override http request options.
     */
    public accountingAccountPaymentsPaymentsByAccountIdAndPaymentIdPut (contentType: string, body: DeletePaymentRequest, accountId: string, paymentId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: DeletePayment;  }> {
        const localVarPath = this.basePath + '/accounting/account/{accountId}/payments/payments/{paymentId}'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'paymentId' + '}', encodeURIComponent(String(paymentId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling accountingAccountPaymentsPaymentsByAccountIdAndPaymentIdPut.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling accountingAccountPaymentsPaymentsByAccountIdAndPaymentIdPut.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling accountingAccountPaymentsPaymentsByAccountIdAndPaymentIdPut.');
        }

        // verify required parameter 'paymentId' is not null or undefined
        if (paymentId === null || paymentId === undefined) {
            throw new Error('Required parameter paymentId was null or undefined when calling accountingAccountPaymentsPaymentsByAccountIdAndPaymentIdPut.');
        }

        localVarHeaderParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "DeletePaymentRequest")
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DeletePayment;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DeletePayment");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * TODO: Add Description
     * @summary List Payments
     * @param contentType 
     * @param accountId 
     * @param {*} [options] Override http request options.
     */
    public accountingAccountPaymentsPaymentsByAccountIdGet (contentType: string, accountId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: ListPayments;  }> {
        const localVarPath = this.basePath + '/accounting/account/{accountId}/payments/payments'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling accountingAccountPaymentsPaymentsByAccountIdGet.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling accountingAccountPaymentsPaymentsByAccountIdGet.');
        }

        localVarHeaderParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ListPayments;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ListPayments");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Add a payment to a specific invoice
     * @summary Make Payment
     * @param contentType 
     * @param body 
     * @param accountId 
     * @param {*} [options] Override http request options.
     */
    public accountingAccountPaymentsPaymentsByAccountIdPost (contentType: string, body: string, accountId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: MakePayment;  }> {
        const localVarPath = this.basePath + '/accounting/account/{accountId}/payments/payments'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling accountingAccountPaymentsPaymentsByAccountIdPost.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling accountingAccountPaymentsPaymentsByAccountIdPost.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling accountingAccountPaymentsPaymentsByAccountIdPost.');
        }

        localVarHeaderParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "string")
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: MakePayment;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "MakePayment");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ProjectsApiApiKeys {
}

export class ProjectsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'auth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ProjectsApiApiKeys, value: string) {
        (this.authentications as any)[ProjectsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.auth.accessToken = token;
    }
    /**
     * TODO: Add Description
     * @summary Invitation Rates
     * @param businessId 
     * @param {*} [options] Override http request options.
     */
    public commentsBusinessInvitationRatesByBusinessIdGet (businessId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: InvitationRates;  }> {
        const localVarPath = this.basePath + '/comments/business/{businessId}/invitation_rates'
            .replace('{' + 'businessId' + '}', encodeURIComponent(String(businessId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'businessId' is not null or undefined
        if (businessId === null || businessId === undefined) {
            throw new Error('Required parameter businessId was null or undefined when calling commentsBusinessInvitationRatesByBusinessIdGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InvitationRates;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InvitationRates");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * TODO: Add Description
     * @summary Delete Project
     * @param contentType 
     * @param body 
     * @param businessId 
     * @param projectId 
     * @param {*} [options] Override http request options.
     */
    public commentsBusinessProjectByBusinessIdAndProjectIdDelete (contentType: string, body: DeleteProjectRequest, businessId: string, projectId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/comments/business/{businessId}/project/{projectId}'
            .replace('{' + 'businessId' + '}', encodeURIComponent(String(businessId)))
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling commentsBusinessProjectByBusinessIdAndProjectIdDelete.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling commentsBusinessProjectByBusinessIdAndProjectIdDelete.');
        }

        // verify required parameter 'businessId' is not null or undefined
        if (businessId === null || businessId === undefined) {
            throw new Error('Required parameter businessId was null or undefined when calling commentsBusinessProjectByBusinessIdAndProjectIdDelete.');
        }

        // verify required parameter 'projectId' is not null or undefined
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling commentsBusinessProjectByBusinessIdAndProjectIdDelete.');
        }

        localVarHeaderParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "DeleteProjectRequest")
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * You will need to update each project service independently with this endpoint
     * @summary Update Service Rates
     * @param contentType 
     * @param body 
     * @param businessId 
     * @param projectId 
     * @param serviceId 
     * @param {*} [options] Override http request options.
     */
    public commentsBusinessProjectServiceServiceIdRateByBusinessIdAndProjectIdPut (contentType: string, body: UpdateServiceRatesRequest, businessId: string, projectId: string, serviceId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: UpdateProjectServiceRates;  }> {
        const localVarPath = this.basePath + '/comments/business/{businessId}/project/{projectId}/service/{serviceId}/rate'
            .replace('{' + 'businessId' + '}', encodeURIComponent(String(businessId)))
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)))
            .replace('{' + 'serviceId' + '}', encodeURIComponent(String(serviceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling commentsBusinessProjectServiceServiceIdRateByBusinessIdAndProjectIdPut.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling commentsBusinessProjectServiceServiceIdRateByBusinessIdAndProjectIdPut.');
        }

        // verify required parameter 'businessId' is not null or undefined
        if (businessId === null || businessId === undefined) {
            throw new Error('Required parameter businessId was null or undefined when calling commentsBusinessProjectServiceServiceIdRateByBusinessIdAndProjectIdPut.');
        }

        // verify required parameter 'projectId' is not null or undefined
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling commentsBusinessProjectServiceServiceIdRateByBusinessIdAndProjectIdPut.');
        }

        // verify required parameter 'serviceId' is not null or undefined
        if (serviceId === null || serviceId === undefined) {
            throw new Error('Required parameter serviceId was null or undefined when calling commentsBusinessProjectServiceServiceIdRateByBusinessIdAndProjectIdPut.');
        }

        localVarHeaderParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "UpdateServiceRatesRequest")
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UpdateProjectServiceRates;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UpdateProjectServiceRates");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Lists all messages in a specific Project's discussion page
     * @summary List All Messages in Project Discussion
     * @param businessid 
     * @param projectid 
     * @param {*} [options] Override http request options.
     */
    public commentsBusinessProjectThreadsByBusinessidAndProjectidGet (businessid: string, projectid: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/comments/business/{businessid}/project/{projectid}/threads'
            .replace('{' + 'businessid' + '}', encodeURIComponent(String(businessid)))
            .replace('{' + 'projectid' + '}', encodeURIComponent(String(projectid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'businessid' is not null or undefined
        if (businessid === null || businessid === undefined) {
            throw new Error('Required parameter businessid was null or undefined when calling commentsBusinessProjectThreadsByBusinessidAndProjectidGet.');
        }

        // verify required parameter 'projectid' is not null or undefined
        if (projectid === null || projectid === undefined) {
            throw new Error('Required parameter projectid was null or undefined when calling commentsBusinessProjectThreadsByBusinessidAndProjectidGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * TODO: Add Description
     * @summary Create New Message in Project Discussion
     * @param contentType 
     * @param body 
     * @param businessid 
     * @param projectid 
     * @param {*} [options] Override http request options.
     */
    public commentsBusinessProjectThreadsByBusinessidAndProjectidPost (contentType: string, body: CreateNewMessageinProjectDiscussionRequest, businessid: string, projectid: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/comments/business/{businessid}/project/{projectid}/threads'
            .replace('{' + 'businessid' + '}', encodeURIComponent(String(businessid)))
            .replace('{' + 'projectid' + '}', encodeURIComponent(String(projectid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling commentsBusinessProjectThreadsByBusinessidAndProjectidPost.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling commentsBusinessProjectThreadsByBusinessidAndProjectidPost.');
        }

        // verify required parameter 'businessid' is not null or undefined
        if (businessid === null || businessid === undefined) {
            throw new Error('Required parameter businessid was null or undefined when calling commentsBusinessProjectThreadsByBusinessidAndProjectidPost.');
        }

        // verify required parameter 'projectid' is not null or undefined
        if (projectid === null || projectid === undefined) {
            throw new Error('Required parameter projectid was null or undefined when calling commentsBusinessProjectThreadsByBusinessidAndProjectidPost.');
        }

        localVarHeaderParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CreateNewMessageinProjectDiscussionRequest")
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get all service rates associated with this project 
     * @summary Service Rates
     * @param businessId 
     * @param {*} [options] Override http request options.
     */
    public commentsBusinessServiceRatesByBusinessIdGet (businessId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: ServiceRates;  }> {
        const localVarPath = this.basePath + '/comments/business/{businessId}/service_rates'
            .replace('{' + 'businessId' + '}', encodeURIComponent(String(businessId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'businessId' is not null or undefined
        if (businessId === null || businessId === undefined) {
            throw new Error('Required parameter businessId was null or undefined when calling commentsBusinessServiceRatesByBusinessIdGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ServiceRates;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ServiceRates");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * You will need to update each project service independently with this endpoint
     * @summary Update Team Member Rate
     * @param contentType 
     * @param body 
     * @param businessId 
     * @param identityId 
     * @param {*} [options] Override http request options.
     */
    public commentsBusinessTeamMemberRateByBusinessIdAndIdentityIdPut (contentType: string, body: string, businessId: string, identityId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: UpdateTeamMemberRate;  }> {
        const localVarPath = this.basePath + '/comments/business/{businessId}/team_member_rate/{identityId}'
            .replace('{' + 'businessId' + '}', encodeURIComponent(String(businessId)))
            .replace('{' + 'identityId' + '}', encodeURIComponent(String(identityId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling commentsBusinessTeamMemberRateByBusinessIdAndIdentityIdPut.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling commentsBusinessTeamMemberRateByBusinessIdAndIdentityIdPut.');
        }

        // verify required parameter 'businessId' is not null or undefined
        if (businessId === null || businessId === undefined) {
            throw new Error('Required parameter businessId was null or undefined when calling commentsBusinessTeamMemberRateByBusinessIdAndIdentityIdPut.');
        }

        // verify required parameter 'identityId' is not null or undefined
        if (identityId === null || identityId === undefined) {
            throw new Error('Required parameter identityId was null or undefined when calling commentsBusinessTeamMemberRateByBusinessIdAndIdentityIdPut.');
        }

        localVarHeaderParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "string")
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UpdateTeamMemberRate;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UpdateTeamMemberRate");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * TODO: Add Description
     * @summary Team Member Rates
     * @param businessId 
     * @param {*} [options] Override http request options.
     */
    public commentsBusinessTeamMemberRatesByBusinessIdGet (businessId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: TeamMemberRates;  }> {
        const localVarPath = this.basePath + '/comments/business/{businessId}/team_member_rates'
            .replace('{' + 'businessId' + '}', encodeURIComponent(String(businessId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'businessId' is not null or undefined
        if (businessId === null || businessId === undefined) {
            throw new Error('Required parameter businessId was null or undefined when calling commentsBusinessTeamMemberRatesByBusinessIdGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TeamMemberRates;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TeamMemberRates");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Adds a comment to a project discussion message
     * @summary Add Comment to Project Discussion Message
     * @param contentType 
     * @param body 
     * @param businessid 
     * @param threadid 
     * @param {*} [options] Override http request options.
     */
    public commentsBusinessThreadsCommentsByBusinessidAndThreadidPost (contentType: string, body: AddCommenttoProjectDiscussionMessageRequest, businessid: string, threadid: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/comments/business/{businessid}/threads/{threadid}/comments'
            .replace('{' + 'businessid' + '}', encodeURIComponent(String(businessid)))
            .replace('{' + 'threadid' + '}', encodeURIComponent(String(threadid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling commentsBusinessThreadsCommentsByBusinessidAndThreadidPost.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling commentsBusinessThreadsCommentsByBusinessidAndThreadidPost.');
        }

        // verify required parameter 'businessid' is not null or undefined
        if (businessid === null || businessid === undefined) {
            throw new Error('Required parameter businessid was null or undefined when calling commentsBusinessThreadsCommentsByBusinessidAndThreadidPost.');
        }

        // verify required parameter 'threadid' is not null or undefined
        if (threadid === null || threadid === undefined) {
            throw new Error('Required parameter threadid was null or undefined when calling commentsBusinessThreadsCommentsByBusinessidAndThreadidPost.');
        }

        localVarHeaderParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "AddCommenttoProjectDiscussionMessageRequest")
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * TODO: Add Description
     * @summary Single Project
     * @param businessId 
     * @param projectId 
     * @param {*} [options] Override http request options.
     */
    public projectsBusinessProjectsByBusinessIdAndProjectIdGet (businessId: string, projectId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: SingleProject;  }> {
        const localVarPath = this.basePath + '/projects/business/{businessId}/projects/{projectId}'
            .replace('{' + 'businessId' + '}', encodeURIComponent(String(businessId)))
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'businessId' is not null or undefined
        if (businessId === null || businessId === undefined) {
            throw new Error('Required parameter businessId was null or undefined when calling projectsBusinessProjectsByBusinessIdAndProjectIdGet.');
        }

        // verify required parameter 'projectId' is not null or undefined
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling projectsBusinessProjectsByBusinessIdAndProjectIdGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SingleProject;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SingleProject");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update project with project title.   *`client_id` in this case is `customerId`*
     * @summary Update Project
     * @param contentType 
     * @param body 
     * @param businessId 
     * @param projectId 
     * @param {*} [options] Override http request options.
     */
    public projectsBusinessProjectsByBusinessIdAndProjectIdPut (contentType: string, body: string, businessId: string, projectId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: UpdateProject;  }> {
        const localVarPath = this.basePath + '/projects/business/{businessId}/projects/{projectId}'
            .replace('{' + 'businessId' + '}', encodeURIComponent(String(businessId)))
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling projectsBusinessProjectsByBusinessIdAndProjectIdPut.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling projectsBusinessProjectsByBusinessIdAndProjectIdPut.');
        }

        // verify required parameter 'businessId' is not null or undefined
        if (businessId === null || businessId === undefined) {
            throw new Error('Required parameter businessId was null or undefined when calling projectsBusinessProjectsByBusinessIdAndProjectIdPut.');
        }

        // verify required parameter 'projectId' is not null or undefined
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling projectsBusinessProjectsByBusinessIdAndProjectIdPut.');
        }

        localVarHeaderParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "string")
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UpdateProject;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UpdateProject");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Remember to remove `Content-Type` headers when making a GET call on projects and time-tracking.
     * @summary List Projects
     * @param businessId 
     * @param {*} [options] Override http request options.
     */
    public projectsBusinessProjectsByBusinessIdGet (businessId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: ListProjects;  }> {
        const localVarPath = this.basePath + '/projects/business/{businessId}/projects'
            .replace('{' + 'businessId' + '}', encodeURIComponent(String(businessId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'businessId' is not null or undefined
        if (businessId === null || businessId === undefined) {
            throw new Error('Required parameter businessId was null or undefined when calling projectsBusinessProjectsByBusinessIdGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ListProjects;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ListProjects");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * TODO: Add Description
     * @summary Create Single Project
     * @param contentType 
     * @param body 
     * @param businessId 
     * @param {*} [options] Override http request options.
     */
    public projectsBusinessProjectsByBusinessIdPost (contentType: string, body: string, businessId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: CreateSingleProject;  }> {
        const localVarPath = this.basePath + '/projects/business/{businessId}/projects'
            .replace('{' + 'businessId' + '}', encodeURIComponent(String(businessId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling projectsBusinessProjectsByBusinessIdPost.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling projectsBusinessProjectsByBusinessIdPost.');
        }

        // verify required parameter 'businessId' is not null or undefined
        if (businessId === null || businessId === undefined) {
            throw new Error('Required parameter businessId was null or undefined when calling projectsBusinessProjectsByBusinessIdPost.');
        }

        localVarHeaderParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "string")
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CreateSingleProject;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CreateSingleProject");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ReportsApiApiKeys {
}

export class ReportsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'auth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ReportsApiApiKeys, value: string) {
        (this.authentications as any)[ReportsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.auth.accessToken = token;
    }
    /**
     * A complete record of your transactions to help you prepare financial statements.
     * @summary General Ledger
     * @param contentType 
     * @param accountId 
     * @param {*} [options] Override http request options.
     */
    public accountingAccountJournalEntryAccountsJournalEntryAccountsByAccountIdGet (contentType: string, accountId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: GeneralLedger;  }> {
        const localVarPath = this.basePath + '/accounting/account/{accountId}/journal_entry_accounts/journal_entry_accounts'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling accountingAccountJournalEntryAccountsJournalEntryAccountsByAccountIdGet.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling accountingAccountJournalEntryAccountsJournalEntryAccountsByAccountIdGet.');
        }

        localVarHeaderParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GeneralLedger;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GeneralLedger");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * TODO: Add Description
     * @summary Download CSV Report
     * @param accountId 
     * @param downloadToken 
     * @param {*} [options] Override http request options.
     */
    public accountingAccountLinksReportsInvoiceDetailsCsvByAccountIdAndDownloadTokenGet (accountId: string, downloadToken: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/accounting/account/{accountId}/links/reports/{downloadToken}/invoice_details.csv'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'downloadToken' + '}', encodeURIComponent(String(downloadToken)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling accountingAccountLinksReportsInvoiceDetailsCsvByAccountIdAndDownloadTokenGet.');
        }

        // verify required parameter 'downloadToken' is not null or undefined
        if (downloadToken === null || downloadToken === undefined) {
            throw new Error('Required parameter downloadToken was null or undefined when calling accountingAccountLinksReportsInvoiceDetailsCsvByAccountIdAndDownloadTokenGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * TODO: Add Description
     * @summary Accounts Aging
     * @param accountId 
     * @param {*} [options] Override http request options.
     */
    public accountingAccountReportsAccountingAccountsAgingByAccountIdGet (accountId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: AccountsAging;  }> {
        const localVarPath = this.basePath + '/accounting/account/{accountId}/reports/accounting/accounts_aging'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling accountingAccountReportsAccountingAccountsAgingByAccountIdGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AccountsAging;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AccountsAging");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * A snapshot of your company's assets, liabilities and equity at any given point in time.
     * @summary Balance Sheet
     * @param dates will need to explain [] as anything before this date
     * @param currencyCode 
     * @param accountId 
     * @param {*} [options] Override http request options.
     */
    public accountingAccountReportsAccountingBalanceSheetByAccountIdGet (dates: string, currencyCode: string, accountId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: BalanceSheet;  }> {
        const localVarPath = this.basePath + '/accounting/account/{accountId}/reports/accounting/balance_sheet'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'dates' is not null or undefined
        if (dates === null || dates === undefined) {
            throw new Error('Required parameter dates was null or undefined when calling accountingAccountReportsAccountingBalanceSheetByAccountIdGet.');
        }

        // verify required parameter 'currencyCode' is not null or undefined
        if (currencyCode === null || currencyCode === undefined) {
            throw new Error('Required parameter currencyCode was null or undefined when calling accountingAccountReportsAccountingBalanceSheetByAccountIdGet.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling accountingAccountReportsAccountingBalanceSheetByAccountIdGet.');
        }

        if (dates !== undefined) {
            localVarQueryParameters['dates[]'] = ObjectSerializer.serialize(dates, "string");
        }

        if (currencyCode !== undefined) {
            localVarQueryParameters['currency_code'] = ObjectSerializer.serialize(currencyCode, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: BalanceSheet;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BalanceSheet");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * TODO: Add Description
     * @summary Expense Details
     * @param contentType 
     * @param accountId 
     * @param {*} [options] Override http request options.
     */
    public accountingAccountReportsAccountingExpenseDetailsByAccountIdGet (contentType: string, accountId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/accounting/account/{accountId}/reports/accounting/expense_details'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling accountingAccountReportsAccountingExpenseDetailsByAccountIdGet.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling accountingAccountReportsAccountingExpenseDetailsByAccountIdGet.');
        }

        localVarHeaderParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * ## Invoice Details  The Invoice Details Report shows all the information involving your invoices
     * @summary Invoice Details
     * @param contentType 
     * @param accountId 
     * @param {*} [options] Override http request options.
     */
    public accountingAccountReportsAccountingInvoiceDetailsByAccountIdGet (contentType: string, accountId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: InvoiceDetails;  }> {
        const localVarPath = this.basePath + '/accounting/account/{accountId}/reports/accounting/invoice_details'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling accountingAccountReportsAccountingInvoiceDetailsByAccountIdGet.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling accountingAccountReportsAccountingInvoiceDetailsByAccountIdGet.');
        }

        localVarHeaderParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InvoiceDetails;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InvoiceDetails");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * TODO: Add Description
     * @summary Payments Collected
     * @param accountId 
     * @param {*} [options] Override http request options.
     */
    public accountingAccountReportsAccountingPaymentsCollectedByAccountIdGet (accountId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: PaymentsCollected;  }> {
        const localVarPath = this.basePath + '/accounting/account/{accountId}/reports/accounting/payments_collected'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling accountingAccountReportsAccountingPaymentsCollectedByAccountIdGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PaymentsCollected;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PaymentsCollected");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * The Profit/Loss Report shows all the information involving both your profits and losses
     * @summary Profit/Loss Report
     * @param contentType 
     * @param accountId 
     * @param {*} [options] Override http request options.
     */
    public accountingAccountReportsAccountingProfitlossEntityByAccountIdGet (contentType: string, accountId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Profit1LossReport;  }> {
        const localVarPath = this.basePath + '/accounting/account/{accountId}/reports/accounting/profitloss_entity'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling accountingAccountReportsAccountingProfitlossEntityByAccountIdGet.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling accountingAccountReportsAccountingProfitlossEntityByAccountIdGet.');
        }

        localVarHeaderParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Profit1LossReport;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Profit1LossReport");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * A breakdown of how much each of your clients is bringing in.
     * @summary Revenue By Client
     * @param salesType 
     * @param contentType 
     * @param accountId 
     * @param {*} [options] Override http request options.
     */
    public accountingAccountReportsAccountingRevenueByClientByAccountIdGet (salesType: string, contentType: string, accountId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: RevenueByClient;  }> {
        const localVarPath = this.basePath + '/accounting/account/{accountId}/reports/accounting/revenue_by_client'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'salesType' is not null or undefined
        if (salesType === null || salesType === undefined) {
            throw new Error('Required parameter salesType was null or undefined when calling accountingAccountReportsAccountingRevenueByClientByAccountIdGet.');
        }

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling accountingAccountReportsAccountingRevenueByClientByAccountIdGet.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling accountingAccountReportsAccountingRevenueByClientByAccountIdGet.');
        }

        if (salesType !== undefined) {
            localVarQueryParameters['sales_type'] = ObjectSerializer.serialize(salesType, "string");
        }

        localVarHeaderParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RevenueByClient;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RevenueByClient");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * TODO: Add Description
     * @summary Sales Tax Summary
     * @param startDate created during or after the given date i.e. &#x60;2019-01-01&#x60;
     * @param endDate created during or before the given date i.e. &#x60;2019-05-01&#x60;
     * @param currencyCode reports using the given currency as primary currency i.e. &#x60;\&quot;USD\&quot;&#x60;
     * @param cashBased True ignores billed payments and uses just collected payments i.e. &#x60;true&#x60;, &#x60;false&#x60;
     * @param accountId 
     * @param {*} [options] Override http request options.
     */
    public accountingAccountReportsAccountingTaxsummaryByAccountIdGet (startDate: string, endDate: string, currencyCode: string, cashBased: boolean, accountId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: SalesTaxSummary;  }> {
        const localVarPath = this.basePath + '/accounting/account/{accountId}/reports/accounting/taxsummary'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'startDate' is not null or undefined
        if (startDate === null || startDate === undefined) {
            throw new Error('Required parameter startDate was null or undefined when calling accountingAccountReportsAccountingTaxsummaryByAccountIdGet.');
        }

        // verify required parameter 'endDate' is not null or undefined
        if (endDate === null || endDate === undefined) {
            throw new Error('Required parameter endDate was null or undefined when calling accountingAccountReportsAccountingTaxsummaryByAccountIdGet.');
        }

        // verify required parameter 'currencyCode' is not null or undefined
        if (currencyCode === null || currencyCode === undefined) {
            throw new Error('Required parameter currencyCode was null or undefined when calling accountingAccountReportsAccountingTaxsummaryByAccountIdGet.');
        }

        // verify required parameter 'cashBased' is not null or undefined
        if (cashBased === null || cashBased === undefined) {
            throw new Error('Required parameter cashBased was null or undefined when calling accountingAccountReportsAccountingTaxsummaryByAccountIdGet.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling accountingAccountReportsAccountingTaxsummaryByAccountIdGet.');
        }

        if (startDate !== undefined) {
            localVarQueryParameters['start_date'] = ObjectSerializer.serialize(startDate, "string");
        }

        if (endDate !== undefined) {
            localVarQueryParameters['end_date'] = ObjectSerializer.serialize(endDate, "string");
        }

        if (currencyCode !== undefined) {
            localVarQueryParameters['currency_code'] = ObjectSerializer.serialize(currencyCode, "string");
        }

        if (cashBased !== undefined) {
            localVarQueryParameters['cash_based'] = ObjectSerializer.serialize(cashBased, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SalesTaxSummary;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SalesTaxSummary");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * A quick gut check to make sure your books are balanced.
     * @summary Trial Balance
     * @param startDate 
     * @param endDate 
     * @param currencyCode 
     * @param accountId 
     * @param {*} [options] Override http request options.
     */
    public accountingAccountReportsAccountingTrialBalanceByAccountIdGet (startDate: string, endDate: string, currencyCode: string, accountId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: TrialBalance;  }> {
        const localVarPath = this.basePath + '/accounting/account/{accountId}/reports/accounting/trial_balance'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'startDate' is not null or undefined
        if (startDate === null || startDate === undefined) {
            throw new Error('Required parameter startDate was null or undefined when calling accountingAccountReportsAccountingTrialBalanceByAccountIdGet.');
        }

        // verify required parameter 'endDate' is not null or undefined
        if (endDate === null || endDate === undefined) {
            throw new Error('Required parameter endDate was null or undefined when calling accountingAccountReportsAccountingTrialBalanceByAccountIdGet.');
        }

        // verify required parameter 'currencyCode' is not null or undefined
        if (currencyCode === null || currencyCode === undefined) {
            throw new Error('Required parameter currencyCode was null or undefined when calling accountingAccountReportsAccountingTrialBalanceByAccountIdGet.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling accountingAccountReportsAccountingTrialBalanceByAccountIdGet.');
        }

        if (startDate !== undefined) {
            localVarQueryParameters['start_date'] = ObjectSerializer.serialize(startDate, "string");
        }

        if (endDate !== undefined) {
            localVarQueryParameters['end_date'] = ObjectSerializer.serialize(endDate, "string");
        }

        if (currencyCode !== undefined) {
            localVarQueryParameters['currency_code'] = ObjectSerializer.serialize(currencyCode, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TrialBalance;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TrialBalance");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * See how much money you're making from each item to sell.
     * @summary Item Sales
     * @param startDate created during or after the given date i.e. &#x60;2019-01-01&#x60;
     * @param endDate created during or before the given date i.e. &#x60;2019-12-31&#x60;
     * @param currencyCode 
     * @param clientids 
     * @param itemNames 
     * @param statusids 
     * @param {*} [options] Override http request options.
     */
    public accountingAccountWkMd2gReportsAccountingItemSalesGet (startDate: string, endDate: string, currencyCode: string, clientids: number, itemNames: string, statusids: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: ItemSales;  }> {
        const localVarPath = this.basePath + '/accounting/account/wkMd2g/reports/accounting/item_sales';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'startDate' is not null or undefined
        if (startDate === null || startDate === undefined) {
            throw new Error('Required parameter startDate was null or undefined when calling accountingAccountWkMd2gReportsAccountingItemSalesGet.');
        }

        // verify required parameter 'endDate' is not null or undefined
        if (endDate === null || endDate === undefined) {
            throw new Error('Required parameter endDate was null or undefined when calling accountingAccountWkMd2gReportsAccountingItemSalesGet.');
        }

        // verify required parameter 'currencyCode' is not null or undefined
        if (currencyCode === null || currencyCode === undefined) {
            throw new Error('Required parameter currencyCode was null or undefined when calling accountingAccountWkMd2gReportsAccountingItemSalesGet.');
        }

        // verify required parameter 'clientids' is not null or undefined
        if (clientids === null || clientids === undefined) {
            throw new Error('Required parameter clientids was null or undefined when calling accountingAccountWkMd2gReportsAccountingItemSalesGet.');
        }

        // verify required parameter 'itemNames' is not null or undefined
        if (itemNames === null || itemNames === undefined) {
            throw new Error('Required parameter itemNames was null or undefined when calling accountingAccountWkMd2gReportsAccountingItemSalesGet.');
        }

        // verify required parameter 'statusids' is not null or undefined
        if (statusids === null || statusids === undefined) {
            throw new Error('Required parameter statusids was null or undefined when calling accountingAccountWkMd2gReportsAccountingItemSalesGet.');
        }

        if (startDate !== undefined) {
            localVarQueryParameters['start_date'] = ObjectSerializer.serialize(startDate, "string");
        }

        if (endDate !== undefined) {
            localVarQueryParameters['end_date'] = ObjectSerializer.serialize(endDate, "string");
        }

        if (currencyCode !== undefined) {
            localVarQueryParameters['currency_code'] = ObjectSerializer.serialize(currencyCode, "string");
        }

        if (clientids !== undefined) {
            localVarQueryParameters['clientids'] = ObjectSerializer.serialize(clientids, "number");
        }

        if (itemNames !== undefined) {
            localVarQueryParameters['item_names'] = ObjectSerializer.serialize(itemNames, "string");
        }

        if (statusids !== undefined) {
            localVarQueryParameters['statusids'] = ObjectSerializer.serialize(statusids, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ItemSales;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ItemSales");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * A detailed summary of how much time you and/or your team tracked over a period of time.   *Reminder to not use `Content-Type` when calling for time-entry details*
     * @summary Time Entry Details
     * @param businessId 
     * @param {*} [options] Override http request options.
     */
    public commentsBusinessTimeEntriesSearchByBusinessIdGet (businessId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: TimeEntryDetails;  }> {
        const localVarPath = this.basePath + '/comments/business/{businessId}/time_entries/search'
            .replace('{' + 'businessId' + '}', encodeURIComponent(String(businessId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'businessId' is not null or undefined
        if (businessId === null || businessId === undefined) {
            throw new Error('Required parameter businessId was null or undefined when calling commentsBusinessTimeEntriesSearchByBusinessIdGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TimeEntryDetails;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TimeEntryDetails");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum RetainersApiApiKeys {
}

export class RetainersApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'auth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: RetainersApiApiKeys, value: string) {
        (this.authentications as any)[RetainersApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.auth.accessToken = token;
    }
    /**
     * TODO: Add Description
     * @summary Single Retainer
     * @param businessId 
     * @param retainerId 
     * @param {*} [options] Override http request options.
     */
    public commentsBusinessRetainerByBusinessIdAndRetainerIdGet (businessId: string, retainerId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: GetindividualRetainersuccess;  }> {
        const localVarPath = this.basePath + '/comments/business/{businessId}/retainer/{retainerId}'
            .replace('{' + 'businessId' + '}', encodeURIComponent(String(businessId)))
            .replace('{' + 'retainerId' + '}', encodeURIComponent(String(retainerId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'businessId' is not null or undefined
        if (businessId === null || businessId === undefined) {
            throw new Error('Required parameter businessId was null or undefined when calling commentsBusinessRetainerByBusinessIdAndRetainerIdGet.');
        }

        // verify required parameter 'retainerId' is not null or undefined
        if (retainerId === null || retainerId === undefined) {
            throw new Error('Required parameter retainerId was null or undefined when calling commentsBusinessRetainerByBusinessIdAndRetainerIdGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetindividualRetainersuccess;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetindividualRetainersuccess");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * TODO: Add Description
     * @summary Update Retainer
     * @param contentType 
     * @param body 
     * @param businessId 
     * @param retainerId 
     * @param {*} [options] Override http request options.
     */
    public commentsBusinessRetainerByBusinessIdAndRetainerIdPut (contentType: string, body: UpdateRetainerRequest, businessId: string, retainerId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: UpdateRetainerSuccess;  }> {
        const localVarPath = this.basePath + '/comments/business/{businessId}/retainer/{retainerId}'
            .replace('{' + 'businessId' + '}', encodeURIComponent(String(businessId)))
            .replace('{' + 'retainerId' + '}', encodeURIComponent(String(retainerId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling commentsBusinessRetainerByBusinessIdAndRetainerIdPut.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling commentsBusinessRetainerByBusinessIdAndRetainerIdPut.');
        }

        // verify required parameter 'businessId' is not null or undefined
        if (businessId === null || businessId === undefined) {
            throw new Error('Required parameter businessId was null or undefined when calling commentsBusinessRetainerByBusinessIdAndRetainerIdPut.');
        }

        // verify required parameter 'retainerId' is not null or undefined
        if (retainerId === null || retainerId === undefined) {
            throw new Error('Required parameter retainerId was null or undefined when calling commentsBusinessRetainerByBusinessIdAndRetainerIdPut.');
        }

        localVarHeaderParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "UpdateRetainerRequest")
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UpdateRetainerSuccess;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UpdateRetainerSuccess");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * TODO: Add Description
     * @summary Get all retainers
     * @param businessId 
     * @param {*} [options] Override http request options.
     */
    public commentsBusinessRetainersByBusinessIdGet (businessId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: GetallretainersSuccess;  }> {
        const localVarPath = this.basePath + '/comments/business/{businessId}/retainers'
            .replace('{' + 'businessId' + '}', encodeURIComponent(String(businessId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'businessId' is not null or undefined
        if (businessId === null || businessId === undefined) {
            throw new Error('Required parameter businessId was null or undefined when calling commentsBusinessRetainersByBusinessIdGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetallretainersSuccess;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetallretainersSuccess");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * TODO: Add Description
     * @summary Create Retainer
     * @param contentType 
     * @param body 
     * @param businessId 
     * @param {*} [options] Override http request options.
     */
    public commentsBusinessRetainersByBusinessIdPost (contentType: string, body: CreateRetainerRequest, businessId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: CreateRetainerSuccess;  }> {
        const localVarPath = this.basePath + '/comments/business/{businessId}/retainers'
            .replace('{' + 'businessId' + '}', encodeURIComponent(String(businessId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling commentsBusinessRetainersByBusinessIdPost.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling commentsBusinessRetainersByBusinessIdPost.');
        }

        // verify required parameter 'businessId' is not null or undefined
        if (businessId === null || businessId === undefined) {
            throw new Error('Required parameter businessId was null or undefined when calling commentsBusinessRetainersByBusinessIdPost.');
        }

        localVarHeaderParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CreateRetainerRequest")
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CreateRetainerSuccess;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CreateRetainerSuccess");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum SystemsApiApiKeys {
}

export class SystemsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'auth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: SystemsApiApiKeys, value: string) {
        (this.authentications as any)[SystemsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.auth.accessToken = token;
    }
    /**
     * The value of `<id>` here is only meaningful if a user has access to multiple systems. See the Identity Model for more information.
     * @summary Get System
     * @param contentType 
     * @param accountId 
     * @param businessId 
     * @param {*} [options] Override http request options.
     */
    public accountingAccountSystemsSystemsByAccountIdAndBusinessIdGet (contentType: string, accountId: string, businessId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: GetSystem;  }> {
        const localVarPath = this.basePath + '/accounting/account/{accountId}/systems/systems/{businessId}'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'businessId' + '}', encodeURIComponent(String(businessId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling accountingAccountSystemsSystemsByAccountIdAndBusinessIdGet.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling accountingAccountSystemsSystemsByAccountIdAndBusinessIdGet.');
        }

        // verify required parameter 'businessId' is not null or undefined
        if (businessId === null || businessId === undefined) {
            throw new Error('Required parameter businessId was null or undefined when calling accountingAccountSystemsSystemsByAccountIdAndBusinessIdGet.');
        }

        localVarHeaderParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetSystem;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetSystem");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TasksApiApiKeys {
}

export class TasksApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'auth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TasksApiApiKeys, value: string) {
        (this.authentications as any)[TasksApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.auth.accessToken = token;
    }
    /**
     * TODO: Add Description
     * @summary Single Task
     * @param contentType 
     * @param accountId 
     * @param taskId 
     * @param {*} [options] Override http request options.
     */
    public accountingAccountProjectsTasksByAccountIdAndTaskIdGet (contentType: string, accountId: string, taskId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: SingleTask;  }> {
        const localVarPath = this.basePath + '/accounting/account/{accountId}/projects/tasks/{taskId}'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'taskId' + '}', encodeURIComponent(String(taskId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling accountingAccountProjectsTasksByAccountIdAndTaskIdGet.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling accountingAccountProjectsTasksByAccountIdAndTaskIdGet.');
        }

        // verify required parameter 'taskId' is not null or undefined
        if (taskId === null || taskId === undefined) {
            throw new Error('Required parameter taskId was null or undefined when calling accountingAccountProjectsTasksByAccountIdAndTaskIdGet.');
        }

        localVarHeaderParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SingleTask;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SingleTask");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * TODO: Add Description
     * @summary Update Task
     * @param contentType 
     * @param body 
     * @param accountId 
     * @param taskId 
     * @param {*} [options] Override http request options.
     */
    public accountingAccountProjectsTasksByAccountIdAndTaskIdPut (contentType: string, body: UpdateTaskRequest, accountId: string, taskId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: UpdateTask;  }> {
        const localVarPath = this.basePath + '/accounting/account/{accountId}/projects/tasks/{taskId}'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'taskId' + '}', encodeURIComponent(String(taskId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling accountingAccountProjectsTasksByAccountIdAndTaskIdPut.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling accountingAccountProjectsTasksByAccountIdAndTaskIdPut.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling accountingAccountProjectsTasksByAccountIdAndTaskIdPut.');
        }

        // verify required parameter 'taskId' is not null or undefined
        if (taskId === null || taskId === undefined) {
            throw new Error('Required parameter taskId was null or undefined when calling accountingAccountProjectsTasksByAccountIdAndTaskIdPut.');
        }

        localVarHeaderParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "UpdateTaskRequest")
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UpdateTask;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UpdateTask");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * TODO: Add Description
     * @summary List Tasks
     * @param contentType 
     * @param accountId 
     * @param {*} [options] Override http request options.
     */
    public accountingAccountProjectsTasksByAccountIdGet (contentType: string, accountId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: ListTasks;  }> {
        const localVarPath = this.basePath + '/accounting/account/{accountId}/projects/tasks'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling accountingAccountProjectsTasksByAccountIdGet.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling accountingAccountProjectsTasksByAccountIdGet.');
        }

        localVarHeaderParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ListTasks;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ListTasks");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * TODO: Add Description
     * @summary Create Task
     * @param contentType 
     * @param body 
     * @param accountId 
     * @param {*} [options] Override http request options.
     */
    public accountingAccountProjectsTasksByAccountIdPost (contentType: string, body: CreateTaskRequest, accountId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: CreateTask;  }> {
        const localVarPath = this.basePath + '/accounting/account/{accountId}/projects/tasks'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling accountingAccountProjectsTasksByAccountIdPost.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling accountingAccountProjectsTasksByAccountIdPost.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling accountingAccountProjectsTasksByAccountIdPost.');
        }

        localVarHeaderParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CreateTaskRequest")
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CreateTask;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CreateTask");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TaxesApiApiKeys {
}

export class TaxesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'auth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TaxesApiApiKeys, value: string) {
        (this.authentications as any)[TaxesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.auth.accessToken = token;
    }
    /**
     * TODO: Add Description
     * @summary Delete Single Tax
     * @param accountId 
     * @param taxId 
     * @param {*} [options] Override http request options.
     */
    public accountingAccountTaxesTaxesByAccountIdAndTaxIdDelete (accountId: string, taxId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: DeleteSingleTax;  }> {
        const localVarPath = this.basePath + '/accounting/account/{accountId}/taxes/taxes/{taxId}'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'taxId' + '}', encodeURIComponent(String(taxId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling accountingAccountTaxesTaxesByAccountIdAndTaxIdDelete.');
        }

        // verify required parameter 'taxId' is not null or undefined
        if (taxId === null || taxId === undefined) {
            throw new Error('Required parameter taxId was null or undefined when calling accountingAccountTaxesTaxesByAccountIdAndTaxIdDelete.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DeleteSingleTax;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DeleteSingleTax");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * TODO: Add Description
     * @summary Get Single Tax
     * @param accountId 
     * @param taxId 
     * @param {*} [options] Override http request options.
     */
    public accountingAccountTaxesTaxesByAccountIdAndTaxIdGet (accountId: string, taxId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: GetSingleTax;  }> {
        const localVarPath = this.basePath + '/accounting/account/{accountId}/taxes/taxes/{taxId}'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'taxId' + '}', encodeURIComponent(String(taxId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling accountingAccountTaxesTaxesByAccountIdAndTaxIdGet.');
        }

        // verify required parameter 'taxId' is not null or undefined
        if (taxId === null || taxId === undefined) {
            throw new Error('Required parameter taxId was null or undefined when calling accountingAccountTaxesTaxesByAccountIdAndTaxIdGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetSingleTax;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetSingleTax");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * TODO: Add Description
     * @summary Update Single Tax
     * @param contentType 
     * @param body 
     * @param accountId 
     * @param taxId 
     * @param {*} [options] Override http request options.
     */
    public accountingAccountTaxesTaxesByAccountIdAndTaxIdPut (contentType: string, body: UpdateSingleTaxRequest, accountId: string, taxId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: UpdateSingleTax;  }> {
        const localVarPath = this.basePath + '/accounting/account/{accountId}/taxes/taxes/{taxId}'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'taxId' + '}', encodeURIComponent(String(taxId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling accountingAccountTaxesTaxesByAccountIdAndTaxIdPut.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling accountingAccountTaxesTaxesByAccountIdAndTaxIdPut.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling accountingAccountTaxesTaxesByAccountIdAndTaxIdPut.');
        }

        // verify required parameter 'taxId' is not null or undefined
        if (taxId === null || taxId === undefined) {
            throw new Error('Required parameter taxId was null or undefined when calling accountingAccountTaxesTaxesByAccountIdAndTaxIdPut.');
        }

        localVarHeaderParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "UpdateSingleTaxRequest")
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UpdateSingleTax;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UpdateSingleTax");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * TODO: Add Description
     * @summary List Taxes
     * @param accountId 
     * @param {*} [options] Override http request options.
     */
    public accountingAccountTaxesTaxesByAccountIdGet (accountId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: ListTaxes;  }> {
        const localVarPath = this.basePath + '/accounting/account/{accountId}/taxes/taxes'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling accountingAccountTaxesTaxesByAccountIdGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ListTaxes;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ListTaxes");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * TODO: Add Description
     * @summary Create Single Tax
     * @param contentType 
     * @param body 
     * @param accountId 
     * @param {*} [options] Override http request options.
     */
    public accountingAccountTaxesTaxesByAccountIdPost (contentType: string, body: CreateSingleTaxRequest, accountId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: CreateSingleTax1;  }> {
        const localVarPath = this.basePath + '/accounting/account/{accountId}/taxes/taxes'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling accountingAccountTaxesTaxesByAccountIdPost.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling accountingAccountTaxesTaxesByAccountIdPost.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling accountingAccountTaxesTaxesByAccountIdPost.');
        }

        localVarHeaderParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CreateSingleTaxRequest")
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CreateSingleTax1;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CreateSingleTax1");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TimeTrackingApiApiKeys {
}

export class TimeTrackingApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'auth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TimeTrackingApiApiKeys, value: string) {
        (this.authentications as any)[TimeTrackingApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.auth.accessToken = token;
    }
    /**
     * TODO: Add Description
     * @summary Delete a Time Entry
     * @param businessId 
     * @param timeEntryId 
     * @param {*} [options] Override http request options.
     */
    public timetrackingBusinessTimeEntriesByBusinessIdAndTimeEntryIdDelete (businessId: string, timeEntryId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/timetracking/business/{businessId}/time_entries/{timeEntryId}'
            .replace('{' + 'businessId' + '}', encodeURIComponent(String(businessId)))
            .replace('{' + 'timeEntryId' + '}', encodeURIComponent(String(timeEntryId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'businessId' is not null or undefined
        if (businessId === null || businessId === undefined) {
            throw new Error('Required parameter businessId was null or undefined when calling timetrackingBusinessTimeEntriesByBusinessIdAndTimeEntryIdDelete.');
        }

        // verify required parameter 'timeEntryId' is not null or undefined
        if (timeEntryId === null || timeEntryId === undefined) {
            throw new Error('Required parameter timeEntryId was null or undefined when calling timetrackingBusinessTimeEntriesByBusinessIdAndTimeEntryIdDelete.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * TODO: Add Description
     * @summary Update a Time Entry
     * @param body 
     * @param businessId 
     * @param timeEntryId 
     * @param {*} [options] Override http request options.
     */
    public timetrackingBusinessTimeEntriesByBusinessIdAndTimeEntryIdPut (body: string, businessId: string, timeEntryId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: UpdateaTimeEntry;  }> {
        const localVarPath = this.basePath + '/timetracking/business/{businessId}/time_entries/{timeEntryId}'
            .replace('{' + 'businessId' + '}', encodeURIComponent(String(businessId)))
            .replace('{' + 'timeEntryId' + '}', encodeURIComponent(String(timeEntryId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling timetrackingBusinessTimeEntriesByBusinessIdAndTimeEntryIdPut.');
        }

        // verify required parameter 'businessId' is not null or undefined
        if (businessId === null || businessId === undefined) {
            throw new Error('Required parameter businessId was null or undefined when calling timetrackingBusinessTimeEntriesByBusinessIdAndTimeEntryIdPut.');
        }

        // verify required parameter 'timeEntryId' is not null or undefined
        if (timeEntryId === null || timeEntryId === undefined) {
            throw new Error('Required parameter timeEntryId was null or undefined when calling timetrackingBusinessTimeEntriesByBusinessIdAndTimeEntryIdPut.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "string")
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UpdateaTimeEntry;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UpdateaTimeEntry");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * TODO: Add Description
     * @summary List Entries
     * @param businessId 
     * @param {*} [options] Override http request options.
     */
    public timetrackingBusinessTimeEntriesByBusinessIdGet (businessId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: ListEntries;  }> {
        const localVarPath = this.basePath + '/timetracking/business/{businessId}/time_entries'
            .replace('{' + 'businessId' + '}', encodeURIComponent(String(businessId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'businessId' is not null or undefined
        if (businessId === null || businessId === undefined) {
            throw new Error('Required parameter businessId was null or undefined when calling timetrackingBusinessTimeEntriesByBusinessIdGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ListEntries;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ListEntries");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * TODO: Add Description
     * @summary Create a Time Entry
     * @param body 
     * @param businessId 
     * @param {*} [options] Override http request options.
     */
    public timetrackingBusinessTimeEntriesByBusinessIdPost (body: string, businessId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: CreateaTimeEntry;  }> {
        const localVarPath = this.basePath + '/timetracking/business/{businessId}/time_entries'
            .replace('{' + 'businessId' + '}', encodeURIComponent(String(businessId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling timetrackingBusinessTimeEntriesByBusinessIdPost.');
        }

        // verify required parameter 'businessId' is not null or undefined
        if (businessId === null || businessId === undefined) {
            throw new Error('Required parameter businessId was null or undefined when calling timetrackingBusinessTimeEntriesByBusinessIdPost.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "string")
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CreateaTimeEntry;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CreateaTimeEntry");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Currently you have to search for employee using their employee name and not an ID. 
     * @summary Time Entries For Employee on Specific Project
     * @param q 
     * @param sort 
     * @param useSearchEndpoint 
     * @param businessId 
     * @param {*} [options] Override http request options.
     */
    public timetrackingBusinessTimeEntriesSearchByBusinessIdGet (q: string, sort: string, useSearchEndpoint: boolean, businessId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/timetracking/business/{businessId}/time_entries/search'
            .replace('{' + 'businessId' + '}', encodeURIComponent(String(businessId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'q' is not null or undefined
        if (q === null || q === undefined) {
            throw new Error('Required parameter q was null or undefined when calling timetrackingBusinessTimeEntriesSearchByBusinessIdGet.');
        }

        // verify required parameter 'sort' is not null or undefined
        if (sort === null || sort === undefined) {
            throw new Error('Required parameter sort was null or undefined when calling timetrackingBusinessTimeEntriesSearchByBusinessIdGet.');
        }

        // verify required parameter 'useSearchEndpoint' is not null or undefined
        if (useSearchEndpoint === null || useSearchEndpoint === undefined) {
            throw new Error('Required parameter useSearchEndpoint was null or undefined when calling timetrackingBusinessTimeEntriesSearchByBusinessIdGet.');
        }

        // verify required parameter 'businessId' is not null or undefined
        if (businessId === null || businessId === undefined) {
            throw new Error('Required parameter businessId was null or undefined when calling timetrackingBusinessTimeEntriesSearchByBusinessIdGet.');
        }

        if (q !== undefined) {
            localVarQueryParameters['q'] = ObjectSerializer.serialize(q, "string");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }

        if (useSearchEndpoint !== undefined) {
            localVarQueryParameters['useSearchEndpoint'] = ObjectSerializer.serialize(useSearchEndpoint, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UploadLogoApiApiKeys {
}

export class UploadLogoApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'auth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: UploadLogoApiApiKeys, value: string) {
        (this.authentications as any)[UploadLogoApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.auth.accessToken = token;
    }
    /**
     * TODO: Add Description
     * @summary Upload Logo
     * @param content 
     * @param accountId 
     * @param {*} [options] Override http request options.
     */
    public uploadsAccountImagesByAccountIdPost (content: string, accountId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: UploadLogo;  }> {
        const localVarPath = this.basePath + '/uploads/account/{accountId}/images'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'content' is not null or undefined
        if (content === null || content === undefined) {
            throw new Error('Required parameter content was null or undefined when calling uploadsAccountImagesByAccountIdPost.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling uploadsAccountImagesByAccountIdPost.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (content !== undefined) {
            localVarFormParams['content'] = ObjectSerializer.serialize(content, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UploadLogo;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UploadLogo");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UploaderApiApiKeys {
}

export class UploaderApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'auth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: UploaderApiApiKeys, value: string) {
        (this.authentications as any)[UploaderApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.auth.accessToken = token;
    }
    /**
     * TODO: Add Description
     * @summary Upload File
     * @param content 
     * @param accountId 
     * @param {*} [options] Override http request options.
     */
    public uploadsAccountAttachmentsByAccountIdPost (content: string, accountId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/uploads/account/{accountId}/attachments'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'content' is not null or undefined
        if (content === null || content === undefined) {
            throw new Error('Required parameter content was null or undefined when calling uploadsAccountAttachmentsByAccountIdPost.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling uploadsAccountAttachmentsByAccountIdPost.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (content !== undefined) {
            localVarFormParams['content'] = ObjectSerializer.serialize(content, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum WebhooksApiApiKeys {
}

export class WebhooksApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'auth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: WebhooksApiApiKeys, value: string) {
        (this.authentications as any)[WebhooksApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.auth.accessToken = token;
    }
    /**
     * TODO: Add Description
     * @summary Delete Webhook Callback
     * @param accountId 
     * @param callbackId 
     * @param {*} [options] Override http request options.
     */
    public eventsAccountEventsCallbacksByAccountIdAndCallbackIdDelete (accountId: string, callbackId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/events/account/{accountId}/events/callbacks/{callbackId}'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'callbackId' + '}', encodeURIComponent(String(callbackId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling eventsAccountEventsCallbacksByAccountIdAndCallbackIdDelete.');
        }

        // verify required parameter 'callbackId' is not null or undefined
        if (callbackId === null || callbackId === undefined) {
            throw new Error('Required parameter callbackId was null or undefined when calling eventsAccountEventsCallbacksByAccountIdAndCallbackIdDelete.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * ## Verifying Webhooks  Each Webhook sent by FreshBooks includes a header, X-FreshBooks-Hmac-SHA256, with a base64-encoded signature generated using with the data sent in the request and token originally sent in the web hook verification process as a secret.  When you receive the webhook, you can verify that it came from FreshBooks by computing the signature and comparing it against the header.  When generating your cryptographic hash function, you will have two inputs.   1. Your string input will be the response parameters which you will need to enter as a JSON String.   i.e. `message = '{\"name\": \"client.update\", \"object_id\": \"177864\", \"user_id\": \"1\", \"account_id\": \"K1pdgJ\"}'`   2. Your verifier (or 'secret') is sent as a response from your initial webhook registration.   It is also important that you maintain spaces between all colons and commas.    You will also need to make sure that your verifier is a base64 encoded string.   Here is an example script in Python:    ``` import base64 import hmac import hashlib  verifier = \"UWQfd9zCzxmVwFZWKqqKwLxqz8gvzGdAn\" message = '{\"name\": \"client.update\", \"object_id\": \"177864\", \"user_id\": \"1\", \"account_id\": \"FrEsHb\"}' dig = hmac.new(     verifier,     msg=message,     digestmod=hashlib.sha256 ).digest() print(base64.b64encode(dig).decode()) ```  and an example in Node.js:   ``` const crypto = require('crypto') const utf8 = require('utf8');  const hmac = hmac256(utf8.encode('{\"name\": \"client.update\", \"object_id\": \"177864\", \"user_id\": \"1\", \"account_id\": \"FrEsHb\"}'),    Buffer.from(utf8.encode('UWQfd9zCzxmVwFZWKqqKwLxqz8gvzGdAn')),    'base64')  console.log(hmac)    function hmac256(data, authKey, encoding) {    const x = crypto.createHmac('sha256', authKey)   x.update(data)   return x.digest(encoding) } ``` 
     * @summary Verify Webhook Callback
     * @param contentType 
     * @param body 
     * @param accountId 
     * @param callbackId 
     * @param {*} [options] Override http request options.
     */
    public eventsAccountEventsCallbacksByAccountIdAndCallbackIdPut (contentType: string, body: string, accountId: string, callbackId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/events/account/{accountId}/events/callbacks/{callbackId}'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'callbackId' + '}', encodeURIComponent(String(callbackId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling eventsAccountEventsCallbacksByAccountIdAndCallbackIdPut.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling eventsAccountEventsCallbacksByAccountIdAndCallbackIdPut.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling eventsAccountEventsCallbacksByAccountIdAndCallbackIdPut.');
        }

        // verify required parameter 'callbackId' is not null or undefined
        if (callbackId === null || callbackId === undefined) {
            throw new Error('Required parameter callbackId was null or undefined when calling eventsAccountEventsCallbacksByAccountIdAndCallbackIdPut.');
        }

        localVarHeaderParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "string")
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * TODO: Add Description
     * @summary List Webhook Callbacks
     * @param accountId 
     * @param {*} [options] Override http request options.
     */
    public eventsAccountEventsCallbacksByAccountIdGet (accountId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: ListWebhookCallbacks;  }> {
        const localVarPath = this.basePath + '/events/account/{accountId}/events/callbacks'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling eventsAccountEventsCallbacksByAccountIdGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ListWebhookCallbacks;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ListWebhookCallbacks");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * ## Events 
     * @summary Register for Callback
     * @param contentType 
     * @param body 
     * @param accountId 
     * @param {*} [options] Override http request options.
     */
    public eventsAccountEventsCallbacksByAccountIdPost (contentType: string, body: RegisterforCallbackRequest, accountId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/events/account/{accountId}/events/callbacks'
            .replace('{' + 'accountId' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling eventsAccountEventsCallbacksByAccountIdPost.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling eventsAccountEventsCallbacksByAccountIdPost.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling eventsAccountEventsCallbacksByAccountIdPost.');
        }

        localVarHeaderParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "RegisterforCallbackRequest")
        };

        this.authentications.auth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
